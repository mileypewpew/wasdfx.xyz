{
  "version": 3,
  "sources": ["../../../../node_modules/drizzle-orm/entity.js", "../../../../node_modules/drizzle-orm/logger.js", "../../../../node_modules/drizzle-orm/query-promise.js", "../../../../node_modules/drizzle-orm/column.js", "../../../../node_modules/drizzle-orm/column-builder.js", "../../../../node_modules/drizzle-orm/table.utils.js", "../../../../node_modules/drizzle-orm/pg-core/foreign-keys.js", "../../../../node_modules/drizzle-orm/tracing-utils.js", "../../../../node_modules/drizzle-orm/pg-core/unique-constraint.js", "../../../../node_modules/drizzle-orm/pg-core/utils/array.js", "../../../../node_modules/drizzle-orm/pg-core/columns/common.js", "../../../../node_modules/drizzle-orm/pg-core/columns/enum.js", "../../../../node_modules/drizzle-orm/subquery.js", "../../../../node_modules/drizzle-orm/version.js", "../../../../node_modules/drizzle-orm/tracing.js", "../../../../node_modules/drizzle-orm/view-common.js", "../../../../node_modules/drizzle-orm/table.js", "../../../../node_modules/drizzle-orm/sql/sql.js", "../../../../node_modules/drizzle-orm/alias.js", "../../../../node_modules/drizzle-orm/selection-proxy.js", "../../../../node_modules/drizzle-orm/utils.js", "../../../../node_modules/drizzle-orm/pg-core/columns/int.common.js", "../../../../node_modules/drizzle-orm/pg-core/columns/bigint.js", "../../../../node_modules/drizzle-orm/pg-core/columns/bigserial.js", "../../../../node_modules/drizzle-orm/pg-core/columns/boolean.js", "../../../../node_modules/drizzle-orm/pg-core/columns/char.js", "../../../../node_modules/drizzle-orm/pg-core/columns/cidr.js", "../../../../node_modules/drizzle-orm/pg-core/columns/custom.js", "../../../../node_modules/drizzle-orm/pg-core/columns/date.common.js", "../../../../node_modules/drizzle-orm/pg-core/columns/date.js", "../../../../node_modules/drizzle-orm/pg-core/columns/double-precision.js", "../../../../node_modules/drizzle-orm/pg-core/columns/inet.js", "../../../../node_modules/drizzle-orm/pg-core/columns/integer.js", "../../../../node_modules/drizzle-orm/pg-core/columns/interval.js", "../../../../node_modules/drizzle-orm/pg-core/columns/json.js", "../../../../node_modules/drizzle-orm/pg-core/columns/jsonb.js", "../../../../node_modules/drizzle-orm/pg-core/columns/line.js", "../../../../node_modules/drizzle-orm/pg-core/columns/macaddr.js", "../../../../node_modules/drizzle-orm/pg-core/columns/macaddr8.js", "../../../../node_modules/drizzle-orm/pg-core/columns/numeric.js", "../../../../node_modules/drizzle-orm/pg-core/columns/point.js", "../../../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js", "../../../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js", "../../../../node_modules/drizzle-orm/pg-core/columns/real.js", "../../../../node_modules/drizzle-orm/pg-core/columns/serial.js", "../../../../node_modules/drizzle-orm/pg-core/columns/smallint.js", "../../../../node_modules/drizzle-orm/pg-core/columns/smallserial.js", "../../../../node_modules/drizzle-orm/pg-core/columns/text.js", "../../../../node_modules/drizzle-orm/pg-core/columns/time.js", "../../../../node_modules/drizzle-orm/pg-core/columns/timestamp.js", "../../../../node_modules/drizzle-orm/pg-core/columns/uuid.js", "../../../../node_modules/drizzle-orm/pg-core/columns/varchar.js", "../../../../node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js", "../../../../node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js", "../../../../node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js", "../../../../node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js", "../../../../node_modules/drizzle-orm/pg-core/columns/all.js", "../../../../node_modules/drizzle-orm/pg-core/table.js", "../../../../node_modules/drizzle-orm/pg-core/checks.js", "../../../../node_modules/drizzle-orm/pg-core/columns/index.js", "../../../../node_modules/drizzle-orm/pg-core/indexes.js", "../../../../node_modules/drizzle-orm/pg-core/policies.js", "../../../../node_modules/drizzle-orm/pg-core/primary-keys.js", "../../../../node_modules/drizzle-orm/pg-core/view-common.js", "../../../../node_modules/drizzle-orm/casing.js", "../../../../node_modules/drizzle-orm/errors.js", "../../../../node_modules/drizzle-orm/sql/expressions/conditions.js", "../../../../node_modules/drizzle-orm/sql/expressions/select.js", "../../../../node_modules/drizzle-orm/sql/expressions/index.js", "../../../../node_modules/drizzle-orm/relations.js", "../../../../node_modules/drizzle-orm/sql/functions/aggregate.js", "../../../../node_modules/drizzle-orm/sql/functions/vector.js", "../../../../node_modules/drizzle-orm/sql/functions/index.js", "../../../../node_modules/drizzle-orm/sql/index.js", "../../../../node_modules/drizzle-orm/pg-core/view-base.js", "../../../../node_modules/drizzle-orm/pg-core/dialect.js", "../../../../node_modules/drizzle-orm/query-builders/query-builder.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/select.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js", "../../../../node_modules/drizzle-orm/pg-core/view.js", "../../../../node_modules/drizzle-orm/pg-core/utils.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/delete.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/insert.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/update.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/index.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/count.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/query.js", "../../../../node_modules/drizzle-orm/pg-core/query-builders/raw.js", "../../../../node_modules/drizzle-orm/pg-core/db.js", "../../../../node_modules/drizzle-orm/cache/core/cache.js", "../../../../node_modules/drizzle-orm/pg-core/session.js", "../../../../node_modules/drizzle-orm/pg-core/utils/index.js", "../../../../node_modules/drizzle-orm/pg-core/index.js", "../../../../node_modules/drizzle-orm/index.js", "../../src/runtime-migrator/storage/migration-tracker.ts", "../../src/runtime-migrator/storage/journal-storage.ts", "../../src/runtime-migrator/storage/snapshot-storage.ts", "../../src/runtime-migrator/extension-manager.ts", "../../src/runtime-migrator/drizzle-adapters/snapshot-generator.ts", "../../src/runtime-migrator/drizzle-adapters/diff-calculator.ts", "../../src/runtime-migrator/drizzle-adapters/sql-generator.ts", "../../src/runtime-migrator/schema-transformer.ts", "../../src/runtime-migrator/drizzle-adapters/database-introspector.ts", "../../src/runtime-migrator/runtime-migrator.ts", "../../src/runtime-migrator/index.ts", "../../src/migration-service.ts", "../../src/index.node.ts", "../../src/pglite/adapter.ts", "../../../../node_modules/drizzle-orm/pglite/driver.js", "../../../../node_modules/drizzle-orm/pglite/session.js", "../../src/base.ts", "../../src/schema/embedding.ts", "../../src/schema/memory.ts", "../../src/schema/agent.ts", "../../src/schema/entity.ts", "../../src/schema/room.ts", "../../src/schema/cache.ts", "../../src/schema/component.ts", "../../src/schema/world.ts", "../../src/schema/log.ts", "../../src/schema/participant.ts", "../../src/schema/relationship.ts", "../../src/schema/tasks.ts", "../../src/schema/messageServer.ts", "../../src/schema/channel.ts", "../../src/schema/message.ts", "../../src/schema/channelParticipant.ts", "../../src/schema/serverAgent.ts", "../../src/pglite/manager.ts", "../../src/pg/adapter.ts", "../../../../node_modules/drizzle-orm/node-postgres/driver.js", "../../../../node_modules/drizzle-orm/node-postgres/session.js", "../../src/pg/manager.ts", "../../src/utils.node.ts"],
  "sourcesContent": [
    "const entityKind = Symbol.for(\"drizzle:entityKind\");\nconst hasOwnEntityKind = Symbol.for(\"drizzle:hasOwnEntityKind\");\nfunction is(value, type) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  if (value instanceof type) {\n    return true;\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n    throw new Error(\n      `Class \"${type.name ?? \"<unknown>\"}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`\n    );\n  }\n  let cls = Object.getPrototypeOf(value).constructor;\n  if (cls) {\n    while (cls) {\n      if (entityKind in cls && cls[entityKind] === type[entityKind]) {\n        return true;\n      }\n      cls = Object.getPrototypeOf(cls);\n    }\n  }\n  return false;\n}\nexport {\n  entityKind,\n  hasOwnEntityKind,\n  is\n};\n//# sourceMappingURL=entity.js.map",
    "import { entityKind } from \"./entity.js\";\nclass ConsoleLogWriter {\n  static [entityKind] = \"ConsoleLogWriter\";\n  write(message) {\n    console.log(message);\n  }\n}\nclass DefaultLogger {\n  static [entityKind] = \"DefaultLogger\";\n  writer;\n  constructor(config) {\n    this.writer = config?.writer ?? new ConsoleLogWriter();\n  }\n  logQuery(query, params) {\n    const stringifiedParams = params.map((p) => {\n      try {\n        return JSON.stringify(p);\n      } catch {\n        return String(p);\n      }\n    });\n    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(\", \")}]` : \"\";\n    this.writer.write(`Query: ${query}${paramsStr}`);\n  }\n}\nclass NoopLogger {\n  static [entityKind] = \"NoopLogger\";\n  logQuery() {\n  }\n}\nexport {\n  ConsoleLogWriter,\n  DefaultLogger,\n  NoopLogger\n};\n//# sourceMappingURL=logger.js.map",
    "import { entityKind } from \"./entity.js\";\nclass QueryPromise {\n  static [entityKind] = \"QueryPromise\";\n  [Symbol.toStringTag] = \"QueryPromise\";\n  catch(onRejected) {\n    return this.then(void 0, onRejected);\n  }\n  finally(onFinally) {\n    return this.then(\n      (value) => {\n        onFinally?.();\n        return value;\n      },\n      (reason) => {\n        onFinally?.();\n        throw reason;\n      }\n    );\n  }\n  then(onFulfilled, onRejected) {\n    return this.execute().then(onFulfilled, onRejected);\n  }\n}\nexport {\n  QueryPromise\n};\n//# sourceMappingURL=query-promise.js.map",
    "import { entityKind } from \"./entity.js\";\nclass Column {\n  constructor(table, config) {\n    this.table = table;\n    this.config = config;\n    this.name = config.name;\n    this.keyAsName = config.keyAsName;\n    this.notNull = config.notNull;\n    this.default = config.default;\n    this.defaultFn = config.defaultFn;\n    this.onUpdateFn = config.onUpdateFn;\n    this.hasDefault = config.hasDefault;\n    this.primary = config.primaryKey;\n    this.isUnique = config.isUnique;\n    this.uniqueName = config.uniqueName;\n    this.uniqueType = config.uniqueType;\n    this.dataType = config.dataType;\n    this.columnType = config.columnType;\n    this.generated = config.generated;\n    this.generatedIdentity = config.generatedIdentity;\n  }\n  static [entityKind] = \"Column\";\n  name;\n  keyAsName;\n  primary;\n  notNull;\n  default;\n  defaultFn;\n  onUpdateFn;\n  hasDefault;\n  isUnique;\n  uniqueName;\n  uniqueType;\n  dataType;\n  columnType;\n  enumValues = void 0;\n  generated = void 0;\n  generatedIdentity = void 0;\n  config;\n  mapFromDriverValue(value) {\n    return value;\n  }\n  mapToDriverValue(value) {\n    return value;\n  }\n  // ** @internal */\n  shouldDisableInsert() {\n    return this.config.generated !== void 0 && this.config.generated.type !== \"byDefault\";\n  }\n}\nexport {\n  Column\n};\n//# sourceMappingURL=column.js.map",
    "import { entityKind } from \"./entity.js\";\nclass ColumnBuilder {\n  static [entityKind] = \"ColumnBuilder\";\n  config;\n  constructor(name, dataType, columnType) {\n    this.config = {\n      name,\n      keyAsName: name === \"\",\n      notNull: false,\n      default: void 0,\n      hasDefault: false,\n      primaryKey: false,\n      isUnique: false,\n      uniqueName: void 0,\n      uniqueType: void 0,\n      dataType,\n      columnType,\n      generated: void 0\n    };\n  }\n  /**\n   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n   *\n   * @example\n   * ```ts\n   * const users = pgTable('users', {\n   * \tid: integer('id').$type<UserId>().primaryKey(),\n   * \tdetails: json('details').$type<UserDetails>().notNull(),\n   * });\n   * ```\n   */\n  $type() {\n    return this;\n  }\n  /**\n   * Adds a `not null` clause to the column definition.\n   *\n   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n   */\n  notNull() {\n    this.config.notNull = true;\n    return this;\n  }\n  /**\n   * Adds a `default <value>` clause to the column definition.\n   *\n   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n   *\n   * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n   */\n  default(value) {\n    this.config.default = value;\n    this.config.hasDefault = true;\n    return this;\n  }\n  /**\n   * Adds a dynamic default value to the column.\n   * The function will be called when the row is inserted, and the returned value will be used as the column value.\n   *\n   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n   */\n  $defaultFn(fn) {\n    this.config.defaultFn = fn;\n    this.config.hasDefault = true;\n    return this;\n  }\n  /**\n   * Alias for {@link $defaultFn}.\n   */\n  $default = this.$defaultFn;\n  /**\n   * Adds a dynamic update value to the column.\n   * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n   * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n   *\n   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n   */\n  $onUpdateFn(fn) {\n    this.config.onUpdateFn = fn;\n    this.config.hasDefault = true;\n    return this;\n  }\n  /**\n   * Alias for {@link $onUpdateFn}.\n   */\n  $onUpdate = this.$onUpdateFn;\n  /**\n   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n   *\n   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n   */\n  primaryKey() {\n    this.config.primaryKey = true;\n    this.config.notNull = true;\n    return this;\n  }\n  /** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n  setName(name) {\n    if (this.config.name !== \"\") return;\n    this.config.name = name;\n  }\n}\nexport {\n  ColumnBuilder\n};\n//# sourceMappingURL=column-builder.js.map",
    "const TableName = Symbol.for(\"drizzle:Name\");\nexport {\n  TableName\n};\n//# sourceMappingURL=table.utils.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { TableName } from \"../table.utils.js\";\nclass ForeignKeyBuilder {\n  static [entityKind] = \"PgForeignKeyBuilder\";\n  /** @internal */\n  reference;\n  /** @internal */\n  _onUpdate = \"no action\";\n  /** @internal */\n  _onDelete = \"no action\";\n  constructor(config, actions) {\n    this.reference = () => {\n      const { name, columns, foreignColumns } = config();\n      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };\n    };\n    if (actions) {\n      this._onUpdate = actions.onUpdate;\n      this._onDelete = actions.onDelete;\n    }\n  }\n  onUpdate(action) {\n    this._onUpdate = action === void 0 ? \"no action\" : action;\n    return this;\n  }\n  onDelete(action) {\n    this._onDelete = action === void 0 ? \"no action\" : action;\n    return this;\n  }\n  /** @internal */\n  build(table) {\n    return new ForeignKey(table, this);\n  }\n}\nclass ForeignKey {\n  constructor(table, builder) {\n    this.table = table;\n    this.reference = builder.reference;\n    this.onUpdate = builder._onUpdate;\n    this.onDelete = builder._onDelete;\n  }\n  static [entityKind] = \"PgForeignKey\";\n  reference;\n  onUpdate;\n  onDelete;\n  getName() {\n    const { name, columns, foreignColumns } = this.reference();\n    const columnNames = columns.map((column) => column.name);\n    const foreignColumnNames = foreignColumns.map((column) => column.name);\n    const chunks = [\n      this.table[TableName],\n      ...columnNames,\n      foreignColumns[0].table[TableName],\n      ...foreignColumnNames\n    ];\n    return name ?? `${chunks.join(\"_\")}_fk`;\n  }\n}\nfunction foreignKey(config) {\n  function mappedConfig() {\n    const { name, columns, foreignColumns } = config;\n    return {\n      name,\n      columns,\n      foreignColumns\n    };\n  }\n  return new ForeignKeyBuilder(mappedConfig);\n}\nexport {\n  ForeignKey,\n  ForeignKeyBuilder,\n  foreignKey\n};\n//# sourceMappingURL=foreign-keys.js.map",
    "function iife(fn, ...args) {\n  return fn(...args);\n}\nexport {\n  iife\n};\n//# sourceMappingURL=tracing-utils.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { TableName } from \"../table.utils.js\";\nfunction unique(name) {\n  return new UniqueOnConstraintBuilder(name);\n}\nfunction uniqueKeyName(table, columns) {\n  return `${table[TableName]}_${columns.join(\"_\")}_unique`;\n}\nclass UniqueConstraintBuilder {\n  constructor(columns, name) {\n    this.name = name;\n    this.columns = columns;\n  }\n  static [entityKind] = \"PgUniqueConstraintBuilder\";\n  /** @internal */\n  columns;\n  /** @internal */\n  nullsNotDistinctConfig = false;\n  nullsNotDistinct() {\n    this.nullsNotDistinctConfig = true;\n    return this;\n  }\n  /** @internal */\n  build(table) {\n    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n  }\n}\nclass UniqueOnConstraintBuilder {\n  static [entityKind] = \"PgUniqueOnConstraintBuilder\";\n  /** @internal */\n  name;\n  constructor(name) {\n    this.name = name;\n  }\n  on(...columns) {\n    return new UniqueConstraintBuilder(columns, this.name);\n  }\n}\nclass UniqueConstraint {\n  constructor(table, columns, nullsNotDistinct, name) {\n    this.table = table;\n    this.columns = columns;\n    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n    this.nullsNotDistinct = nullsNotDistinct;\n  }\n  static [entityKind] = \"PgUniqueConstraint\";\n  columns;\n  name;\n  nullsNotDistinct = false;\n  getName() {\n    return this.name;\n  }\n}\nexport {\n  UniqueConstraint,\n  UniqueConstraintBuilder,\n  UniqueOnConstraintBuilder,\n  unique,\n  uniqueKeyName\n};\n//# sourceMappingURL=unique-constraint.js.map",
    "function parsePgArrayValue(arrayString, startFrom, inQuotes) {\n  for (let i = startFrom; i < arrayString.length; i++) {\n    const char = arrayString[i];\n    if (char === \"\\\\\") {\n      i++;\n      continue;\n    }\n    if (char === '\"') {\n      return [arrayString.slice(startFrom, i).replace(/\\\\/g, \"\"), i + 1];\n    }\n    if (inQuotes) {\n      continue;\n    }\n    if (char === \",\" || char === \"}\") {\n      return [arrayString.slice(startFrom, i).replace(/\\\\/g, \"\"), i];\n    }\n  }\n  return [arrayString.slice(startFrom).replace(/\\\\/g, \"\"), arrayString.length];\n}\nfunction parsePgNestedArray(arrayString, startFrom = 0) {\n  const result = [];\n  let i = startFrom;\n  let lastCharIsComma = false;\n  while (i < arrayString.length) {\n    const char = arrayString[i];\n    if (char === \",\") {\n      if (lastCharIsComma || i === startFrom) {\n        result.push(\"\");\n      }\n      lastCharIsComma = true;\n      i++;\n      continue;\n    }\n    lastCharIsComma = false;\n    if (char === \"\\\\\") {\n      i += 2;\n      continue;\n    }\n    if (char === '\"') {\n      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);\n      result.push(value2);\n      i = startFrom2;\n      continue;\n    }\n    if (char === \"}\") {\n      return [result, i + 1];\n    }\n    if (char === \"{\") {\n      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);\n      result.push(value2);\n      i = startFrom2;\n      continue;\n    }\n    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n    result.push(value);\n    i = newStartFrom;\n  }\n  return [result, i];\n}\nfunction parsePgArray(arrayString) {\n  const [result] = parsePgNestedArray(arrayString, 1);\n  return result;\n}\nfunction makePgArray(array) {\n  return `{${array.map((item) => {\n    if (Array.isArray(item)) {\n      return makePgArray(item);\n    }\n    if (typeof item === \"string\") {\n      return `\"${item.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"')}\"`;\n    }\n    return `${item}`;\n  }).join(\",\")}}`;\n}\nexport {\n  makePgArray,\n  parsePgArray,\n  parsePgNestedArray\n};\n//# sourceMappingURL=array.js.map",
    "import { ColumnBuilder } from \"../../column-builder.js\";\nimport { Column } from \"../../column.js\";\nimport { entityKind, is } from \"../../entity.js\";\nimport { ForeignKeyBuilder } from \"../foreign-keys.js\";\nimport { iife } from \"../../tracing-utils.js\";\nimport { uniqueKeyName } from \"../unique-constraint.js\";\nimport { makePgArray, parsePgArray } from \"../utils/array.js\";\nclass PgColumnBuilder extends ColumnBuilder {\n  foreignKeyConfigs = [];\n  static [entityKind] = \"PgColumnBuilder\";\n  array(size) {\n    return new PgArrayBuilder(this.config.name, this, size);\n  }\n  references(ref, actions = {}) {\n    this.foreignKeyConfigs.push({ ref, actions });\n    return this;\n  }\n  unique(name, config) {\n    this.config.isUnique = true;\n    this.config.uniqueName = name;\n    this.config.uniqueType = config?.nulls;\n    return this;\n  }\n  generatedAlwaysAs(as) {\n    this.config.generated = {\n      as,\n      type: \"always\",\n      mode: \"stored\"\n    };\n    return this;\n  }\n  /** @internal */\n  buildForeignKeys(column, table) {\n    return this.foreignKeyConfigs.map(({ ref, actions }) => {\n      return iife(\n        (ref2, actions2) => {\n          const builder = new ForeignKeyBuilder(() => {\n            const foreignColumn = ref2();\n            return { columns: [column], foreignColumns: [foreignColumn] };\n          });\n          if (actions2.onUpdate) {\n            builder.onUpdate(actions2.onUpdate);\n          }\n          if (actions2.onDelete) {\n            builder.onDelete(actions2.onDelete);\n          }\n          return builder.build(table);\n        },\n        ref,\n        actions\n      );\n    });\n  }\n  /** @internal */\n  buildExtraConfigColumn(table) {\n    return new ExtraConfigColumn(table, this.config);\n  }\n}\nclass PgColumn extends Column {\n  constructor(table, config) {\n    if (!config.uniqueName) {\n      config.uniqueName = uniqueKeyName(table, [config.name]);\n    }\n    super(table, config);\n    this.table = table;\n  }\n  static [entityKind] = \"PgColumn\";\n}\nclass ExtraConfigColumn extends PgColumn {\n  static [entityKind] = \"ExtraConfigColumn\";\n  getSQLType() {\n    return this.getSQLType();\n  }\n  indexConfig = {\n    order: this.config.order ?? \"asc\",\n    nulls: this.config.nulls ?? \"last\",\n    opClass: this.config.opClass\n  };\n  defaultConfig = {\n    order: \"asc\",\n    nulls: \"last\",\n    opClass: void 0\n  };\n  asc() {\n    this.indexConfig.order = \"asc\";\n    return this;\n  }\n  desc() {\n    this.indexConfig.order = \"desc\";\n    return this;\n  }\n  nullsFirst() {\n    this.indexConfig.nulls = \"first\";\n    return this;\n  }\n  nullsLast() {\n    this.indexConfig.nulls = \"last\";\n    return this;\n  }\n  /**\n   * ### PostgreSQL documentation quote\n   *\n   * > An operator class with optional parameters can be specified for each column of an index.\n   * The operator class identifies the operators to be used by the index for that column.\n   * For example, a B-tree index on four-byte integers would use the int4_ops class;\n   * this operator class includes comparison functions for four-byte integers.\n   * In practice the default operator class for the column's data type is usually sufficient.\n   * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n   * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n   * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n   * More information about operator classes check:\n   *\n   * ### Useful links\n   * https://www.postgresql.org/docs/current/sql-createindex.html\n   *\n   * https://www.postgresql.org/docs/current/indexes-opclass.html\n   *\n   * https://www.postgresql.org/docs/current/xindex.html\n   *\n   * ### Additional types\n   * If you have the `pg_vector` extension installed in your database, you can use the\n   * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n   *\n   * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n   *\n   * @param opClass\n   * @returns\n   */\n  op(opClass) {\n    this.indexConfig.opClass = opClass;\n    return this;\n  }\n}\nclass IndexedColumn {\n  static [entityKind] = \"IndexedColumn\";\n  constructor(name, keyAsName, type, indexConfig) {\n    this.name = name;\n    this.keyAsName = keyAsName;\n    this.type = type;\n    this.indexConfig = indexConfig;\n  }\n  name;\n  keyAsName;\n  type;\n  indexConfig;\n}\nclass PgArrayBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgArrayBuilder\";\n  constructor(name, baseBuilder, size) {\n    super(name, \"array\", \"PgArray\");\n    this.config.baseBuilder = baseBuilder;\n    this.config.size = size;\n  }\n  /** @internal */\n  build(table) {\n    const baseColumn = this.config.baseBuilder.build(table);\n    return new PgArray(\n      table,\n      this.config,\n      baseColumn\n    );\n  }\n}\nclass PgArray extends PgColumn {\n  constructor(table, config, baseColumn, range) {\n    super(table, config);\n    this.baseColumn = baseColumn;\n    this.range = range;\n    this.size = config.size;\n  }\n  size;\n  static [entityKind] = \"PgArray\";\n  getSQLType() {\n    return `${this.baseColumn.getSQLType()}[${typeof this.size === \"number\" ? this.size : \"\"}]`;\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      value = parsePgArray(value);\n    }\n    return value.map((v) => this.baseColumn.mapFromDriverValue(v));\n  }\n  mapToDriverValue(value, isNestedArray = false) {\n    const a = value.map(\n      (v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v)\n    );\n    if (isNestedArray) return a;\n    return makePgArray(a);\n  }\n}\nexport {\n  ExtraConfigColumn,\n  IndexedColumn,\n  PgArray,\n  PgArrayBuilder,\n  PgColumn,\n  PgColumnBuilder\n};\n//# sourceMappingURL=common.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgEnumObjectColumnBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgEnumObjectColumnBuilder\";\n  constructor(name, enumInstance) {\n    super(name, \"string\", \"PgEnumObjectColumn\");\n    this.config.enum = enumInstance;\n  }\n  /** @internal */\n  build(table) {\n    return new PgEnumObjectColumn(\n      table,\n      this.config\n    );\n  }\n}\nclass PgEnumObjectColumn extends PgColumn {\n  static [entityKind] = \"PgEnumObjectColumn\";\n  enum;\n  enumValues = this.config.enum.enumValues;\n  constructor(table, config) {\n    super(table, config);\n    this.enum = config.enum;\n  }\n  getSQLType() {\n    return this.enum.enumName;\n  }\n}\nconst isPgEnumSym = Symbol.for(\"drizzle:isPgEnum\");\nfunction isPgEnum(obj) {\n  return !!obj && typeof obj === \"function\" && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\nclass PgEnumColumnBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgEnumColumnBuilder\";\n  constructor(name, enumInstance) {\n    super(name, \"string\", \"PgEnumColumn\");\n    this.config.enum = enumInstance;\n  }\n  /** @internal */\n  build(table) {\n    return new PgEnumColumn(\n      table,\n      this.config\n    );\n  }\n}\nclass PgEnumColumn extends PgColumn {\n  static [entityKind] = \"PgEnumColumn\";\n  enum = this.config.enum;\n  enumValues = this.config.enum.enumValues;\n  constructor(table, config) {\n    super(table, config);\n    this.enum = config.enum;\n  }\n  getSQLType() {\n    return this.enum.enumName;\n  }\n}\nfunction pgEnum(enumName, input) {\n  return Array.isArray(input) ? pgEnumWithSchema(enumName, [...input], void 0) : pgEnumObjectWithSchema(enumName, input, void 0);\n}\nfunction pgEnumWithSchema(enumName, values, schema) {\n  const enumInstance = Object.assign(\n    (name) => new PgEnumColumnBuilder(name ?? \"\", enumInstance),\n    {\n      enumName,\n      enumValues: values,\n      schema,\n      [isPgEnumSym]: true\n    }\n  );\n  return enumInstance;\n}\nfunction pgEnumObjectWithSchema(enumName, values, schema) {\n  const enumInstance = Object.assign(\n    (name) => new PgEnumObjectColumnBuilder(name ?? \"\", enumInstance),\n    {\n      enumName,\n      enumValues: Object.values(values),\n      schema,\n      [isPgEnumSym]: true\n    }\n  );\n  return enumInstance;\n}\nexport {\n  PgEnumColumn,\n  PgEnumColumnBuilder,\n  PgEnumObjectColumn,\n  PgEnumObjectColumnBuilder,\n  isPgEnum,\n  pgEnum,\n  pgEnumObjectWithSchema,\n  pgEnumWithSchema\n};\n//# sourceMappingURL=enum.js.map",
    "import { entityKind } from \"./entity.js\";\nclass Subquery {\n  static [entityKind] = \"Subquery\";\n  constructor(sql, fields, alias, isWith = false, usedTables = []) {\n    this._ = {\n      brand: \"Subquery\",\n      sql,\n      selectedFields: fields,\n      alias,\n      isWith,\n      usedTables\n    };\n  }\n  // getSQL(): SQL<unknown> {\n  // \treturn new SQL([this]);\n  // }\n}\nclass WithSubquery extends Subquery {\n  static [entityKind] = \"WithSubquery\";\n}\nexport {\n  Subquery,\n  WithSubquery\n};\n//# sourceMappingURL=subquery.js.map",
    "// package.json\nvar version = \"0.44.5\";\n\n// src/version.ts\nvar compatibilityVersion = 10;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n",
    "import { iife } from \"./tracing-utils.js\";\nimport { npmVersion } from \"./version.js\";\nlet otel;\nlet rawTracer;\nconst tracer = {\n  startActiveSpan(name, fn) {\n    if (!otel) {\n      return fn();\n    }\n    if (!rawTracer) {\n      rawTracer = otel.trace.getTracer(\"drizzle-orm\", npmVersion);\n    }\n    return iife(\n      (otel2, rawTracer2) => rawTracer2.startActiveSpan(\n        name,\n        (span) => {\n          try {\n            return fn(span);\n          } catch (e) {\n            span.setStatus({\n              code: otel2.SpanStatusCode.ERROR,\n              message: e instanceof Error ? e.message : \"Unknown error\"\n              // eslint-disable-line no-instanceof/no-instanceof\n            });\n            throw e;\n          } finally {\n            span.end();\n          }\n        }\n      ),\n      otel,\n      rawTracer\n    );\n  }\n};\nexport {\n  tracer\n};\n//# sourceMappingURL=tracing.js.map",
    "const ViewBaseConfig = Symbol.for(\"drizzle:ViewBaseConfig\");\nexport {\n  ViewBaseConfig\n};\n//# sourceMappingURL=view-common.js.map",
    "import { entityKind } from \"./entity.js\";\nimport { TableName } from \"./table.utils.js\";\nconst Schema = Symbol.for(\"drizzle:Schema\");\nconst Columns = Symbol.for(\"drizzle:Columns\");\nconst ExtraConfigColumns = Symbol.for(\"drizzle:ExtraConfigColumns\");\nconst OriginalName = Symbol.for(\"drizzle:OriginalName\");\nconst BaseName = Symbol.for(\"drizzle:BaseName\");\nconst IsAlias = Symbol.for(\"drizzle:IsAlias\");\nconst ExtraConfigBuilder = Symbol.for(\"drizzle:ExtraConfigBuilder\");\nconst IsDrizzleTable = Symbol.for(\"drizzle:IsDrizzleTable\");\nclass Table {\n  static [entityKind] = \"Table\";\n  /** @internal */\n  static Symbol = {\n    Name: TableName,\n    Schema,\n    OriginalName,\n    Columns,\n    ExtraConfigColumns,\n    BaseName,\n    IsAlias,\n    ExtraConfigBuilder\n  };\n  /**\n   * @internal\n   * Can be changed if the table is aliased.\n   */\n  [TableName];\n  /**\n   * @internal\n   * Used to store the original name of the table, before any aliasing.\n   */\n  [OriginalName];\n  /** @internal */\n  [Schema];\n  /** @internal */\n  [Columns];\n  /** @internal */\n  [ExtraConfigColumns];\n  /**\n   *  @internal\n   * Used to store the table name before the transformation via the `tableCreator` functions.\n   */\n  [BaseName];\n  /** @internal */\n  [IsAlias] = false;\n  /** @internal */\n  [IsDrizzleTable] = true;\n  /** @internal */\n  [ExtraConfigBuilder] = void 0;\n  constructor(name, schema, baseName) {\n    this[TableName] = this[OriginalName] = name;\n    this[Schema] = schema;\n    this[BaseName] = baseName;\n  }\n}\nfunction isTable(table) {\n  return typeof table === \"object\" && table !== null && IsDrizzleTable in table;\n}\nfunction getTableName(table) {\n  return table[TableName];\n}\nfunction getTableUniqueName(table) {\n  return `${table[Schema] ?? \"public\"}.${table[TableName]}`;\n}\nexport {\n  BaseName,\n  Columns,\n  ExtraConfigBuilder,\n  ExtraConfigColumns,\n  IsAlias,\n  OriginalName,\n  Schema,\n  Table,\n  getTableName,\n  getTableUniqueName,\n  isTable\n};\n//# sourceMappingURL=table.js.map",
    "import { entityKind, is } from \"../entity.js\";\nimport { isPgEnum } from \"../pg-core/columns/enum.js\";\nimport { Subquery } from \"../subquery.js\";\nimport { tracer } from \"../tracing.js\";\nimport { ViewBaseConfig } from \"../view-common.js\";\nimport { Column } from \"../column.js\";\nimport { IsAlias, Table } from \"../table.js\";\nclass FakePrimitiveParam {\n  static [entityKind] = \"FakePrimitiveParam\";\n}\nfunction isSQLWrapper(value) {\n  return value !== null && value !== void 0 && typeof value.getSQL === \"function\";\n}\nfunction mergeQueries(queries) {\n  const result = { sql: \"\", params: [] };\n  for (const query of queries) {\n    result.sql += query.sql;\n    result.params.push(...query.params);\n    if (query.typings?.length) {\n      if (!result.typings) {\n        result.typings = [];\n      }\n      result.typings.push(...query.typings);\n    }\n  }\n  return result;\n}\nclass StringChunk {\n  static [entityKind] = \"StringChunk\";\n  value;\n  constructor(value) {\n    this.value = Array.isArray(value) ? value : [value];\n  }\n  getSQL() {\n    return new SQL([this]);\n  }\n}\nclass SQL {\n  constructor(queryChunks) {\n    this.queryChunks = queryChunks;\n    for (const chunk of queryChunks) {\n      if (is(chunk, Table)) {\n        const schemaName = chunk[Table.Symbol.Schema];\n        this.usedTables.push(\n          schemaName === void 0 ? chunk[Table.Symbol.Name] : schemaName + \".\" + chunk[Table.Symbol.Name]\n        );\n      }\n    }\n  }\n  static [entityKind] = \"SQL\";\n  /** @internal */\n  decoder = noopDecoder;\n  shouldInlineParams = false;\n  /** @internal */\n  usedTables = [];\n  append(query) {\n    this.queryChunks.push(...query.queryChunks);\n    return this;\n  }\n  toQuery(config) {\n    return tracer.startActiveSpan(\"drizzle.buildSQL\", (span) => {\n      const query = this.buildQueryFromSourceParams(this.queryChunks, config);\n      span?.setAttributes({\n        \"drizzle.query.text\": query.sql,\n        \"drizzle.query.params\": JSON.stringify(query.params)\n      });\n      return query;\n    });\n  }\n  buildQueryFromSourceParams(chunks, _config) {\n    const config = Object.assign({}, _config, {\n      inlineParams: _config.inlineParams || this.shouldInlineParams,\n      paramStartIndex: _config.paramStartIndex || { value: 0 }\n    });\n    const {\n      casing,\n      escapeName,\n      escapeParam,\n      prepareTyping,\n      inlineParams,\n      paramStartIndex\n    } = config;\n    return mergeQueries(chunks.map((chunk) => {\n      if (is(chunk, StringChunk)) {\n        return { sql: chunk.value.join(\"\"), params: [] };\n      }\n      if (is(chunk, Name)) {\n        return { sql: escapeName(chunk.value), params: [] };\n      }\n      if (chunk === void 0) {\n        return { sql: \"\", params: [] };\n      }\n      if (Array.isArray(chunk)) {\n        const result = [new StringChunk(\"(\")];\n        for (const [i, p] of chunk.entries()) {\n          result.push(p);\n          if (i < chunk.length - 1) {\n            result.push(new StringChunk(\", \"));\n          }\n        }\n        result.push(new StringChunk(\")\"));\n        return this.buildQueryFromSourceParams(result, config);\n      }\n      if (is(chunk, SQL)) {\n        return this.buildQueryFromSourceParams(chunk.queryChunks, {\n          ...config,\n          inlineParams: inlineParams || chunk.shouldInlineParams\n        });\n      }\n      if (is(chunk, Table)) {\n        const schemaName = chunk[Table.Symbol.Schema];\n        const tableName = chunk[Table.Symbol.Name];\n        return {\n          sql: schemaName === void 0 || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + \".\" + escapeName(tableName),\n          params: []\n        };\n      }\n      if (is(chunk, Column)) {\n        const columnName = casing.getColumnCasing(chunk);\n        if (_config.invokeSource === \"indexes\") {\n          return { sql: escapeName(columnName), params: [] };\n        }\n        const schemaName = chunk.table[Table.Symbol.Schema];\n        return {\n          sql: chunk.table[IsAlias] || schemaName === void 0 ? escapeName(chunk.table[Table.Symbol.Name]) + \".\" + escapeName(columnName) : escapeName(schemaName) + \".\" + escapeName(chunk.table[Table.Symbol.Name]) + \".\" + escapeName(columnName),\n          params: []\n        };\n      }\n      if (is(chunk, View)) {\n        const schemaName = chunk[ViewBaseConfig].schema;\n        const viewName = chunk[ViewBaseConfig].name;\n        return {\n          sql: schemaName === void 0 || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + \".\" + escapeName(viewName),\n          params: []\n        };\n      }\n      if (is(chunk, Param)) {\n        if (is(chunk.value, Placeholder)) {\n          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: [\"none\"] };\n        }\n        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);\n        if (is(mappedValue, SQL)) {\n          return this.buildQueryFromSourceParams([mappedValue], config);\n        }\n        if (inlineParams) {\n          return { sql: this.mapInlineParam(mappedValue, config), params: [] };\n        }\n        let typings = [\"none\"];\n        if (prepareTyping) {\n          typings = [prepareTyping(chunk.encoder)];\n        }\n        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n      }\n      if (is(chunk, Placeholder)) {\n        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: [\"none\"] };\n      }\n      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== void 0) {\n        return { sql: escapeName(chunk.fieldAlias), params: [] };\n      }\n      if (is(chunk, Subquery)) {\n        if (chunk._.isWith) {\n          return { sql: escapeName(chunk._.alias), params: [] };\n        }\n        return this.buildQueryFromSourceParams([\n          new StringChunk(\"(\"),\n          chunk._.sql,\n          new StringChunk(\") \"),\n          new Name(chunk._.alias)\n        ], config);\n      }\n      if (isPgEnum(chunk)) {\n        if (chunk.schema) {\n          return { sql: escapeName(chunk.schema) + \".\" + escapeName(chunk.enumName), params: [] };\n        }\n        return { sql: escapeName(chunk.enumName), params: [] };\n      }\n      if (isSQLWrapper(chunk)) {\n        if (chunk.shouldOmitSQLParens?.()) {\n          return this.buildQueryFromSourceParams([chunk.getSQL()], config);\n        }\n        return this.buildQueryFromSourceParams([\n          new StringChunk(\"(\"),\n          chunk.getSQL(),\n          new StringChunk(\")\")\n        ], config);\n      }\n      if (inlineParams) {\n        return { sql: this.mapInlineParam(chunk, config), params: [] };\n      }\n      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: [\"none\"] };\n    }));\n  }\n  mapInlineParam(chunk, { escapeString }) {\n    if (chunk === null) {\n      return \"null\";\n    }\n    if (typeof chunk === \"number\" || typeof chunk === \"boolean\") {\n      return chunk.toString();\n    }\n    if (typeof chunk === \"string\") {\n      return escapeString(chunk);\n    }\n    if (typeof chunk === \"object\") {\n      const mappedValueAsString = chunk.toString();\n      if (mappedValueAsString === \"[object Object]\") {\n        return escapeString(JSON.stringify(chunk));\n      }\n      return escapeString(mappedValueAsString);\n    }\n    throw new Error(\"Unexpected param value: \" + chunk);\n  }\n  getSQL() {\n    return this;\n  }\n  as(alias) {\n    if (alias === void 0) {\n      return this;\n    }\n    return new SQL.Aliased(this, alias);\n  }\n  mapWith(decoder) {\n    this.decoder = typeof decoder === \"function\" ? { mapFromDriverValue: decoder } : decoder;\n    return this;\n  }\n  inlineParams() {\n    this.shouldInlineParams = true;\n    return this;\n  }\n  /**\n   * This method is used to conditionally include a part of the query.\n   *\n   * @param condition - Condition to check\n   * @returns itself if the condition is `true`, otherwise `undefined`\n   */\n  if(condition) {\n    return condition ? this : void 0;\n  }\n}\nclass Name {\n  constructor(value) {\n    this.value = value;\n  }\n  static [entityKind] = \"Name\";\n  brand;\n  getSQL() {\n    return new SQL([this]);\n  }\n}\nfunction name(value) {\n  return new Name(value);\n}\nfunction isDriverValueEncoder(value) {\n  return typeof value === \"object\" && value !== null && \"mapToDriverValue\" in value && typeof value.mapToDriverValue === \"function\";\n}\nconst noopDecoder = {\n  mapFromDriverValue: (value) => value\n};\nconst noopEncoder = {\n  mapToDriverValue: (value) => value\n};\nconst noopMapper = {\n  ...noopDecoder,\n  ...noopEncoder\n};\nclass Param {\n  /**\n   * @param value - Parameter value\n   * @param encoder - Encoder to convert the value to a driver parameter\n   */\n  constructor(value, encoder = noopEncoder) {\n    this.value = value;\n    this.encoder = encoder;\n  }\n  static [entityKind] = \"Param\";\n  brand;\n  getSQL() {\n    return new SQL([this]);\n  }\n}\nfunction param(value, encoder) {\n  return new Param(value, encoder);\n}\nfunction sql(strings, ...params) {\n  const queryChunks = [];\n  if (params.length > 0 || strings.length > 0 && strings[0] !== \"\") {\n    queryChunks.push(new StringChunk(strings[0]));\n  }\n  for (const [paramIndex, param2] of params.entries()) {\n    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));\n  }\n  return new SQL(queryChunks);\n}\n((sql2) => {\n  function empty() {\n    return new SQL([]);\n  }\n  sql2.empty = empty;\n  function fromList(list) {\n    return new SQL(list);\n  }\n  sql2.fromList = fromList;\n  function raw(str) {\n    return new SQL([new StringChunk(str)]);\n  }\n  sql2.raw = raw;\n  function join(chunks, separator) {\n    const result = [];\n    for (const [i, chunk] of chunks.entries()) {\n      if (i > 0 && separator !== void 0) {\n        result.push(separator);\n      }\n      result.push(chunk);\n    }\n    return new SQL(result);\n  }\n  sql2.join = join;\n  function identifier(value) {\n    return new Name(value);\n  }\n  sql2.identifier = identifier;\n  function placeholder2(name2) {\n    return new Placeholder(name2);\n  }\n  sql2.placeholder = placeholder2;\n  function param2(value, encoder) {\n    return new Param(value, encoder);\n  }\n  sql2.param = param2;\n})(sql || (sql = {}));\n((SQL2) => {\n  class Aliased {\n    constructor(sql2, fieldAlias) {\n      this.sql = sql2;\n      this.fieldAlias = fieldAlias;\n    }\n    static [entityKind] = \"SQL.Aliased\";\n    /** @internal */\n    isSelectionField = false;\n    getSQL() {\n      return this.sql;\n    }\n    /** @internal */\n    clone() {\n      return new Aliased(this.sql, this.fieldAlias);\n    }\n  }\n  SQL2.Aliased = Aliased;\n})(SQL || (SQL = {}));\nclass Placeholder {\n  constructor(name2) {\n    this.name = name2;\n  }\n  static [entityKind] = \"Placeholder\";\n  getSQL() {\n    return new SQL([this]);\n  }\n}\nfunction placeholder(name2) {\n  return new Placeholder(name2);\n}\nfunction fillPlaceholders(params, values) {\n  return params.map((p) => {\n    if (is(p, Placeholder)) {\n      if (!(p.name in values)) {\n        throw new Error(`No value for placeholder \"${p.name}\" was provided`);\n      }\n      return values[p.name];\n    }\n    if (is(p, Param) && is(p.value, Placeholder)) {\n      if (!(p.value.name in values)) {\n        throw new Error(`No value for placeholder \"${p.value.name}\" was provided`);\n      }\n      return p.encoder.mapToDriverValue(values[p.value.name]);\n    }\n    return p;\n  });\n}\nconst IsDrizzleView = Symbol.for(\"drizzle:IsDrizzleView\");\nclass View {\n  static [entityKind] = \"View\";\n  /** @internal */\n  [ViewBaseConfig];\n  /** @internal */\n  [IsDrizzleView] = true;\n  constructor({ name: name2, schema, selectedFields, query }) {\n    this[ViewBaseConfig] = {\n      name: name2,\n      originalName: name2,\n      schema,\n      selectedFields,\n      query,\n      isExisting: !query,\n      isAlias: false\n    };\n  }\n  getSQL() {\n    return new SQL([this]);\n  }\n}\nfunction isView(view) {\n  return typeof view === \"object\" && view !== null && IsDrizzleView in view;\n}\nfunction getViewName(view) {\n  return view[ViewBaseConfig].name;\n}\nColumn.prototype.getSQL = function() {\n  return new SQL([this]);\n};\nTable.prototype.getSQL = function() {\n  return new SQL([this]);\n};\nSubquery.prototype.getSQL = function() {\n  return new SQL([this]);\n};\nexport {\n  FakePrimitiveParam,\n  Name,\n  Param,\n  Placeholder,\n  SQL,\n  StringChunk,\n  View,\n  fillPlaceholders,\n  getViewName,\n  isDriverValueEncoder,\n  isSQLWrapper,\n  isView,\n  name,\n  noopDecoder,\n  noopEncoder,\n  noopMapper,\n  param,\n  placeholder,\n  sql\n};\n//# sourceMappingURL=sql.js.map",
    "import { Column } from \"./column.js\";\nimport { entityKind, is } from \"./entity.js\";\nimport { SQL, sql } from \"./sql/sql.js\";\nimport { Table } from \"./table.js\";\nimport { ViewBaseConfig } from \"./view-common.js\";\nclass ColumnAliasProxyHandler {\n  constructor(table) {\n    this.table = table;\n  }\n  static [entityKind] = \"ColumnAliasProxyHandler\";\n  get(columnObj, prop) {\n    if (prop === \"table\") {\n      return this.table;\n    }\n    return columnObj[prop];\n  }\n}\nclass TableAliasProxyHandler {\n  constructor(alias, replaceOriginalName) {\n    this.alias = alias;\n    this.replaceOriginalName = replaceOriginalName;\n  }\n  static [entityKind] = \"TableAliasProxyHandler\";\n  get(target, prop) {\n    if (prop === Table.Symbol.IsAlias) {\n      return true;\n    }\n    if (prop === Table.Symbol.Name) {\n      return this.alias;\n    }\n    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {\n      return this.alias;\n    }\n    if (prop === ViewBaseConfig) {\n      return {\n        ...target[ViewBaseConfig],\n        name: this.alias,\n        isAlias: true\n      };\n    }\n    if (prop === Table.Symbol.Columns) {\n      const columns = target[Table.Symbol.Columns];\n      if (!columns) {\n        return columns;\n      }\n      const proxiedColumns = {};\n      Object.keys(columns).map((key) => {\n        proxiedColumns[key] = new Proxy(\n          columns[key],\n          new ColumnAliasProxyHandler(new Proxy(target, this))\n        );\n      });\n      return proxiedColumns;\n    }\n    const value = target[prop];\n    if (is(value, Column)) {\n      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));\n    }\n    return value;\n  }\n}\nclass RelationTableAliasProxyHandler {\n  constructor(alias) {\n    this.alias = alias;\n  }\n  static [entityKind] = \"RelationTableAliasProxyHandler\";\n  get(target, prop) {\n    if (prop === \"sourceTable\") {\n      return aliasedTable(target.sourceTable, this.alias);\n    }\n    return target[prop];\n  }\n}\nfunction aliasedTable(table, tableAlias) {\n  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));\n}\nfunction aliasedRelation(relation, tableAlias) {\n  return new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));\n}\nfunction aliasedTableColumn(column, tableAlias) {\n  return new Proxy(\n    column,\n    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))\n  );\n}\nfunction mapColumnsInAliasedSQLToAlias(query, alias) {\n  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);\n}\nfunction mapColumnsInSQLToAlias(query, alias) {\n  return sql.join(query.queryChunks.map((c) => {\n    if (is(c, Column)) {\n      return aliasedTableColumn(c, alias);\n    }\n    if (is(c, SQL)) {\n      return mapColumnsInSQLToAlias(c, alias);\n    }\n    if (is(c, SQL.Aliased)) {\n      return mapColumnsInAliasedSQLToAlias(c, alias);\n    }\n    return c;\n  }));\n}\nexport {\n  ColumnAliasProxyHandler,\n  RelationTableAliasProxyHandler,\n  TableAliasProxyHandler,\n  aliasedRelation,\n  aliasedTable,\n  aliasedTableColumn,\n  mapColumnsInAliasedSQLToAlias,\n  mapColumnsInSQLToAlias\n};\n//# sourceMappingURL=alias.js.map",
    "import { ColumnAliasProxyHandler, TableAliasProxyHandler } from \"./alias.js\";\nimport { Column } from \"./column.js\";\nimport { entityKind, is } from \"./entity.js\";\nimport { SQL, View } from \"./sql/sql.js\";\nimport { Subquery } from \"./subquery.js\";\nimport { ViewBaseConfig } from \"./view-common.js\";\nclass SelectionProxyHandler {\n  static [entityKind] = \"SelectionProxyHandler\";\n  config;\n  constructor(config) {\n    this.config = { ...config };\n  }\n  get(subquery, prop) {\n    if (prop === \"_\") {\n      return {\n        ...subquery[\"_\"],\n        selectedFields: new Proxy(\n          subquery._.selectedFields,\n          this\n        )\n      };\n    }\n    if (prop === ViewBaseConfig) {\n      return {\n        ...subquery[ViewBaseConfig],\n        selectedFields: new Proxy(\n          subquery[ViewBaseConfig].selectedFields,\n          this\n        )\n      };\n    }\n    if (typeof prop === \"symbol\") {\n      return subquery[prop];\n    }\n    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;\n    const value = columns[prop];\n    if (is(value, SQL.Aliased)) {\n      if (this.config.sqlAliasedBehavior === \"sql\" && !value.isSelectionField) {\n        return value.sql;\n      }\n      const newValue = value.clone();\n      newValue.isSelectionField = true;\n      return newValue;\n    }\n    if (is(value, SQL)) {\n      if (this.config.sqlBehavior === \"sql\") {\n        return value;\n      }\n      throw new Error(\n        `You tried to reference \"${prop}\" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using \".as('alias')\" method.`\n      );\n    }\n    if (is(value, Column)) {\n      if (this.config.alias) {\n        return new Proxy(\n          value,\n          new ColumnAliasProxyHandler(\n            new Proxy(\n              value.table,\n              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)\n            )\n          )\n        );\n      }\n      return value;\n    }\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n    return new Proxy(value, new SelectionProxyHandler(this.config));\n  }\n}\nexport {\n  SelectionProxyHandler\n};\n//# sourceMappingURL=selection-proxy.js.map",
    "import { Column } from \"./column.js\";\nimport { is } from \"./entity.js\";\nimport { Param, SQL, View } from \"./sql/sql.js\";\nimport { Subquery } from \"./subquery.js\";\nimport { getTableName, Table } from \"./table.js\";\nimport { ViewBaseConfig } from \"./view-common.js\";\nfunction mapResultRow(columns, row, joinsNotNullableMap) {\n  const nullifyMap = {};\n  const result = columns.reduce(\n    (result2, { path, field }, columnIndex) => {\n      let decoder;\n      if (is(field, Column)) {\n        decoder = field;\n      } else if (is(field, SQL)) {\n        decoder = field.decoder;\n      } else {\n        decoder = field.sql.decoder;\n      }\n      let node = result2;\n      for (const [pathChunkIndex, pathChunk] of path.entries()) {\n        if (pathChunkIndex < path.length - 1) {\n          if (!(pathChunk in node)) {\n            node[pathChunk] = {};\n          }\n          node = node[pathChunk];\n        } else {\n          const rawValue = row[columnIndex];\n          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n            const objectName = path[0];\n            if (!(objectName in nullifyMap)) {\n              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n            } else if (typeof nullifyMap[objectName] === \"string\" && nullifyMap[objectName] !== getTableName(field.table)) {\n              nullifyMap[objectName] = false;\n            }\n          }\n        }\n      }\n      return result2;\n    },\n    {}\n  );\n  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n    for (const [objectName, tableName] of Object.entries(nullifyMap)) {\n      if (typeof tableName === \"string\" && !joinsNotNullableMap[tableName]) {\n        result[objectName] = null;\n      }\n    }\n  }\n  return result;\n}\nfunction orderSelectedFields(fields, pathPrefix) {\n  return Object.entries(fields).reduce((result, [name, field]) => {\n    if (typeof name !== \"string\") {\n      return result;\n    }\n    const newPath = pathPrefix ? [...pathPrefix, name] : [name];\n    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n      result.push({ path: newPath, field });\n    } else if (is(field, Table)) {\n      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n    } else {\n      result.push(...orderSelectedFields(field, newPath));\n    }\n    return result;\n  }, []);\n}\nfunction haveSameKeys(left, right) {\n  const leftKeys = Object.keys(left);\n  const rightKeys = Object.keys(right);\n  if (leftKeys.length !== rightKeys.length) {\n    return false;\n  }\n  for (const [index, key] of leftKeys.entries()) {\n    if (key !== rightKeys[index]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mapUpdateSet(table, values) {\n  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {\n    if (is(value, SQL) || is(value, Column)) {\n      return [key, value];\n    } else {\n      return [key, new Param(value, table[Table.Symbol.Columns][key])];\n    }\n  });\n  if (entries.length === 0) {\n    throw new Error(\"No values to set\");\n  }\n  return Object.fromEntries(entries);\n}\nfunction applyMixins(baseClass, extendedClasses) {\n  for (const extendedClass of extendedClasses) {\n    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n      if (name === \"constructor\") continue;\n      Object.defineProperty(\n        baseClass.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)\n      );\n    }\n  }\n}\nfunction getTableColumns(table) {\n  return table[Table.Symbol.Columns];\n}\nfunction getViewSelectedFields(view) {\n  return view[ViewBaseConfig].selectedFields;\n}\nfunction getTableLikeName(table) {\n  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];\n}\nfunction getColumnNameAndConfig(a, b) {\n  return {\n    name: typeof a === \"string\" && a.length > 0 ? a : \"\",\n    config: typeof a === \"object\" ? a : b\n  };\n}\nconst _ = {};\nconst __ = {};\nfunction isConfig(data) {\n  if (typeof data !== \"object\" || data === null) return false;\n  if (data.constructor.name !== \"Object\") return false;\n  if (\"logger\" in data) {\n    const type = typeof data[\"logger\"];\n    if (type !== \"boolean\" && (type !== \"object\" || typeof data[\"logger\"][\"logQuery\"] !== \"function\") && type !== \"undefined\") return false;\n    return true;\n  }\n  if (\"schema\" in data) {\n    const type = typeof data[\"schema\"];\n    if (type !== \"object\" && type !== \"undefined\") return false;\n    return true;\n  }\n  if (\"casing\" in data) {\n    const type = typeof data[\"casing\"];\n    if (type !== \"string\" && type !== \"undefined\") return false;\n    return true;\n  }\n  if (\"mode\" in data) {\n    if (data[\"mode\"] !== \"default\" || data[\"mode\"] !== \"planetscale\" || data[\"mode\"] !== void 0) return false;\n    return true;\n  }\n  if (\"connection\" in data) {\n    const type = typeof data[\"connection\"];\n    if (type !== \"string\" && type !== \"object\" && type !== \"undefined\") return false;\n    return true;\n  }\n  if (\"client\" in data) {\n    const type = typeof data[\"client\"];\n    if (type !== \"object\" && type !== \"function\" && type !== \"undefined\") return false;\n    return true;\n  }\n  if (Object.keys(data).length === 0) return true;\n  return false;\n}\nconst textDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder();\nexport {\n  applyMixins,\n  getColumnNameAndConfig,\n  getTableColumns,\n  getTableLikeName,\n  getViewSelectedFields,\n  haveSameKeys,\n  isConfig,\n  mapResultRow,\n  mapUpdateSet,\n  orderSelectedFields,\n  textDecoder\n};\n//# sourceMappingURL=utils.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumnBuilder } from \"./common.js\";\nclass PgIntColumnBaseBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgIntColumnBaseBuilder\";\n  generatedAlwaysAsIdentity(sequence) {\n    if (sequence) {\n      const { name, ...options } = sequence;\n      this.config.generatedIdentity = {\n        type: \"always\",\n        sequenceName: name,\n        sequenceOptions: options\n      };\n    } else {\n      this.config.generatedIdentity = {\n        type: \"always\"\n      };\n    }\n    this.config.hasDefault = true;\n    this.config.notNull = true;\n    return this;\n  }\n  generatedByDefaultAsIdentity(sequence) {\n    if (sequence) {\n      const { name, ...options } = sequence;\n      this.config.generatedIdentity = {\n        type: \"byDefault\",\n        sequenceName: name,\n        sequenceOptions: options\n      };\n    } else {\n      this.config.generatedIdentity = {\n        type: \"byDefault\"\n      };\n    }\n    this.config.hasDefault = true;\n    this.config.notNull = true;\n    return this;\n  }\n}\nexport {\n  PgIntColumnBaseBuilder\n};\n//# sourceMappingURL=int.common.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgIntColumnBaseBuilder } from \"./int.common.js\";\nclass PgBigInt53Builder extends PgIntColumnBaseBuilder {\n  static [entityKind] = \"PgBigInt53Builder\";\n  constructor(name) {\n    super(name, \"number\", \"PgBigInt53\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgBigInt53(table, this.config);\n  }\n}\nclass PgBigInt53 extends PgColumn {\n  static [entityKind] = \"PgBigInt53\";\n  getSQLType() {\n    return \"bigint\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"number\") {\n      return value;\n    }\n    return Number(value);\n  }\n}\nclass PgBigInt64Builder extends PgIntColumnBaseBuilder {\n  static [entityKind] = \"PgBigInt64Builder\";\n  constructor(name) {\n    super(name, \"bigint\", \"PgBigInt64\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgBigInt64(\n      table,\n      this.config\n    );\n  }\n}\nclass PgBigInt64 extends PgColumn {\n  static [entityKind] = \"PgBigInt64\";\n  getSQLType() {\n    return \"bigint\";\n  }\n  // eslint-disable-next-line unicorn/prefer-native-coercion-functions\n  mapFromDriverValue(value) {\n    return BigInt(value);\n  }\n}\nfunction bigint(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (config.mode === \"number\") {\n    return new PgBigInt53Builder(name);\n  }\n  return new PgBigInt64Builder(name);\n}\nexport {\n  PgBigInt53,\n  PgBigInt53Builder,\n  PgBigInt64,\n  PgBigInt64Builder,\n  bigint\n};\n//# sourceMappingURL=bigint.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgBigSerial53Builder extends PgColumnBuilder {\n  static [entityKind] = \"PgBigSerial53Builder\";\n  constructor(name) {\n    super(name, \"number\", \"PgBigSerial53\");\n    this.config.hasDefault = true;\n    this.config.notNull = true;\n  }\n  /** @internal */\n  build(table) {\n    return new PgBigSerial53(\n      table,\n      this.config\n    );\n  }\n}\nclass PgBigSerial53 extends PgColumn {\n  static [entityKind] = \"PgBigSerial53\";\n  getSQLType() {\n    return \"bigserial\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"number\") {\n      return value;\n    }\n    return Number(value);\n  }\n}\nclass PgBigSerial64Builder extends PgColumnBuilder {\n  static [entityKind] = \"PgBigSerial64Builder\";\n  constructor(name) {\n    super(name, \"bigint\", \"PgBigSerial64\");\n    this.config.hasDefault = true;\n  }\n  /** @internal */\n  build(table) {\n    return new PgBigSerial64(\n      table,\n      this.config\n    );\n  }\n}\nclass PgBigSerial64 extends PgColumn {\n  static [entityKind] = \"PgBigSerial64\";\n  getSQLType() {\n    return \"bigserial\";\n  }\n  // eslint-disable-next-line unicorn/prefer-native-coercion-functions\n  mapFromDriverValue(value) {\n    return BigInt(value);\n  }\n}\nfunction bigserial(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (config.mode === \"number\") {\n    return new PgBigSerial53Builder(name);\n  }\n  return new PgBigSerial64Builder(name);\n}\nexport {\n  PgBigSerial53,\n  PgBigSerial53Builder,\n  PgBigSerial64,\n  PgBigSerial64Builder,\n  bigserial\n};\n//# sourceMappingURL=bigserial.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgBooleanBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgBooleanBuilder\";\n  constructor(name) {\n    super(name, \"boolean\", \"PgBoolean\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgBoolean(table, this.config);\n  }\n}\nclass PgBoolean extends PgColumn {\n  static [entityKind] = \"PgBoolean\";\n  getSQLType() {\n    return \"boolean\";\n  }\n}\nfunction boolean(name) {\n  return new PgBooleanBuilder(name ?? \"\");\n}\nexport {\n  PgBoolean,\n  PgBooleanBuilder,\n  boolean\n};\n//# sourceMappingURL=boolean.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgCharBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgCharBuilder\";\n  constructor(name, config) {\n    super(name, \"string\", \"PgChar\");\n    this.config.length = config.length;\n    this.config.enumValues = config.enum;\n  }\n  /** @internal */\n  build(table) {\n    return new PgChar(\n      table,\n      this.config\n    );\n  }\n}\nclass PgChar extends PgColumn {\n  static [entityKind] = \"PgChar\";\n  length = this.config.length;\n  enumValues = this.config.enumValues;\n  getSQLType() {\n    return this.length === void 0 ? `char` : `char(${this.length})`;\n  }\n}\nfunction char(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgCharBuilder(name, config);\n}\nexport {\n  PgChar,\n  PgCharBuilder,\n  char\n};\n//# sourceMappingURL=char.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgCidrBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgCidrBuilder\";\n  constructor(name) {\n    super(name, \"string\", \"PgCidr\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgCidr(table, this.config);\n  }\n}\nclass PgCidr extends PgColumn {\n  static [entityKind] = \"PgCidr\";\n  getSQLType() {\n    return \"cidr\";\n  }\n}\nfunction cidr(name) {\n  return new PgCidrBuilder(name ?? \"\");\n}\nexport {\n  PgCidr,\n  PgCidrBuilder,\n  cidr\n};\n//# sourceMappingURL=cidr.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgCustomColumnBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgCustomColumnBuilder\";\n  constructor(name, fieldConfig, customTypeParams) {\n    super(name, \"custom\", \"PgCustomColumn\");\n    this.config.fieldConfig = fieldConfig;\n    this.config.customTypeParams = customTypeParams;\n  }\n  /** @internal */\n  build(table) {\n    return new PgCustomColumn(\n      table,\n      this.config\n    );\n  }\n}\nclass PgCustomColumn extends PgColumn {\n  static [entityKind] = \"PgCustomColumn\";\n  sqlName;\n  mapTo;\n  mapFrom;\n  constructor(table, config) {\n    super(table, config);\n    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);\n    this.mapTo = config.customTypeParams.toDriver;\n    this.mapFrom = config.customTypeParams.fromDriver;\n  }\n  getSQLType() {\n    return this.sqlName;\n  }\n  mapFromDriverValue(value) {\n    return typeof this.mapFrom === \"function\" ? this.mapFrom(value) : value;\n  }\n  mapToDriverValue(value) {\n    return typeof this.mapTo === \"function\" ? this.mapTo(value) : value;\n  }\n}\nfunction customType(customTypeParams) {\n  return (a, b) => {\n    const { name, config } = getColumnNameAndConfig(a, b);\n    return new PgCustomColumnBuilder(name, config, customTypeParams);\n  };\n}\nexport {\n  PgCustomColumn,\n  PgCustomColumnBuilder,\n  customType\n};\n//# sourceMappingURL=custom.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { sql } from \"../../sql/sql.js\";\nimport { PgColumnBuilder } from \"./common.js\";\nclass PgDateColumnBaseBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgDateColumnBaseBuilder\";\n  defaultNow() {\n    return this.default(sql`now()`);\n  }\n}\nexport {\n  PgDateColumnBaseBuilder\n};\n//# sourceMappingURL=date.common.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgDateColumnBaseBuilder } from \"./date.common.js\";\nclass PgDateBuilder extends PgDateColumnBaseBuilder {\n  static [entityKind] = \"PgDateBuilder\";\n  constructor(name) {\n    super(name, \"date\", \"PgDate\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgDate(table, this.config);\n  }\n}\nclass PgDate extends PgColumn {\n  static [entityKind] = \"PgDate\";\n  getSQLType() {\n    return \"date\";\n  }\n  mapFromDriverValue(value) {\n    return new Date(value);\n  }\n  mapToDriverValue(value) {\n    return value.toISOString();\n  }\n}\nclass PgDateStringBuilder extends PgDateColumnBaseBuilder {\n  static [entityKind] = \"PgDateStringBuilder\";\n  constructor(name) {\n    super(name, \"string\", \"PgDateString\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgDateString(\n      table,\n      this.config\n    );\n  }\n}\nclass PgDateString extends PgColumn {\n  static [entityKind] = \"PgDateString\";\n  getSQLType() {\n    return \"date\";\n  }\n}\nfunction date(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (config?.mode === \"date\") {\n    return new PgDateBuilder(name);\n  }\n  return new PgDateStringBuilder(name);\n}\nexport {\n  PgDate,\n  PgDateBuilder,\n  PgDateString,\n  PgDateStringBuilder,\n  date\n};\n//# sourceMappingURL=date.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgDoublePrecisionBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgDoublePrecisionBuilder\";\n  constructor(name) {\n    super(name, \"number\", \"PgDoublePrecision\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgDoublePrecision(\n      table,\n      this.config\n    );\n  }\n}\nclass PgDoublePrecision extends PgColumn {\n  static [entityKind] = \"PgDoublePrecision\";\n  getSQLType() {\n    return \"double precision\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      return Number.parseFloat(value);\n    }\n    return value;\n  }\n}\nfunction doublePrecision(name) {\n  return new PgDoublePrecisionBuilder(name ?? \"\");\n}\nexport {\n  PgDoublePrecision,\n  PgDoublePrecisionBuilder,\n  doublePrecision\n};\n//# sourceMappingURL=double-precision.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgInetBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgInetBuilder\";\n  constructor(name) {\n    super(name, \"string\", \"PgInet\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgInet(table, this.config);\n  }\n}\nclass PgInet extends PgColumn {\n  static [entityKind] = \"PgInet\";\n  getSQLType() {\n    return \"inet\";\n  }\n}\nfunction inet(name) {\n  return new PgInetBuilder(name ?? \"\");\n}\nexport {\n  PgInet,\n  PgInetBuilder,\n  inet\n};\n//# sourceMappingURL=inet.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgIntColumnBaseBuilder } from \"./int.common.js\";\nclass PgIntegerBuilder extends PgIntColumnBaseBuilder {\n  static [entityKind] = \"PgIntegerBuilder\";\n  constructor(name) {\n    super(name, \"number\", \"PgInteger\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgInteger(table, this.config);\n  }\n}\nclass PgInteger extends PgColumn {\n  static [entityKind] = \"PgInteger\";\n  getSQLType() {\n    return \"integer\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      return Number.parseInt(value);\n    }\n    return value;\n  }\n}\nfunction integer(name) {\n  return new PgIntegerBuilder(name ?? \"\");\n}\nexport {\n  PgInteger,\n  PgIntegerBuilder,\n  integer\n};\n//# sourceMappingURL=integer.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgIntervalBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgIntervalBuilder\";\n  constructor(name, intervalConfig) {\n    super(name, \"string\", \"PgInterval\");\n    this.config.intervalConfig = intervalConfig;\n  }\n  /** @internal */\n  build(table) {\n    return new PgInterval(table, this.config);\n  }\n}\nclass PgInterval extends PgColumn {\n  static [entityKind] = \"PgInterval\";\n  fields = this.config.intervalConfig.fields;\n  precision = this.config.intervalConfig.precision;\n  getSQLType() {\n    const fields = this.fields ? ` ${this.fields}` : \"\";\n    const precision = this.precision ? `(${this.precision})` : \"\";\n    return `interval${fields}${precision}`;\n  }\n}\nfunction interval(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgIntervalBuilder(name, config);\n}\nexport {\n  PgInterval,\n  PgIntervalBuilder,\n  interval\n};\n//# sourceMappingURL=interval.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgJsonBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgJsonBuilder\";\n  constructor(name) {\n    super(name, \"json\", \"PgJson\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgJson(table, this.config);\n  }\n}\nclass PgJson extends PgColumn {\n  static [entityKind] = \"PgJson\";\n  constructor(table, config) {\n    super(table, config);\n  }\n  getSQLType() {\n    return \"json\";\n  }\n  mapToDriverValue(value) {\n    return JSON.stringify(value);\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      try {\n        return JSON.parse(value);\n      } catch {\n        return value;\n      }\n    }\n    return value;\n  }\n}\nfunction json(name) {\n  return new PgJsonBuilder(name ?? \"\");\n}\nexport {\n  PgJson,\n  PgJsonBuilder,\n  json\n};\n//# sourceMappingURL=json.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgJsonbBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgJsonbBuilder\";\n  constructor(name) {\n    super(name, \"json\", \"PgJsonb\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgJsonb(table, this.config);\n  }\n}\nclass PgJsonb extends PgColumn {\n  static [entityKind] = \"PgJsonb\";\n  constructor(table, config) {\n    super(table, config);\n  }\n  getSQLType() {\n    return \"jsonb\";\n  }\n  mapToDriverValue(value) {\n    return JSON.stringify(value);\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      try {\n        return JSON.parse(value);\n      } catch {\n        return value;\n      }\n    }\n    return value;\n  }\n}\nfunction jsonb(name) {\n  return new PgJsonbBuilder(name ?? \"\");\n}\nexport {\n  PgJsonb,\n  PgJsonbBuilder,\n  jsonb\n};\n//# sourceMappingURL=jsonb.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgLineBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgLineBuilder\";\n  constructor(name) {\n    super(name, \"array\", \"PgLine\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgLineTuple(\n      table,\n      this.config\n    );\n  }\n}\nclass PgLineTuple extends PgColumn {\n  static [entityKind] = \"PgLine\";\n  getSQLType() {\n    return \"line\";\n  }\n  mapFromDriverValue(value) {\n    const [a, b, c] = value.slice(1, -1).split(\",\");\n    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];\n  }\n  mapToDriverValue(value) {\n    return `{${value[0]},${value[1]},${value[2]}}`;\n  }\n}\nclass PgLineABCBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgLineABCBuilder\";\n  constructor(name) {\n    super(name, \"json\", \"PgLineABC\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgLineABC(\n      table,\n      this.config\n    );\n  }\n}\nclass PgLineABC extends PgColumn {\n  static [entityKind] = \"PgLineABC\";\n  getSQLType() {\n    return \"line\";\n  }\n  mapFromDriverValue(value) {\n    const [a, b, c] = value.slice(1, -1).split(\",\");\n    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };\n  }\n  mapToDriverValue(value) {\n    return `{${value.a},${value.b},${value.c}}`;\n  }\n}\nfunction line(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (!config?.mode || config.mode === \"tuple\") {\n    return new PgLineBuilder(name);\n  }\n  return new PgLineABCBuilder(name);\n}\nexport {\n  PgLineABC,\n  PgLineABCBuilder,\n  PgLineBuilder,\n  PgLineTuple,\n  line\n};\n//# sourceMappingURL=line.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgMacaddrBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgMacaddrBuilder\";\n  constructor(name) {\n    super(name, \"string\", \"PgMacaddr\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgMacaddr(table, this.config);\n  }\n}\nclass PgMacaddr extends PgColumn {\n  static [entityKind] = \"PgMacaddr\";\n  getSQLType() {\n    return \"macaddr\";\n  }\n}\nfunction macaddr(name) {\n  return new PgMacaddrBuilder(name ?? \"\");\n}\nexport {\n  PgMacaddr,\n  PgMacaddrBuilder,\n  macaddr\n};\n//# sourceMappingURL=macaddr.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgMacaddr8Builder extends PgColumnBuilder {\n  static [entityKind] = \"PgMacaddr8Builder\";\n  constructor(name) {\n    super(name, \"string\", \"PgMacaddr8\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgMacaddr8(table, this.config);\n  }\n}\nclass PgMacaddr8 extends PgColumn {\n  static [entityKind] = \"PgMacaddr8\";\n  getSQLType() {\n    return \"macaddr8\";\n  }\n}\nfunction macaddr8(name) {\n  return new PgMacaddr8Builder(name ?? \"\");\n}\nexport {\n  PgMacaddr8,\n  PgMacaddr8Builder,\n  macaddr8\n};\n//# sourceMappingURL=macaddr8.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgNumericBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgNumericBuilder\";\n  constructor(name, precision, scale) {\n    super(name, \"string\", \"PgNumeric\");\n    this.config.precision = precision;\n    this.config.scale = scale;\n  }\n  /** @internal */\n  build(table) {\n    return new PgNumeric(table, this.config);\n  }\n}\nclass PgNumeric extends PgColumn {\n  static [entityKind] = \"PgNumeric\";\n  precision;\n  scale;\n  constructor(table, config) {\n    super(table, config);\n    this.precision = config.precision;\n    this.scale = config.scale;\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") return value;\n    return String(value);\n  }\n  getSQLType() {\n    if (this.precision !== void 0 && this.scale !== void 0) {\n      return `numeric(${this.precision}, ${this.scale})`;\n    } else if (this.precision === void 0) {\n      return \"numeric\";\n    } else {\n      return `numeric(${this.precision})`;\n    }\n  }\n}\nclass PgNumericNumberBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgNumericNumberBuilder\";\n  constructor(name, precision, scale) {\n    super(name, \"number\", \"PgNumericNumber\");\n    this.config.precision = precision;\n    this.config.scale = scale;\n  }\n  /** @internal */\n  build(table) {\n    return new PgNumericNumber(\n      table,\n      this.config\n    );\n  }\n}\nclass PgNumericNumber extends PgColumn {\n  static [entityKind] = \"PgNumericNumber\";\n  precision;\n  scale;\n  constructor(table, config) {\n    super(table, config);\n    this.precision = config.precision;\n    this.scale = config.scale;\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"number\") return value;\n    return Number(value);\n  }\n  mapToDriverValue = String;\n  getSQLType() {\n    if (this.precision !== void 0 && this.scale !== void 0) {\n      return `numeric(${this.precision}, ${this.scale})`;\n    } else if (this.precision === void 0) {\n      return \"numeric\";\n    } else {\n      return `numeric(${this.precision})`;\n    }\n  }\n}\nclass PgNumericBigIntBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgNumericBigIntBuilder\";\n  constructor(name, precision, scale) {\n    super(name, \"bigint\", \"PgNumericBigInt\");\n    this.config.precision = precision;\n    this.config.scale = scale;\n  }\n  /** @internal */\n  build(table) {\n    return new PgNumericBigInt(\n      table,\n      this.config\n    );\n  }\n}\nclass PgNumericBigInt extends PgColumn {\n  static [entityKind] = \"PgNumericBigInt\";\n  precision;\n  scale;\n  constructor(table, config) {\n    super(table, config);\n    this.precision = config.precision;\n    this.scale = config.scale;\n  }\n  mapFromDriverValue = BigInt;\n  mapToDriverValue = String;\n  getSQLType() {\n    if (this.precision !== void 0 && this.scale !== void 0) {\n      return `numeric(${this.precision}, ${this.scale})`;\n    } else if (this.precision === void 0) {\n      return \"numeric\";\n    } else {\n      return `numeric(${this.precision})`;\n    }\n  }\n}\nfunction numeric(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  const mode = config?.mode;\n  return mode === \"number\" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === \"bigint\" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);\n}\nconst decimal = numeric;\nexport {\n  PgNumeric,\n  PgNumericBigInt,\n  PgNumericBigIntBuilder,\n  PgNumericBuilder,\n  PgNumericNumber,\n  PgNumericNumberBuilder,\n  decimal,\n  numeric\n};\n//# sourceMappingURL=numeric.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgPointTupleBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgPointTupleBuilder\";\n  constructor(name) {\n    super(name, \"array\", \"PgPointTuple\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgPointTuple(\n      table,\n      this.config\n    );\n  }\n}\nclass PgPointTuple extends PgColumn {\n  static [entityKind] = \"PgPointTuple\";\n  getSQLType() {\n    return \"point\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      const [x, y] = value.slice(1, -1).split(\",\");\n      return [Number.parseFloat(x), Number.parseFloat(y)];\n    }\n    return [value.x, value.y];\n  }\n  mapToDriverValue(value) {\n    return `(${value[0]},${value[1]})`;\n  }\n}\nclass PgPointObjectBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgPointObjectBuilder\";\n  constructor(name) {\n    super(name, \"json\", \"PgPointObject\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgPointObject(\n      table,\n      this.config\n    );\n  }\n}\nclass PgPointObject extends PgColumn {\n  static [entityKind] = \"PgPointObject\";\n  getSQLType() {\n    return \"point\";\n  }\n  mapFromDriverValue(value) {\n    if (typeof value === \"string\") {\n      const [x, y] = value.slice(1, -1).split(\",\");\n      return { x: Number.parseFloat(x), y: Number.parseFloat(y) };\n    }\n    return value;\n  }\n  mapToDriverValue(value) {\n    return `(${value.x},${value.y})`;\n  }\n}\nfunction point(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (!config?.mode || config.mode === \"tuple\") {\n    return new PgPointTupleBuilder(name);\n  }\n  return new PgPointObjectBuilder(name);\n}\nexport {\n  PgPointObject,\n  PgPointObjectBuilder,\n  PgPointTuple,\n  PgPointTupleBuilder,\n  point\n};\n//# sourceMappingURL=point.js.map",
    "function hexToBytes(hex) {\n  const bytes = [];\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));\n  }\n  return new Uint8Array(bytes);\n}\nfunction bytesToFloat64(bytes, offset) {\n  const buffer = new ArrayBuffer(8);\n  const view = new DataView(buffer);\n  for (let i = 0; i < 8; i++) {\n    view.setUint8(i, bytes[offset + i]);\n  }\n  return view.getFloat64(0, true);\n}\nfunction parseEWKB(hex) {\n  const bytes = hexToBytes(hex);\n  let offset = 0;\n  const byteOrder = bytes[offset];\n  offset += 1;\n  const view = new DataView(bytes.buffer);\n  const geomType = view.getUint32(offset, byteOrder === 1);\n  offset += 4;\n  let _srid;\n  if (geomType & 536870912) {\n    _srid = view.getUint32(offset, byteOrder === 1);\n    offset += 4;\n  }\n  if ((geomType & 65535) === 1) {\n    const x = bytesToFloat64(bytes, offset);\n    offset += 8;\n    const y = bytesToFloat64(bytes, offset);\n    offset += 8;\n    return [x, y];\n  }\n  throw new Error(\"Unsupported geometry type\");\n}\nexport {\n  parseEWKB\n};\n//# sourceMappingURL=utils.js.map",
    "import { entityKind } from \"../../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"../common.js\";\nimport { parseEWKB } from \"./utils.js\";\nclass PgGeometryBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgGeometryBuilder\";\n  constructor(name) {\n    super(name, \"array\", \"PgGeometry\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgGeometry(\n      table,\n      this.config\n    );\n  }\n}\nclass PgGeometry extends PgColumn {\n  static [entityKind] = \"PgGeometry\";\n  getSQLType() {\n    return \"geometry(point)\";\n  }\n  mapFromDriverValue(value) {\n    return parseEWKB(value);\n  }\n  mapToDriverValue(value) {\n    return `point(${value[0]} ${value[1]})`;\n  }\n}\nclass PgGeometryObjectBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgGeometryObjectBuilder\";\n  constructor(name) {\n    super(name, \"json\", \"PgGeometryObject\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgGeometryObject(\n      table,\n      this.config\n    );\n  }\n}\nclass PgGeometryObject extends PgColumn {\n  static [entityKind] = \"PgGeometryObject\";\n  getSQLType() {\n    return \"geometry(point)\";\n  }\n  mapFromDriverValue(value) {\n    const parsed = parseEWKB(value);\n    return { x: parsed[0], y: parsed[1] };\n  }\n  mapToDriverValue(value) {\n    return `point(${value.x} ${value.y})`;\n  }\n}\nfunction geometry(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (!config?.mode || config.mode === \"tuple\") {\n    return new PgGeometryBuilder(name);\n  }\n  return new PgGeometryObjectBuilder(name);\n}\nexport {\n  PgGeometry,\n  PgGeometryBuilder,\n  PgGeometryObject,\n  PgGeometryObjectBuilder,\n  geometry\n};\n//# sourceMappingURL=geometry.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgRealBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgRealBuilder\";\n  constructor(name, length) {\n    super(name, \"number\", \"PgReal\");\n    this.config.length = length;\n  }\n  /** @internal */\n  build(table) {\n    return new PgReal(table, this.config);\n  }\n}\nclass PgReal extends PgColumn {\n  static [entityKind] = \"PgReal\";\n  constructor(table, config) {\n    super(table, config);\n  }\n  getSQLType() {\n    return \"real\";\n  }\n  mapFromDriverValue = (value) => {\n    if (typeof value === \"string\") {\n      return Number.parseFloat(value);\n    }\n    return value;\n  };\n}\nfunction real(name) {\n  return new PgRealBuilder(name ?? \"\");\n}\nexport {\n  PgReal,\n  PgRealBuilder,\n  real\n};\n//# sourceMappingURL=real.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgSerialBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgSerialBuilder\";\n  constructor(name) {\n    super(name, \"number\", \"PgSerial\");\n    this.config.hasDefault = true;\n    this.config.notNull = true;\n  }\n  /** @internal */\n  build(table) {\n    return new PgSerial(table, this.config);\n  }\n}\nclass PgSerial extends PgColumn {\n  static [entityKind] = \"PgSerial\";\n  getSQLType() {\n    return \"serial\";\n  }\n}\nfunction serial(name) {\n  return new PgSerialBuilder(name ?? \"\");\n}\nexport {\n  PgSerial,\n  PgSerialBuilder,\n  serial\n};\n//# sourceMappingURL=serial.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgIntColumnBaseBuilder } from \"./int.common.js\";\nclass PgSmallIntBuilder extends PgIntColumnBaseBuilder {\n  static [entityKind] = \"PgSmallIntBuilder\";\n  constructor(name) {\n    super(name, \"number\", \"PgSmallInt\");\n  }\n  /** @internal */\n  build(table) {\n    return new PgSmallInt(table, this.config);\n  }\n}\nclass PgSmallInt extends PgColumn {\n  static [entityKind] = \"PgSmallInt\";\n  getSQLType() {\n    return \"smallint\";\n  }\n  mapFromDriverValue = (value) => {\n    if (typeof value === \"string\") {\n      return Number(value);\n    }\n    return value;\n  };\n}\nfunction smallint(name) {\n  return new PgSmallIntBuilder(name ?? \"\");\n}\nexport {\n  PgSmallInt,\n  PgSmallIntBuilder,\n  smallint\n};\n//# sourceMappingURL=smallint.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgSmallSerialBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgSmallSerialBuilder\";\n  constructor(name) {\n    super(name, \"number\", \"PgSmallSerial\");\n    this.config.hasDefault = true;\n    this.config.notNull = true;\n  }\n  /** @internal */\n  build(table) {\n    return new PgSmallSerial(\n      table,\n      this.config\n    );\n  }\n}\nclass PgSmallSerial extends PgColumn {\n  static [entityKind] = \"PgSmallSerial\";\n  getSQLType() {\n    return \"smallserial\";\n  }\n}\nfunction smallserial(name) {\n  return new PgSmallSerialBuilder(name ?? \"\");\n}\nexport {\n  PgSmallSerial,\n  PgSmallSerialBuilder,\n  smallserial\n};\n//# sourceMappingURL=smallserial.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgTextBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgTextBuilder\";\n  constructor(name, config) {\n    super(name, \"string\", \"PgText\");\n    this.config.enumValues = config.enum;\n  }\n  /** @internal */\n  build(table) {\n    return new PgText(table, this.config);\n  }\n}\nclass PgText extends PgColumn {\n  static [entityKind] = \"PgText\";\n  enumValues = this.config.enumValues;\n  getSQLType() {\n    return \"text\";\n  }\n}\nfunction text(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgTextBuilder(name, config);\n}\nexport {\n  PgText,\n  PgTextBuilder,\n  text\n};\n//# sourceMappingURL=text.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgDateColumnBaseBuilder } from \"./date.common.js\";\nclass PgTimeBuilder extends PgDateColumnBaseBuilder {\n  constructor(name, withTimezone, precision) {\n    super(name, \"string\", \"PgTime\");\n    this.withTimezone = withTimezone;\n    this.precision = precision;\n    this.config.withTimezone = withTimezone;\n    this.config.precision = precision;\n  }\n  static [entityKind] = \"PgTimeBuilder\";\n  /** @internal */\n  build(table) {\n    return new PgTime(table, this.config);\n  }\n}\nclass PgTime extends PgColumn {\n  static [entityKind] = \"PgTime\";\n  withTimezone;\n  precision;\n  constructor(table, config) {\n    super(table, config);\n    this.withTimezone = config.withTimezone;\n    this.precision = config.precision;\n  }\n  getSQLType() {\n    const precision = this.precision === void 0 ? \"\" : `(${this.precision})`;\n    return `time${precision}${this.withTimezone ? \" with time zone\" : \"\"}`;\n  }\n}\nfunction time(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);\n}\nexport {\n  PgTime,\n  PgTimeBuilder,\n  time\n};\n//# sourceMappingURL=time.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn } from \"./common.js\";\nimport { PgDateColumnBaseBuilder } from \"./date.common.js\";\nclass PgTimestampBuilder extends PgDateColumnBaseBuilder {\n  static [entityKind] = \"PgTimestampBuilder\";\n  constructor(name, withTimezone, precision) {\n    super(name, \"date\", \"PgTimestamp\");\n    this.config.withTimezone = withTimezone;\n    this.config.precision = precision;\n  }\n  /** @internal */\n  build(table) {\n    return new PgTimestamp(table, this.config);\n  }\n}\nclass PgTimestamp extends PgColumn {\n  static [entityKind] = \"PgTimestamp\";\n  withTimezone;\n  precision;\n  constructor(table, config) {\n    super(table, config);\n    this.withTimezone = config.withTimezone;\n    this.precision = config.precision;\n  }\n  getSQLType() {\n    const precision = this.precision === void 0 ? \"\" : ` (${this.precision})`;\n    return `timestamp${precision}${this.withTimezone ? \" with time zone\" : \"\"}`;\n  }\n  mapFromDriverValue = (value) => {\n    return new Date(this.withTimezone ? value : value + \"+0000\");\n  };\n  mapToDriverValue = (value) => {\n    return value.toISOString();\n  };\n}\nclass PgTimestampStringBuilder extends PgDateColumnBaseBuilder {\n  static [entityKind] = \"PgTimestampStringBuilder\";\n  constructor(name, withTimezone, precision) {\n    super(name, \"string\", \"PgTimestampString\");\n    this.config.withTimezone = withTimezone;\n    this.config.precision = precision;\n  }\n  /** @internal */\n  build(table) {\n    return new PgTimestampString(\n      table,\n      this.config\n    );\n  }\n}\nclass PgTimestampString extends PgColumn {\n  static [entityKind] = \"PgTimestampString\";\n  withTimezone;\n  precision;\n  constructor(table, config) {\n    super(table, config);\n    this.withTimezone = config.withTimezone;\n    this.precision = config.precision;\n  }\n  getSQLType() {\n    const precision = this.precision === void 0 ? \"\" : `(${this.precision})`;\n    return `timestamp${precision}${this.withTimezone ? \" with time zone\" : \"\"}`;\n  }\n}\nfunction timestamp(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  if (config?.mode === \"string\") {\n    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);\n  }\n  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);\n}\nexport {\n  PgTimestamp,\n  PgTimestampBuilder,\n  PgTimestampString,\n  PgTimestampStringBuilder,\n  timestamp\n};\n//# sourceMappingURL=timestamp.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { sql } from \"../../sql/sql.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgUUIDBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgUUIDBuilder\";\n  constructor(name) {\n    super(name, \"string\", \"PgUUID\");\n  }\n  /**\n   * Adds `default gen_random_uuid()` to the column definition.\n   */\n  defaultRandom() {\n    return this.default(sql`gen_random_uuid()`);\n  }\n  /** @internal */\n  build(table) {\n    return new PgUUID(table, this.config);\n  }\n}\nclass PgUUID extends PgColumn {\n  static [entityKind] = \"PgUUID\";\n  getSQLType() {\n    return \"uuid\";\n  }\n}\nfunction uuid(name) {\n  return new PgUUIDBuilder(name ?? \"\");\n}\nexport {\n  PgUUID,\n  PgUUIDBuilder,\n  uuid\n};\n//# sourceMappingURL=uuid.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"./common.js\";\nclass PgVarcharBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgVarcharBuilder\";\n  constructor(name, config) {\n    super(name, \"string\", \"PgVarchar\");\n    this.config.length = config.length;\n    this.config.enumValues = config.enum;\n  }\n  /** @internal */\n  build(table) {\n    return new PgVarchar(\n      table,\n      this.config\n    );\n  }\n}\nclass PgVarchar extends PgColumn {\n  static [entityKind] = \"PgVarchar\";\n  length = this.config.length;\n  enumValues = this.config.enumValues;\n  getSQLType() {\n    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;\n  }\n}\nfunction varchar(a, b = {}) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgVarcharBuilder(name, config);\n}\nexport {\n  PgVarchar,\n  PgVarcharBuilder,\n  varchar\n};\n//# sourceMappingURL=varchar.js.map",
    "import { entityKind } from \"../../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"../common.js\";\nclass PgBinaryVectorBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgBinaryVectorBuilder\";\n  constructor(name, config) {\n    super(name, \"string\", \"PgBinaryVector\");\n    this.config.dimensions = config.dimensions;\n  }\n  /** @internal */\n  build(table) {\n    return new PgBinaryVector(\n      table,\n      this.config\n    );\n  }\n}\nclass PgBinaryVector extends PgColumn {\n  static [entityKind] = \"PgBinaryVector\";\n  dimensions = this.config.dimensions;\n  getSQLType() {\n    return `bit(${this.dimensions})`;\n  }\n}\nfunction bit(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgBinaryVectorBuilder(name, config);\n}\nexport {\n  PgBinaryVector,\n  PgBinaryVectorBuilder,\n  bit\n};\n//# sourceMappingURL=bit.js.map",
    "import { entityKind } from \"../../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"../common.js\";\nclass PgHalfVectorBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgHalfVectorBuilder\";\n  constructor(name, config) {\n    super(name, \"array\", \"PgHalfVector\");\n    this.config.dimensions = config.dimensions;\n  }\n  /** @internal */\n  build(table) {\n    return new PgHalfVector(\n      table,\n      this.config\n    );\n  }\n}\nclass PgHalfVector extends PgColumn {\n  static [entityKind] = \"PgHalfVector\";\n  dimensions = this.config.dimensions;\n  getSQLType() {\n    return `halfvec(${this.dimensions})`;\n  }\n  mapToDriverValue(value) {\n    return JSON.stringify(value);\n  }\n  mapFromDriverValue(value) {\n    return value.slice(1, -1).split(\",\").map((v) => Number.parseFloat(v));\n  }\n}\nfunction halfvec(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgHalfVectorBuilder(name, config);\n}\nexport {\n  PgHalfVector,\n  PgHalfVectorBuilder,\n  halfvec\n};\n//# sourceMappingURL=halfvec.js.map",
    "import { entityKind } from \"../../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"../common.js\";\nclass PgSparseVectorBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgSparseVectorBuilder\";\n  constructor(name, config) {\n    super(name, \"string\", \"PgSparseVector\");\n    this.config.dimensions = config.dimensions;\n  }\n  /** @internal */\n  build(table) {\n    return new PgSparseVector(\n      table,\n      this.config\n    );\n  }\n}\nclass PgSparseVector extends PgColumn {\n  static [entityKind] = \"PgSparseVector\";\n  dimensions = this.config.dimensions;\n  getSQLType() {\n    return `sparsevec(${this.dimensions})`;\n  }\n}\nfunction sparsevec(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgSparseVectorBuilder(name, config);\n}\nexport {\n  PgSparseVector,\n  PgSparseVectorBuilder,\n  sparsevec\n};\n//# sourceMappingURL=sparsevec.js.map",
    "import { entityKind } from \"../../../entity.js\";\nimport { getColumnNameAndConfig } from \"../../../utils.js\";\nimport { PgColumn, PgColumnBuilder } from \"../common.js\";\nclass PgVectorBuilder extends PgColumnBuilder {\n  static [entityKind] = \"PgVectorBuilder\";\n  constructor(name, config) {\n    super(name, \"array\", \"PgVector\");\n    this.config.dimensions = config.dimensions;\n  }\n  /** @internal */\n  build(table) {\n    return new PgVector(\n      table,\n      this.config\n    );\n  }\n}\nclass PgVector extends PgColumn {\n  static [entityKind] = \"PgVector\";\n  dimensions = this.config.dimensions;\n  getSQLType() {\n    return `vector(${this.dimensions})`;\n  }\n  mapToDriverValue(value) {\n    return JSON.stringify(value);\n  }\n  mapFromDriverValue(value) {\n    return value.slice(1, -1).split(\",\").map((v) => Number.parseFloat(v));\n  }\n}\nfunction vector(a, b) {\n  const { name, config } = getColumnNameAndConfig(a, b);\n  return new PgVectorBuilder(name, config);\n}\nexport {\n  PgVector,\n  PgVectorBuilder,\n  vector\n};\n//# sourceMappingURL=vector.js.map",
    "import { bigint } from \"./bigint.js\";\nimport { bigserial } from \"./bigserial.js\";\nimport { boolean } from \"./boolean.js\";\nimport { char } from \"./char.js\";\nimport { cidr } from \"./cidr.js\";\nimport { customType } from \"./custom.js\";\nimport { date } from \"./date.js\";\nimport { doublePrecision } from \"./double-precision.js\";\nimport { inet } from \"./inet.js\";\nimport { integer } from \"./integer.js\";\nimport { interval } from \"./interval.js\";\nimport { json } from \"./json.js\";\nimport { jsonb } from \"./jsonb.js\";\nimport { line } from \"./line.js\";\nimport { macaddr } from \"./macaddr.js\";\nimport { macaddr8 } from \"./macaddr8.js\";\nimport { numeric } from \"./numeric.js\";\nimport { point } from \"./point.js\";\nimport { geometry } from \"./postgis_extension/geometry.js\";\nimport { real } from \"./real.js\";\nimport { serial } from \"./serial.js\";\nimport { smallint } from \"./smallint.js\";\nimport { smallserial } from \"./smallserial.js\";\nimport { text } from \"./text.js\";\nimport { time } from \"./time.js\";\nimport { timestamp } from \"./timestamp.js\";\nimport { uuid } from \"./uuid.js\";\nimport { varchar } from \"./varchar.js\";\nimport { bit } from \"./vector_extension/bit.js\";\nimport { halfvec } from \"./vector_extension/halfvec.js\";\nimport { sparsevec } from \"./vector_extension/sparsevec.js\";\nimport { vector } from \"./vector_extension/vector.js\";\nfunction getPgColumnBuilders() {\n  return {\n    bigint,\n    bigserial,\n    boolean,\n    char,\n    cidr,\n    customType,\n    date,\n    doublePrecision,\n    inet,\n    integer,\n    interval,\n    json,\n    jsonb,\n    line,\n    macaddr,\n    macaddr8,\n    numeric,\n    point,\n    geometry,\n    real,\n    serial,\n    smallint,\n    smallserial,\n    text,\n    time,\n    timestamp,\n    uuid,\n    varchar,\n    bit,\n    halfvec,\n    sparsevec,\n    vector\n  };\n}\nexport {\n  getPgColumnBuilders\n};\n//# sourceMappingURL=all.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { Table } from \"../table.js\";\nimport { getPgColumnBuilders } from \"./columns/all.js\";\nconst InlineForeignKeys = Symbol.for(\"drizzle:PgInlineForeignKeys\");\nconst EnableRLS = Symbol.for(\"drizzle:EnableRLS\");\nclass PgTable extends Table {\n  static [entityKind] = \"PgTable\";\n  /** @internal */\n  static Symbol = Object.assign({}, Table.Symbol, {\n    InlineForeignKeys,\n    EnableRLS\n  });\n  /**@internal */\n  [InlineForeignKeys] = [];\n  /** @internal */\n  [EnableRLS] = false;\n  /** @internal */\n  [Table.Symbol.ExtraConfigBuilder] = void 0;\n  /** @internal */\n  [Table.Symbol.ExtraConfigColumns] = {};\n}\nfunction pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {\n  const rawTable = new PgTable(name, schema, baseName);\n  const parsedColumns = typeof columns === \"function\" ? columns(getPgColumnBuilders()) : columns;\n  const builtColumns = Object.fromEntries(\n    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {\n      const colBuilder = colBuilderBase;\n      colBuilder.setName(name2);\n      const column = colBuilder.build(rawTable);\n      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n      return [name2, column];\n    })\n  );\n  const builtColumnsForExtraConfig = Object.fromEntries(\n    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {\n      const colBuilder = colBuilderBase;\n      colBuilder.setName(name2);\n      const column = colBuilder.buildExtraConfigColumn(rawTable);\n      return [name2, column];\n    })\n  );\n  const table = Object.assign(rawTable, builtColumns);\n  table[Table.Symbol.Columns] = builtColumns;\n  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n  if (extraConfig) {\n    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;\n  }\n  return Object.assign(table, {\n    enableRLS: () => {\n      table[PgTable.Symbol.EnableRLS] = true;\n      return table;\n    }\n  });\n}\nconst pgTable = (name, columns, extraConfig) => {\n  return pgTableWithSchema(name, columns, extraConfig, void 0);\n};\nfunction pgTableCreator(customizeTableName) {\n  return (name, columns, extraConfig) => {\n    return pgTableWithSchema(customizeTableName(name), columns, extraConfig, void 0, name);\n  };\n}\nexport {\n  EnableRLS,\n  InlineForeignKeys,\n  PgTable,\n  pgTable,\n  pgTableCreator,\n  pgTableWithSchema\n};\n//# sourceMappingURL=table.js.map",
    "import { entityKind } from \"../entity.js\";\nclass CheckBuilder {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n  }\n  static [entityKind] = \"PgCheckBuilder\";\n  brand;\n  /** @internal */\n  build(table) {\n    return new Check(table, this);\n  }\n}\nclass Check {\n  constructor(table, builder) {\n    this.table = table;\n    this.name = builder.name;\n    this.value = builder.value;\n  }\n  static [entityKind] = \"PgCheck\";\n  name;\n  value;\n}\nfunction check(name, value) {\n  return new CheckBuilder(name, value);\n}\nexport {\n  Check,\n  CheckBuilder,\n  check\n};\n//# sourceMappingURL=checks.js.map",
    "export * from \"./bigint.js\";\nexport * from \"./bigserial.js\";\nexport * from \"./boolean.js\";\nexport * from \"./char.js\";\nexport * from \"./cidr.js\";\nexport * from \"./common.js\";\nexport * from \"./custom.js\";\nexport * from \"./date.js\";\nexport * from \"./double-precision.js\";\nexport * from \"./enum.js\";\nexport * from \"./inet.js\";\nexport * from \"./int.common.js\";\nexport * from \"./integer.js\";\nexport * from \"./interval.js\";\nexport * from \"./json.js\";\nexport * from \"./jsonb.js\";\nexport * from \"./line.js\";\nexport * from \"./macaddr.js\";\nexport * from \"./macaddr8.js\";\nexport * from \"./numeric.js\";\nexport * from \"./point.js\";\nexport * from \"./postgis_extension/geometry.js\";\nexport * from \"./real.js\";\nexport * from \"./serial.js\";\nexport * from \"./smallint.js\";\nexport * from \"./smallserial.js\";\nexport * from \"./text.js\";\nexport * from \"./time.js\";\nexport * from \"./timestamp.js\";\nexport * from \"./uuid.js\";\nexport * from \"./varchar.js\";\nexport * from \"./vector_extension/bit.js\";\nexport * from \"./vector_extension/halfvec.js\";\nexport * from \"./vector_extension/sparsevec.js\";\nexport * from \"./vector_extension/vector.js\";\n//# sourceMappingURL=index.js.map",
    "import { SQL } from \"../sql/sql.js\";\nimport { entityKind, is } from \"../entity.js\";\nimport { IndexedColumn } from \"./columns/index.js\";\nclass IndexBuilderOn {\n  constructor(unique, name) {\n    this.unique = unique;\n    this.name = name;\n  }\n  static [entityKind] = \"PgIndexBuilderOn\";\n  on(...columns) {\n    return new IndexBuilder(\n      columns.map((it) => {\n        if (is(it, SQL)) {\n          return it;\n        }\n        it = it;\n        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);\n        it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n        return clonedIndexedColumn;\n      }),\n      this.unique,\n      false,\n      this.name\n    );\n  }\n  onOnly(...columns) {\n    return new IndexBuilder(\n      columns.map((it) => {\n        if (is(it, SQL)) {\n          return it;\n        }\n        it = it;\n        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);\n        it.indexConfig = it.defaultConfig;\n        return clonedIndexedColumn;\n      }),\n      this.unique,\n      true,\n      this.name\n    );\n  }\n  /**\n   * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.\n   *\n   * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.\n   *\n   * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**\n   *\n   * @param method The name of the index method to be used\n   * @param columns\n   * @returns\n   */\n  using(method, ...columns) {\n    return new IndexBuilder(\n      columns.map((it) => {\n        if (is(it, SQL)) {\n          return it;\n        }\n        it = it;\n        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);\n        it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n        return clonedIndexedColumn;\n      }),\n      this.unique,\n      true,\n      this.name,\n      method\n    );\n  }\n}\nclass IndexBuilder {\n  static [entityKind] = \"PgIndexBuilder\";\n  /** @internal */\n  config;\n  constructor(columns, unique, only, name, method = \"btree\") {\n    this.config = {\n      name,\n      columns,\n      unique,\n      only,\n      method\n    };\n  }\n  concurrently() {\n    this.config.concurrently = true;\n    return this;\n  }\n  with(obj) {\n    this.config.with = obj;\n    return this;\n  }\n  where(condition) {\n    this.config.where = condition;\n    return this;\n  }\n  /** @internal */\n  build(table) {\n    return new Index(this.config, table);\n  }\n}\nclass Index {\n  static [entityKind] = \"PgIndex\";\n  config;\n  constructor(config, table) {\n    this.config = { ...config, table };\n  }\n}\nfunction index(name) {\n  return new IndexBuilderOn(false, name);\n}\nfunction uniqueIndex(name) {\n  return new IndexBuilderOn(true, name);\n}\nexport {\n  Index,\n  IndexBuilder,\n  IndexBuilderOn,\n  index,\n  uniqueIndex\n};\n//# sourceMappingURL=indexes.js.map",
    "import { entityKind } from \"../entity.js\";\nclass PgPolicy {\n  constructor(name, config) {\n    this.name = name;\n    if (config) {\n      this.as = config.as;\n      this.for = config.for;\n      this.to = config.to;\n      this.using = config.using;\n      this.withCheck = config.withCheck;\n    }\n  }\n  static [entityKind] = \"PgPolicy\";\n  as;\n  for;\n  to;\n  using;\n  withCheck;\n  /** @internal */\n  _linkedTable;\n  link(table) {\n    this._linkedTable = table;\n    return this;\n  }\n}\nfunction pgPolicy(name, config) {\n  return new PgPolicy(name, config);\n}\nexport {\n  PgPolicy,\n  pgPolicy\n};\n//# sourceMappingURL=policies.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { PgTable } from \"./table.js\";\nfunction primaryKey(...config) {\n  if (config[0].columns) {\n    return new PrimaryKeyBuilder(config[0].columns, config[0].name);\n  }\n  return new PrimaryKeyBuilder(config);\n}\nclass PrimaryKeyBuilder {\n  static [entityKind] = \"PgPrimaryKeyBuilder\";\n  /** @internal */\n  columns;\n  /** @internal */\n  name;\n  constructor(columns, name) {\n    this.columns = columns;\n    this.name = name;\n  }\n  /** @internal */\n  build(table) {\n    return new PrimaryKey(table, this.columns, this.name);\n  }\n}\nclass PrimaryKey {\n  constructor(table, columns, name) {\n    this.table = table;\n    this.columns = columns;\n    this.name = name;\n  }\n  static [entityKind] = \"PgPrimaryKey\";\n  columns;\n  name;\n  getName() {\n    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join(\"_\")}_pk`;\n  }\n}\nexport {\n  PrimaryKey,\n  PrimaryKeyBuilder,\n  primaryKey\n};\n//# sourceMappingURL=primary-keys.js.map",
    "const PgViewConfig = Symbol.for(\"drizzle:PgViewConfig\");\nexport {\n  PgViewConfig\n};\n//# sourceMappingURL=view-common.js.map",
    "import { entityKind } from \"./entity.js\";\nimport { Table } from \"./table.js\";\nfunction toSnakeCase(input) {\n  const words = input.replace(/['\\u2019]/g, \"\").match(/[\\da-z]+|[A-Z]+(?![a-z])|[A-Z][\\da-z]+/g) ?? [];\n  return words.map((word) => word.toLowerCase()).join(\"_\");\n}\nfunction toCamelCase(input) {\n  const words = input.replace(/['\\u2019]/g, \"\").match(/[\\da-z]+|[A-Z]+(?![a-z])|[A-Z][\\da-z]+/g) ?? [];\n  return words.reduce((acc, word, i) => {\n    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;\n    return acc + formattedWord;\n  }, \"\");\n}\nfunction noopCase(input) {\n  return input;\n}\nclass CasingCache {\n  static [entityKind] = \"CasingCache\";\n  /** @internal */\n  cache = {};\n  cachedTables = {};\n  convert;\n  constructor(casing) {\n    this.convert = casing === \"snake_case\" ? toSnakeCase : casing === \"camelCase\" ? toCamelCase : noopCase;\n  }\n  getColumnCasing(column) {\n    if (!column.keyAsName) return column.name;\n    const schema = column.table[Table.Symbol.Schema] ?? \"public\";\n    const tableName = column.table[Table.Symbol.OriginalName];\n    const key = `${schema}.${tableName}.${column.name}`;\n    if (!this.cache[key]) {\n      this.cacheTable(column.table);\n    }\n    return this.cache[key];\n  }\n  cacheTable(table) {\n    const schema = table[Table.Symbol.Schema] ?? \"public\";\n    const tableName = table[Table.Symbol.OriginalName];\n    const tableKey = `${schema}.${tableName}`;\n    if (!this.cachedTables[tableKey]) {\n      for (const column of Object.values(table[Table.Symbol.Columns])) {\n        const columnKey = `${tableKey}.${column.name}`;\n        this.cache[columnKey] = this.convert(column.name);\n      }\n      this.cachedTables[tableKey] = true;\n    }\n  }\n  clearCache() {\n    this.cache = {};\n    this.cachedTables = {};\n  }\n}\nexport {\n  CasingCache,\n  toCamelCase,\n  toSnakeCase\n};\n//# sourceMappingURL=casing.js.map",
    "import { entityKind } from \"./entity.js\";\nclass DrizzleError extends Error {\n  static [entityKind] = \"DrizzleError\";\n  constructor({ message, cause }) {\n    super(message);\n    this.name = \"DrizzleError\";\n    this.cause = cause;\n  }\n}\nclass DrizzleQueryError extends Error {\n  constructor(query, params, cause) {\n    super(`Failed query: ${query}\nparams: ${params}`);\n    this.query = query;\n    this.params = params;\n    this.cause = cause;\n    Error.captureStackTrace(this, DrizzleQueryError);\n    if (cause) this.cause = cause;\n  }\n}\nclass TransactionRollbackError extends DrizzleError {\n  static [entityKind] = \"TransactionRollbackError\";\n  constructor() {\n    super({ message: \"Rollback\" });\n  }\n}\nexport {\n  DrizzleError,\n  DrizzleQueryError,\n  TransactionRollbackError\n};\n//# sourceMappingURL=errors.js.map",
    "import { Column } from \"../../column.js\";\nimport { is } from \"../../entity.js\";\nimport { Table } from \"../../table.js\";\nimport {\n  isDriverValueEncoder,\n  isSQLWrapper,\n  Param,\n  Placeholder,\n  SQL,\n  sql,\n  StringChunk,\n  View\n} from \"../sql.js\";\nfunction bindIfParam(value, column) {\n  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {\n    return new Param(value, column);\n  }\n  return value;\n}\nconst eq = (left, right) => {\n  return sql`${left} = ${bindIfParam(right, left)}`;\n};\nconst ne = (left, right) => {\n  return sql`${left} <> ${bindIfParam(right, left)}`;\n};\nfunction and(...unfilteredConditions) {\n  const conditions = unfilteredConditions.filter(\n    (c) => c !== void 0\n  );\n  if (conditions.length === 0) {\n    return void 0;\n  }\n  if (conditions.length === 1) {\n    return new SQL(conditions);\n  }\n  return new SQL([\n    new StringChunk(\"(\"),\n    sql.join(conditions, new StringChunk(\" and \")),\n    new StringChunk(\")\")\n  ]);\n}\nfunction or(...unfilteredConditions) {\n  const conditions = unfilteredConditions.filter(\n    (c) => c !== void 0\n  );\n  if (conditions.length === 0) {\n    return void 0;\n  }\n  if (conditions.length === 1) {\n    return new SQL(conditions);\n  }\n  return new SQL([\n    new StringChunk(\"(\"),\n    sql.join(conditions, new StringChunk(\" or \")),\n    new StringChunk(\")\")\n  ]);\n}\nfunction not(condition) {\n  return sql`not ${condition}`;\n}\nconst gt = (left, right) => {\n  return sql`${left} > ${bindIfParam(right, left)}`;\n};\nconst gte = (left, right) => {\n  return sql`${left} >= ${bindIfParam(right, left)}`;\n};\nconst lt = (left, right) => {\n  return sql`${left} < ${bindIfParam(right, left)}`;\n};\nconst lte = (left, right) => {\n  return sql`${left} <= ${bindIfParam(right, left)}`;\n};\nfunction inArray(column, values) {\n  if (Array.isArray(values)) {\n    if (values.length === 0) {\n      return sql`false`;\n    }\n    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n  }\n  return sql`${column} in ${bindIfParam(values, column)}`;\n}\nfunction notInArray(column, values) {\n  if (Array.isArray(values)) {\n    if (values.length === 0) {\n      return sql`true`;\n    }\n    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n  }\n  return sql`${column} not in ${bindIfParam(values, column)}`;\n}\nfunction isNull(value) {\n  return sql`${value} is null`;\n}\nfunction isNotNull(value) {\n  return sql`${value} is not null`;\n}\nfunction exists(subquery) {\n  return sql`exists ${subquery}`;\n}\nfunction notExists(subquery) {\n  return sql`not exists ${subquery}`;\n}\nfunction between(column, min, max) {\n  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(\n    max,\n    column\n  )}`;\n}\nfunction notBetween(column, min, max) {\n  return sql`${column} not between ${bindIfParam(\n    min,\n    column\n  )} and ${bindIfParam(max, column)}`;\n}\nfunction like(column, value) {\n  return sql`${column} like ${value}`;\n}\nfunction notLike(column, value) {\n  return sql`${column} not like ${value}`;\n}\nfunction ilike(column, value) {\n  return sql`${column} ilike ${value}`;\n}\nfunction notIlike(column, value) {\n  return sql`${column} not ilike ${value}`;\n}\nfunction arrayContains(column, values) {\n  if (Array.isArray(values)) {\n    if (values.length === 0) {\n      throw new Error(\"arrayContains requires at least one value\");\n    }\n    const array = sql`${bindIfParam(values, column)}`;\n    return sql`${column} @> ${array}`;\n  }\n  return sql`${column} @> ${bindIfParam(values, column)}`;\n}\nfunction arrayContained(column, values) {\n  if (Array.isArray(values)) {\n    if (values.length === 0) {\n      throw new Error(\"arrayContained requires at least one value\");\n    }\n    const array = sql`${bindIfParam(values, column)}`;\n    return sql`${column} <@ ${array}`;\n  }\n  return sql`${column} <@ ${bindIfParam(values, column)}`;\n}\nfunction arrayOverlaps(column, values) {\n  if (Array.isArray(values)) {\n    if (values.length === 0) {\n      throw new Error(\"arrayOverlaps requires at least one value\");\n    }\n    const array = sql`${bindIfParam(values, column)}`;\n    return sql`${column} && ${array}`;\n  }\n  return sql`${column} && ${bindIfParam(values, column)}`;\n}\nexport {\n  and,\n  arrayContained,\n  arrayContains,\n  arrayOverlaps,\n  between,\n  bindIfParam,\n  eq,\n  exists,\n  gt,\n  gte,\n  ilike,\n  inArray,\n  isNotNull,\n  isNull,\n  like,\n  lt,\n  lte,\n  ne,\n  not,\n  notBetween,\n  notExists,\n  notIlike,\n  notInArray,\n  notLike,\n  or\n};\n//# sourceMappingURL=conditions.js.map",
    "import { sql } from \"../sql.js\";\nfunction asc(column) {\n  return sql`${column} asc`;\n}\nfunction desc(column) {\n  return sql`${column} desc`;\n}\nexport {\n  asc,\n  desc\n};\n//# sourceMappingURL=select.js.map",
    "export * from \"./conditions.js\";\nexport * from \"./select.js\";\n//# sourceMappingURL=index.js.map",
    "import { getTableUniqueName, Table } from \"./table.js\";\nimport { Column } from \"./column.js\";\nimport { entityKind, is } from \"./entity.js\";\nimport { PrimaryKeyBuilder } from \"./pg-core/primary-keys.js\";\nimport {\n  and,\n  asc,\n  between,\n  desc,\n  eq,\n  exists,\n  gt,\n  gte,\n  ilike,\n  inArray,\n  isNotNull,\n  isNull,\n  like,\n  lt,\n  lte,\n  ne,\n  not,\n  notBetween,\n  notExists,\n  notIlike,\n  notInArray,\n  notLike,\n  or\n} from \"./sql/expressions/index.js\";\nimport { SQL, sql } from \"./sql/sql.js\";\nclass Relation {\n  constructor(sourceTable, referencedTable, relationName) {\n    this.sourceTable = sourceTable;\n    this.referencedTable = referencedTable;\n    this.relationName = relationName;\n    this.referencedTableName = referencedTable[Table.Symbol.Name];\n  }\n  static [entityKind] = \"Relation\";\n  referencedTableName;\n  fieldName;\n}\nclass Relations {\n  constructor(table, config) {\n    this.table = table;\n    this.config = config;\n  }\n  static [entityKind] = \"Relations\";\n}\nclass One extends Relation {\n  constructor(sourceTable, referencedTable, config, isNullable) {\n    super(sourceTable, referencedTable, config?.relationName);\n    this.config = config;\n    this.isNullable = isNullable;\n  }\n  static [entityKind] = \"One\";\n  withFieldName(fieldName) {\n    const relation = new One(\n      this.sourceTable,\n      this.referencedTable,\n      this.config,\n      this.isNullable\n    );\n    relation.fieldName = fieldName;\n    return relation;\n  }\n}\nclass Many extends Relation {\n  constructor(sourceTable, referencedTable, config) {\n    super(sourceTable, referencedTable, config?.relationName);\n    this.config = config;\n  }\n  static [entityKind] = \"Many\";\n  withFieldName(fieldName) {\n    const relation = new Many(\n      this.sourceTable,\n      this.referencedTable,\n      this.config\n    );\n    relation.fieldName = fieldName;\n    return relation;\n  }\n}\nfunction getOperators() {\n  return {\n    and,\n    between,\n    eq,\n    exists,\n    gt,\n    gte,\n    ilike,\n    inArray,\n    isNull,\n    isNotNull,\n    like,\n    lt,\n    lte,\n    ne,\n    not,\n    notBetween,\n    notExists,\n    notLike,\n    notIlike,\n    notInArray,\n    or,\n    sql\n  };\n}\nfunction getOrderByOperators() {\n  return {\n    sql,\n    asc,\n    desc\n  };\n}\nfunction extractTablesRelationalConfig(schema, configHelpers) {\n  if (Object.keys(schema).length === 1 && \"default\" in schema && !is(schema[\"default\"], Table)) {\n    schema = schema[\"default\"];\n  }\n  const tableNamesMap = {};\n  const relationsBuffer = {};\n  const tablesConfig = {};\n  for (const [key, value] of Object.entries(schema)) {\n    if (is(value, Table)) {\n      const dbName = getTableUniqueName(value);\n      const bufferedRelations = relationsBuffer[dbName];\n      tableNamesMap[dbName] = key;\n      tablesConfig[key] = {\n        tsName: key,\n        dbName: value[Table.Symbol.Name],\n        schema: value[Table.Symbol.Schema],\n        columns: value[Table.Symbol.Columns],\n        relations: bufferedRelations?.relations ?? {},\n        primaryKey: bufferedRelations?.primaryKey ?? []\n      };\n      for (const column of Object.values(\n        value[Table.Symbol.Columns]\n      )) {\n        if (column.primary) {\n          tablesConfig[key].primaryKey.push(column);\n        }\n      }\n      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);\n      if (extraConfig) {\n        for (const configEntry of Object.values(extraConfig)) {\n          if (is(configEntry, PrimaryKeyBuilder)) {\n            tablesConfig[key].primaryKey.push(...configEntry.columns);\n          }\n        }\n      }\n    } else if (is(value, Relations)) {\n      const dbName = getTableUniqueName(value.table);\n      const tableName = tableNamesMap[dbName];\n      const relations2 = value.config(\n        configHelpers(value.table)\n      );\n      let primaryKey;\n      for (const [relationName, relation] of Object.entries(relations2)) {\n        if (tableName) {\n          const tableConfig = tablesConfig[tableName];\n          tableConfig.relations[relationName] = relation;\n          if (primaryKey) {\n            tableConfig.primaryKey.push(...primaryKey);\n          }\n        } else {\n          if (!(dbName in relationsBuffer)) {\n            relationsBuffer[dbName] = {\n              relations: {},\n              primaryKey\n            };\n          }\n          relationsBuffer[dbName].relations[relationName] = relation;\n        }\n      }\n    }\n  }\n  return { tables: tablesConfig, tableNamesMap };\n}\nfunction relations(table, relations2) {\n  return new Relations(\n    table,\n    (helpers) => Object.fromEntries(\n      Object.entries(relations2(helpers)).map(([key, value]) => [\n        key,\n        value.withFieldName(key)\n      ])\n    )\n  );\n}\nfunction createOne(sourceTable) {\n  return function one(table, config) {\n    return new One(\n      sourceTable,\n      table,\n      config,\n      config?.fields.reduce((res, f) => res && f.notNull, true) ?? false\n    );\n  };\n}\nfunction createMany(sourceTable) {\n  return function many(referencedTable, config) {\n    return new Many(sourceTable, referencedTable, config);\n  };\n}\nfunction normalizeRelation(schema, tableNamesMap, relation) {\n  if (is(relation, One) && relation.config) {\n    return {\n      fields: relation.config.fields,\n      references: relation.config.references\n    };\n  }\n  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];\n  if (!referencedTableTsName) {\n    throw new Error(\n      `Table \"${relation.referencedTable[Table.Symbol.Name]}\" not found in schema`\n    );\n  }\n  const referencedTableConfig = schema[referencedTableTsName];\n  if (!referencedTableConfig) {\n    throw new Error(`Table \"${referencedTableTsName}\" not found in schema`);\n  }\n  const sourceTable = relation.sourceTable;\n  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];\n  if (!sourceTableTsName) {\n    throw new Error(\n      `Table \"${sourceTable[Table.Symbol.Name]}\" not found in schema`\n    );\n  }\n  const reverseRelations = [];\n  for (const referencedTableRelation of Object.values(\n    referencedTableConfig.relations\n  )) {\n    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {\n      reverseRelations.push(referencedTableRelation);\n    }\n  }\n  if (reverseRelations.length > 1) {\n    throw relation.relationName ? new Error(\n      `There are multiple relations with name \"${relation.relationName}\" in table \"${referencedTableTsName}\"`\n    ) : new Error(\n      `There are multiple relations between \"${referencedTableTsName}\" and \"${relation.sourceTable[Table.Symbol.Name]}\". Please specify relation name`\n    );\n  }\n  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {\n    return {\n      fields: reverseRelations[0].config.references,\n      references: reverseRelations[0].config.fields\n    };\n  }\n  throw new Error(\n    `There is not enough information to infer relation \"${sourceTableTsName}.${relation.fieldName}\"`\n  );\n}\nfunction createTableRelationsHelpers(sourceTable) {\n  return {\n    one: createOne(sourceTable),\n    many: createMany(sourceTable)\n  };\n}\nfunction mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {\n  const result = {};\n  for (const [\n    selectionItemIndex,\n    selectionItem\n  ] of buildQueryResultSelection.entries()) {\n    if (selectionItem.isJson) {\n      const relation = tableConfig.relations[selectionItem.tsKey];\n      const rawSubRows = row[selectionItemIndex];\n      const subRows = typeof rawSubRows === \"string\" ? JSON.parse(rawSubRows) : rawSubRows;\n      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(\n        tablesConfig,\n        tablesConfig[selectionItem.relationTableTsKey],\n        subRows,\n        selectionItem.selection,\n        mapColumnValue\n      ) : subRows.map(\n        (subRow) => mapRelationalRow(\n          tablesConfig,\n          tablesConfig[selectionItem.relationTableTsKey],\n          subRow,\n          selectionItem.selection,\n          mapColumnValue\n        )\n      );\n    } else {\n      const value = mapColumnValue(row[selectionItemIndex]);\n      const field = selectionItem.field;\n      let decoder;\n      if (is(field, Column)) {\n        decoder = field;\n      } else if (is(field, SQL)) {\n        decoder = field.decoder;\n      } else {\n        decoder = field.sql.decoder;\n      }\n      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n    }\n  }\n  return result;\n}\nexport {\n  Many,\n  One,\n  Relation,\n  Relations,\n  createMany,\n  createOne,\n  createTableRelationsHelpers,\n  extractTablesRelationalConfig,\n  getOperators,\n  getOrderByOperators,\n  mapRelationalRow,\n  normalizeRelation,\n  relations\n};\n//# sourceMappingURL=relations.js.map",
    "import { Column } from \"../../column.js\";\nimport { is } from \"../../entity.js\";\nimport { sql } from \"../sql.js\";\nfunction count(expression) {\n  return sql`count(${expression || sql.raw(\"*\")})`.mapWith(Number);\n}\nfunction countDistinct(expression) {\n  return sql`count(distinct ${expression})`.mapWith(Number);\n}\nfunction avg(expression) {\n  return sql`avg(${expression})`.mapWith(String);\n}\nfunction avgDistinct(expression) {\n  return sql`avg(distinct ${expression})`.mapWith(String);\n}\nfunction sum(expression) {\n  return sql`sum(${expression})`.mapWith(String);\n}\nfunction sumDistinct(expression) {\n  return sql`sum(distinct ${expression})`.mapWith(String);\n}\nfunction max(expression) {\n  return sql`max(${expression})`.mapWith(is(expression, Column) ? expression : String);\n}\nfunction min(expression) {\n  return sql`min(${expression})`.mapWith(is(expression, Column) ? expression : String);\n}\nexport {\n  avg,\n  avgDistinct,\n  count,\n  countDistinct,\n  max,\n  min,\n  sum,\n  sumDistinct\n};\n//# sourceMappingURL=aggregate.js.map",
    "import { sql } from \"../sql.js\";\nfunction toSql(value) {\n  return JSON.stringify(value);\n}\nfunction l2Distance(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <-> ${toSql(value)}`;\n  }\n  return sql`${column} <-> ${value}`;\n}\nfunction l1Distance(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <+> ${toSql(value)}`;\n  }\n  return sql`${column} <+> ${value}`;\n}\nfunction innerProduct(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <#> ${toSql(value)}`;\n  }\n  return sql`${column} <#> ${value}`;\n}\nfunction cosineDistance(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <=> ${toSql(value)}`;\n  }\n  return sql`${column} <=> ${value}`;\n}\nfunction hammingDistance(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <~> ${toSql(value)}`;\n  }\n  return sql`${column} <~> ${value}`;\n}\nfunction jaccardDistance(column, value) {\n  if (Array.isArray(value)) {\n    return sql`${column} <%> ${toSql(value)}`;\n  }\n  return sql`${column} <%> ${value}`;\n}\nexport {\n  cosineDistance,\n  hammingDistance,\n  innerProduct,\n  jaccardDistance,\n  l1Distance,\n  l2Distance\n};\n//# sourceMappingURL=vector.js.map",
    "export * from \"./aggregate.js\";\nexport * from \"./vector.js\";\n//# sourceMappingURL=index.js.map",
    "export * from \"./expressions/index.js\";\nexport * from \"./functions/index.js\";\nexport * from \"./sql.js\";\n//# sourceMappingURL=index.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { View } from \"../sql/sql.js\";\nclass PgViewBase extends View {\n  static [entityKind] = \"PgViewBase\";\n}\nexport {\n  PgViewBase\n};\n//# sourceMappingURL=view-base.js.map",
    "import { aliasedTable, aliasedTableColumn, mapColumnsInAliasedSQLToAlias, mapColumnsInSQLToAlias } from \"../alias.js\";\nimport { CasingCache } from \"../casing.js\";\nimport { Column } from \"../column.js\";\nimport { entityKind, is } from \"../entity.js\";\nimport { DrizzleError } from \"../errors.js\";\nimport {\n  PgColumn,\n  PgDate,\n  PgDateString,\n  PgJson,\n  PgJsonb,\n  PgNumeric,\n  PgTime,\n  PgTimestamp,\n  PgTimestampString,\n  PgUUID\n} from \"./columns/index.js\";\nimport { PgTable } from \"./table.js\";\nimport {\n  getOperators,\n  getOrderByOperators,\n  Many,\n  normalizeRelation,\n  One\n} from \"../relations.js\";\nimport { and, eq, View } from \"../sql/index.js\";\nimport {\n  Param,\n  SQL,\n  sql\n} from \"../sql/sql.js\";\nimport { Subquery } from \"../subquery.js\";\nimport { getTableName, getTableUniqueName, Table } from \"../table.js\";\nimport { orderSelectedFields } from \"../utils.js\";\nimport { ViewBaseConfig } from \"../view-common.js\";\nimport { PgViewBase } from \"./view-base.js\";\nclass PgDialect {\n  static [entityKind] = \"PgDialect\";\n  /** @internal */\n  casing;\n  constructor(config) {\n    this.casing = new CasingCache(config?.casing);\n  }\n  async migrate(migrations, session, config) {\n    const migrationsTable = typeof config === \"string\" ? \"__drizzle_migrations\" : config.migrationsTable ?? \"__drizzle_migrations\";\n    const migrationsSchema = typeof config === \"string\" ? \"drizzle\" : config.migrationsSchema ?? \"drizzle\";\n    const migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n    await session.execute(migrationTableCreate);\n    const dbMigrations = await session.all(\n      sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`\n    );\n    const lastDbMigration = dbMigrations[0];\n    await session.transaction(async (tx) => {\n      for await (const migration of migrations) {\n        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n          for (const stmt of migration.sql) {\n            await tx.execute(sql.raw(stmt));\n          }\n          await tx.execute(\n            sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`\n          );\n        }\n      }\n    });\n  }\n  escapeName(name) {\n    return `\"${name}\"`;\n  }\n  escapeParam(num) {\n    return `$${num + 1}`;\n  }\n  escapeString(str) {\n    return `'${str.replace(/'/g, \"''\")}'`;\n  }\n  buildWithCTE(queries) {\n    if (!queries?.length) return void 0;\n    const withSqlChunks = [sql`with `];\n    for (const [i, w] of queries.entries()) {\n      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);\n      if (i < queries.length - 1) {\n        withSqlChunks.push(sql`, `);\n      }\n    }\n    withSqlChunks.push(sql` `);\n    return sql.join(withSqlChunks);\n  }\n  buildDeleteQuery({ table, where, returning, withList }) {\n    const withSql = this.buildWithCTE(withList);\n    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;\n    const whereSql = where ? sql` where ${where}` : void 0;\n    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;\n  }\n  buildUpdateSet(table, set) {\n    const tableColumns = table[Table.Symbol.Columns];\n    const columnNames = Object.keys(tableColumns).filter(\n      (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0\n    );\n    const setSize = columnNames.length;\n    return sql.join(columnNames.flatMap((colName, i) => {\n      const col = tableColumns[colName];\n      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);\n      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;\n      if (i < setSize - 1) {\n        return [res, sql.raw(\", \")];\n      }\n      return [res];\n    }));\n  }\n  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {\n    const withSql = this.buildWithCTE(withList);\n    const tableName = table[PgTable.Symbol.Name];\n    const tableSchema = table[PgTable.Symbol.Schema];\n    const origTableName = table[PgTable.Symbol.OriginalName];\n    const alias = tableName === origTableName ? void 0 : tableName;\n    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;\n    const setSql = this.buildUpdateSet(table, set);\n    const fromSql = from && sql.join([sql.raw(\" from \"), this.buildFromTable(from)]);\n    const joinsSql = this.buildJoins(joins);\n    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : void 0;\n    const whereSql = where ? sql` where ${where}` : void 0;\n    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;\n  }\n  /**\n   * Builds selection SQL with provided fields/expressions\n   *\n   * Examples:\n   *\n   * `select <selection> from`\n   *\n   * `insert ... returning <selection>`\n   *\n   * If `isSingleTable` is true, then columns won't be prefixed with table name\n   */\n  buildSelection(fields, { isSingleTable = false } = {}) {\n    const columnsLen = fields.length;\n    const chunks = fields.flatMap(({ field }, i) => {\n      const chunk = [];\n      if (is(field, SQL.Aliased) && field.isSelectionField) {\n        chunk.push(sql.identifier(field.fieldAlias));\n      } else if (is(field, SQL.Aliased) || is(field, SQL)) {\n        const query = is(field, SQL.Aliased) ? field.sql : field;\n        if (isSingleTable) {\n          chunk.push(\n            new SQL(\n              query.queryChunks.map((c) => {\n                if (is(c, PgColumn)) {\n                  return sql.identifier(this.casing.getColumnCasing(c));\n                }\n                return c;\n              })\n            )\n          );\n        } else {\n          chunk.push(query);\n        }\n        if (is(field, SQL.Aliased)) {\n          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n        }\n      } else if (is(field, Column)) {\n        if (isSingleTable) {\n          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));\n        } else {\n          chunk.push(field);\n        }\n      }\n      if (i < columnsLen - 1) {\n        chunk.push(sql`, `);\n      }\n      return chunk;\n    });\n    return sql.join(chunks);\n  }\n  buildJoins(joins) {\n    if (!joins || joins.length === 0) {\n      return void 0;\n    }\n    const joinsArray = [];\n    for (const [index, joinMeta] of joins.entries()) {\n      if (index === 0) {\n        joinsArray.push(sql` `);\n      }\n      const table = joinMeta.table;\n      const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;\n      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : void 0;\n      if (is(table, PgTable)) {\n        const tableName = table[PgTable.Symbol.Name];\n        const tableSchema = table[PgTable.Symbol.Schema];\n        const origTableName = table[PgTable.Symbol.OriginalName];\n        const alias = tableName === origTableName ? void 0 : joinMeta.alias;\n        joinsArray.push(\n          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`\n        );\n      } else if (is(table, View)) {\n        const viewName = table[ViewBaseConfig].name;\n        const viewSchema = table[ViewBaseConfig].schema;\n        const origViewName = table[ViewBaseConfig].originalName;\n        const alias = viewName === origViewName ? void 0 : joinMeta.alias;\n        joinsArray.push(\n          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`\n        );\n      } else {\n        joinsArray.push(\n          sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`\n        );\n      }\n      if (index < joins.length - 1) {\n        joinsArray.push(sql` `);\n      }\n    }\n    return sql.join(joinsArray);\n  }\n  buildFromTable(table) {\n    if (is(table, Table) && table[Table.Symbol.IsAlias]) {\n      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;\n      if (table[Table.Symbol.Schema]) {\n        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;\n      }\n      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;\n    }\n    return table;\n  }\n  buildSelectQuery({\n    withList,\n    fields,\n    fieldsFlat,\n    where,\n    having,\n    table,\n    joins,\n    orderBy,\n    groupBy,\n    limit,\n    offset,\n    lockingClause,\n    distinct,\n    setOperators\n  }) {\n    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);\n    for (const f of fieldsList) {\n      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(\n        ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])\n      ))(f.field.table)) {\n        const tableName = getTableName(f.field.table);\n        throw new Error(\n          `Your \"${f.path.join(\"->\")}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`\n        );\n      }\n    }\n    const isSingleTable = !joins || joins.length === 0;\n    const withSql = this.buildWithCTE(withList);\n    let distinctSql;\n    if (distinct) {\n      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;\n    }\n    const selection = this.buildSelection(fieldsList, { isSingleTable });\n    const tableSql = this.buildFromTable(table);\n    const joinsSql = this.buildJoins(joins);\n    const whereSql = where ? sql` where ${where}` : void 0;\n    const havingSql = having ? sql` having ${having}` : void 0;\n    let orderBySql;\n    if (orderBy && orderBy.length > 0) {\n      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;\n    }\n    let groupBySql;\n    if (groupBy && groupBy.length > 0) {\n      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;\n    }\n    const limitSql = typeof limit === \"object\" || typeof limit === \"number\" && limit >= 0 ? sql` limit ${limit}` : void 0;\n    const offsetSql = offset ? sql` offset ${offset}` : void 0;\n    const lockingClauseSql = sql.empty();\n    if (lockingClause) {\n      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;\n      if (lockingClause.config.of) {\n        clauseSql.append(\n          sql` of ${sql.join(\n            Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],\n            sql`, `\n          )}`\n        );\n      }\n      if (lockingClause.config.noWait) {\n        clauseSql.append(sql` nowait`);\n      } else if (lockingClause.config.skipLocked) {\n        clauseSql.append(sql` skip locked`);\n      }\n      lockingClauseSql.append(clauseSql);\n    }\n    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;\n    if (setOperators.length > 0) {\n      return this.buildSetOperations(finalQuery, setOperators);\n    }\n    return finalQuery;\n  }\n  buildSetOperations(leftSelect, setOperators) {\n    const [setOperator, ...rest] = setOperators;\n    if (!setOperator) {\n      throw new Error(\"Cannot pass undefined values to any set operator\");\n    }\n    if (rest.length === 0) {\n      return this.buildSetOperationQuery({ leftSelect, setOperator });\n    }\n    return this.buildSetOperations(\n      this.buildSetOperationQuery({ leftSelect, setOperator }),\n      rest\n    );\n  }\n  buildSetOperationQuery({\n    leftSelect,\n    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }\n  }) {\n    const leftChunk = sql`(${leftSelect.getSQL()}) `;\n    const rightChunk = sql`(${rightSelect.getSQL()})`;\n    let orderBySql;\n    if (orderBy && orderBy.length > 0) {\n      const orderByValues = [];\n      for (const singleOrderBy of orderBy) {\n        if (is(singleOrderBy, PgColumn)) {\n          orderByValues.push(sql.identifier(singleOrderBy.name));\n        } else if (is(singleOrderBy, SQL)) {\n          for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {\n            const chunk = singleOrderBy.queryChunks[i];\n            if (is(chunk, PgColumn)) {\n              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);\n            }\n          }\n          orderByValues.push(sql`${singleOrderBy}`);\n        } else {\n          orderByValues.push(sql`${singleOrderBy}`);\n        }\n      }\n      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;\n    }\n    const limitSql = typeof limit === \"object\" || typeof limit === \"number\" && limit >= 0 ? sql` limit ${limit}` : void 0;\n    const operatorChunk = sql.raw(`${type} ${isAll ? \"all \" : \"\"}`);\n    const offsetSql = offset ? sql` offset ${offset}` : void 0;\n    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;\n  }\n  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {\n    const valuesSqlList = [];\n    const columns = table[Table.Symbol.Columns];\n    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());\n    const insertOrder = colEntries.map(\n      ([, column]) => sql.identifier(this.casing.getColumnCasing(column))\n    );\n    if (select) {\n      const select2 = valuesOrSelect;\n      if (is(select2, SQL)) {\n        valuesSqlList.push(select2);\n      } else {\n        valuesSqlList.push(select2.getSQL());\n      }\n    } else {\n      const values = valuesOrSelect;\n      valuesSqlList.push(sql.raw(\"values \"));\n      for (const [valueIndex, value] of values.entries()) {\n        const valueList = [];\n        for (const [fieldName, col] of colEntries) {\n          const colValue = value[fieldName];\n          if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {\n            if (col.defaultFn !== void 0) {\n              const defaultFnResult = col.defaultFn();\n              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n              valueList.push(defaultValue);\n            } else if (!col.default && col.onUpdateFn !== void 0) {\n              const onUpdateFnResult = col.onUpdateFn();\n              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);\n              valueList.push(newValue);\n            } else {\n              valueList.push(sql`default`);\n            }\n          } else {\n            valueList.push(colValue);\n          }\n        }\n        valuesSqlList.push(valueList);\n        if (valueIndex < values.length - 1) {\n          valuesSqlList.push(sql`, `);\n        }\n      }\n    }\n    const withSql = this.buildWithCTE(withList);\n    const valuesSql = sql.join(valuesSqlList);\n    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;\n    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;\n    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : void 0;\n    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;\n  }\n  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {\n    const concurrentlySql = concurrently ? sql` concurrently` : void 0;\n    const withNoDataSql = withNoData ? sql` with no data` : void 0;\n    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;\n  }\n  prepareTyping(encoder) {\n    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {\n      return \"json\";\n    } else if (is(encoder, PgNumeric)) {\n      return \"decimal\";\n    } else if (is(encoder, PgTime)) {\n      return \"time\";\n    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {\n      return \"timestamp\";\n    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {\n      return \"date\";\n    } else if (is(encoder, PgUUID)) {\n      return \"uuid\";\n    } else {\n      return \"none\";\n    }\n  }\n  sqlToQuery(sql2, invokeSource) {\n    return sql2.toQuery({\n      casing: this.casing,\n      escapeName: this.escapeName,\n      escapeParam: this.escapeParam,\n      escapeString: this.escapeString,\n      prepareTyping: this.prepareTyping,\n      invokeSource\n    });\n  }\n  // buildRelationalQueryWithPK({\n  // \tfullSchema,\n  // \tschema,\n  // \ttableNamesMap,\n  // \ttable,\n  // \ttableConfig,\n  // \tqueryConfig: config,\n  // \ttableAlias,\n  // \tisRoot = false,\n  // \tjoinOn,\n  // }: {\n  // \tfullSchema: Record<string, unknown>;\n  // \tschema: TablesRelationalConfig;\n  // \ttableNamesMap: Record<string, string>;\n  // \ttable: PgTable;\n  // \ttableConfig: TableRelationalConfig;\n  // \tqueryConfig: true | DBQueryConfig<'many', true>;\n  // \ttableAlias: string;\n  // \tisRoot?: boolean;\n  // \tjoinOn?: SQL;\n  // }): BuildRelationalQueryResult<PgTable, PgColumn> {\n  // \t// For { \"<relation>\": true }, return a table with selection of all columns\n  // \tif (config === true) {\n  // \t\tconst selectionEntries = Object.entries(tableConfig.columns);\n  // \t\tconst selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((\n  // \t\t\t[key, value],\n  // \t\t) => ({\n  // \t\t\tdbKey: value.name,\n  // \t\t\ttsKey: key,\n  // \t\t\tfield: value as PgColumn,\n  // \t\t\trelationTableTsKey: undefined,\n  // \t\t\tisJson: false,\n  // \t\t\tselection: [],\n  // \t\t}));\n  // \t\treturn {\n  // \t\t\ttableTsKey: tableConfig.tsName,\n  // \t\t\tsql: table,\n  // \t\t\tselection,\n  // \t\t};\n  // \t}\n  // \t// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n  // \t// let selectionForBuild = selection;\n  // \tconst aliasedColumns = Object.fromEntries(\n  // \t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n  // \t);\n  // \tconst aliasedRelations = Object.fromEntries(\n  // \t\tObject.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),\n  // \t);\n  // \tconst aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);\n  // \tlet where, hasUserDefinedWhere;\n  // \tif (config.where) {\n  // \t\tconst whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;\n  // \t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n  // \t\thasUserDefinedWhere = !!where;\n  // \t}\n  // \twhere = and(joinOn, where);\n  // \t// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];\n  // \tlet joins: Join[] = [];\n  // \tlet selectedColumns: string[] = [];\n  // \t// Figure out which columns to select\n  // \tif (config.columns) {\n  // \t\tlet isIncludeMode = false;\n  // \t\tfor (const [field, value] of Object.entries(config.columns)) {\n  // \t\t\tif (value === undefined) {\n  // \t\t\t\tcontinue;\n  // \t\t\t}\n  // \t\t\tif (field in tableConfig.columns) {\n  // \t\t\t\tif (!isIncludeMode && value === true) {\n  // \t\t\t\t\tisIncludeMode = true;\n  // \t\t\t\t}\n  // \t\t\t\tselectedColumns.push(field);\n  // \t\t\t}\n  // \t\t}\n  // \t\tif (selectedColumns.length > 0) {\n  // \t\t\tselectedColumns = isIncludeMode\n  // \t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n  // \t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n  // \t\t}\n  // \t} else {\n  // \t\t// Select all columns if selection is not specified\n  // \t\tselectedColumns = Object.keys(tableConfig.columns);\n  // \t}\n  // \t// for (const field of selectedColumns) {\n  // \t// \tconst column = tableConfig.columns[field]! as PgColumn;\n  // \t// \tfieldsSelection.push({ tsKey: field, value: column });\n  // \t// }\n  // \tlet initiallySelectedRelations: {\n  // \t\ttsKey: string;\n  // \t\tqueryConfig: true | DBQueryConfig<'many', false>;\n  // \t\trelation: Relation;\n  // \t}[] = [];\n  // \t// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n  // \t// Figure out which relations to select\n  // \tif (config.with) {\n  // \t\tinitiallySelectedRelations = Object.entries(config.with)\n  // \t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n  // \t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n  // \t}\n  // \tconst manyRelations = initiallySelectedRelations.filter((r) =>\n  // \t\tis(r.relation, Many)\n  // \t\t&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0\n  // \t);\n  // \t// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level\n  // \tconst isInnermostQuery = manyRelations.length < 2;\n  // \tconst selectedExtras: {\n  // \t\ttsKey: string;\n  // \t\tvalue: SQL.Aliased;\n  // \t}[] = [];\n  // \t// Figure out which extras to select\n  // \tif (isInnermostQuery && config.extras) {\n  // \t\tconst extras = typeof config.extras === 'function'\n  // \t\t\t? config.extras(aliasedFields, { sql })\n  // \t\t\t: config.extras;\n  // \t\tfor (const [tsKey, value] of Object.entries(extras)) {\n  // \t\t\tselectedExtras.push({\n  // \t\t\t\ttsKey,\n  // \t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n  // \t\t\t});\n  // \t\t}\n  // \t}\n  // \t// Transform `fieldsSelection` into `selection`\n  // \t// `fieldsSelection` shouldn't be used after this point\n  // \t// for (const { tsKey, value, isExtra } of fieldsSelection) {\n  // \t// \tselection.push({\n  // \t// \t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n  // \t// \t\ttsKey,\n  // \t// \t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n  // \t// \t\trelationTableTsKey: undefined,\n  // \t// \t\tisJson: false,\n  // \t// \t\tisExtra,\n  // \t// \t\tselection: [],\n  // \t// \t});\n  // \t// }\n  // \tlet orderByOrig = typeof config.orderBy === 'function'\n  // \t\t? config.orderBy(aliasedFields, orderByOperators)\n  // \t\t: config.orderBy ?? [];\n  // \tif (!Array.isArray(orderByOrig)) {\n  // \t\torderByOrig = [orderByOrig];\n  // \t}\n  // \tconst orderBy = orderByOrig.map((orderByValue) => {\n  // \t\tif (is(orderByValue, Column)) {\n  // \t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as PgColumn;\n  // \t\t}\n  // \t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n  // \t});\n  // \tconst limit = isInnermostQuery ? config.limit : undefined;\n  // \tconst offset = isInnermostQuery ? config.offset : undefined;\n  // \t// For non-root queries without additional config except columns, return a table with selection\n  // \tif (\n  // \t\t!isRoot\n  // \t\t&& initiallySelectedRelations.length === 0\n  // \t\t&& selectedExtras.length === 0\n  // \t\t&& !where\n  // \t\t&& orderBy.length === 0\n  // \t\t&& limit === undefined\n  // \t\t&& offset === undefined\n  // \t) {\n  // \t\treturn {\n  // \t\t\ttableTsKey: tableConfig.tsName,\n  // \t\t\tsql: table,\n  // \t\t\tselection: selectedColumns.map((key) => ({\n  // \t\t\t\tdbKey: tableConfig.columns[key]!.name,\n  // \t\t\t\ttsKey: key,\n  // \t\t\t\tfield: tableConfig.columns[key] as PgColumn,\n  // \t\t\t\trelationTableTsKey: undefined,\n  // \t\t\t\tisJson: false,\n  // \t\t\t\tselection: [],\n  // \t\t\t})),\n  // \t\t};\n  // \t}\n  // \tconst selectedRelationsWithoutPK:\n  // \t// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level\n  // \tfor (\n  // \t\tconst {\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tqueryConfig: selectedRelationConfigValue,\n  // \t\t\trelation,\n  // \t\t} of initiallySelectedRelations\n  // \t) {\n  // \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n  // \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n  // \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n  // \t\tconst relationTable = schema[relationTableTsName]!;\n  // \t\tif (relationTable.primaryKey.length > 0) {\n  // \t\t\tcontinue;\n  // \t\t}\n  // \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n  // \t\tconst joinOn = and(\n  // \t\t\t...normalizedRelation.fields.map((field, i) =>\n  // \t\t\t\teq(\n  // \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n  // \t\t\t\t\taliasedTableColumn(field, tableAlias),\n  // \t\t\t\t)\n  // \t\t\t),\n  // \t\t);\n  // \t\tconst builtRelation = this.buildRelationalQueryWithoutPK({\n  // \t\t\tfullSchema,\n  // \t\t\tschema,\n  // \t\t\ttableNamesMap,\n  // \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n  // \t\t\ttableConfig: schema[relationTableTsName]!,\n  // \t\t\tqueryConfig: selectedRelationConfigValue,\n  // \t\t\ttableAlias: relationTableAlias,\n  // \t\t\tjoinOn,\n  // \t\t\tnestedQueryRelation: relation,\n  // \t\t});\n  // \t\tconst field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);\n  // \t\tjoins.push({\n  // \t\t\ton: sql`true`,\n  // \t\t\ttable: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),\n  // \t\t\talias: relationTableAlias,\n  // \t\t\tjoinType: 'left',\n  // \t\t\tlateral: true,\n  // \t\t});\n  // \t\tselectedRelations.push({\n  // \t\t\tdbKey: selectedRelationTsKey,\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tfield,\n  // \t\t\trelationTableTsKey: relationTableTsName,\n  // \t\t\tisJson: true,\n  // \t\t\tselection: builtRelation.selection,\n  // \t\t});\n  // \t}\n  // \tconst oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>\n  // \t\tis(r.relation, One)\n  // \t);\n  // \t// Process all One relations with PKs, because they can all be joined on the same level\n  // \tfor (\n  // \t\tconst {\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tqueryConfig: selectedRelationConfigValue,\n  // \t\t\trelation,\n  // \t\t} of oneRelations\n  // \t) {\n  // \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n  // \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n  // \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n  // \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n  // \t\tconst relationTable = schema[relationTableTsName]!;\n  // \t\tif (relationTable.primaryKey.length === 0) {\n  // \t\t\tcontinue;\n  // \t\t}\n  // \t\tconst joinOn = and(\n  // \t\t\t...normalizedRelation.fields.map((field, i) =>\n  // \t\t\t\teq(\n  // \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n  // \t\t\t\t\taliasedTableColumn(field, tableAlias),\n  // \t\t\t\t)\n  // \t\t\t),\n  // \t\t);\n  // \t\tconst builtRelation = this.buildRelationalQueryWithPK({\n  // \t\t\tfullSchema,\n  // \t\t\tschema,\n  // \t\t\ttableNamesMap,\n  // \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n  // \t\t\ttableConfig: schema[relationTableTsName]!,\n  // \t\t\tqueryConfig: selectedRelationConfigValue,\n  // \t\t\ttableAlias: relationTableAlias,\n  // \t\t\tjoinOn,\n  // \t\t});\n  // \t\tconst field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${\n  // \t\t\tsql.join(\n  // \t\t\t\tbuiltRelation.selection.map(({ field }) =>\n  // \t\t\t\t\tis(field, SQL.Aliased)\n  // \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n  // \t\t\t\t\t\t: is(field, Column)\n  // \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n  // \t\t\t\t\t\t: field\n  // \t\t\t\t),\n  // \t\t\t\tsql`, `,\n  // \t\t\t)\n  // \t\t}) end`.as(selectedRelationTsKey);\n  // \t\tconst isLateralJoin = is(builtRelation.sql, SQL);\n  // \t\tjoins.push({\n  // \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n  // \t\t\ttable: is(builtRelation.sql, SQL)\n  // \t\t\t\t? new Subquery(builtRelation.sql, {}, relationTableAlias)\n  // \t\t\t\t: aliasedTable(builtRelation.sql, relationTableAlias),\n  // \t\t\talias: relationTableAlias,\n  // \t\t\tjoinType: 'left',\n  // \t\t\tlateral: is(builtRelation.sql, SQL),\n  // \t\t});\n  // \t\tselectedRelations.push({\n  // \t\t\tdbKey: selectedRelationTsKey,\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tfield,\n  // \t\t\trelationTableTsKey: relationTableTsName,\n  // \t\t\tisJson: true,\n  // \t\t\tselection: builtRelation.selection,\n  // \t\t});\n  // \t}\n  // \tlet distinct: PgSelectConfig['distinct'];\n  // \tlet tableFrom: PgTable | Subquery = table;\n  // \t// Process first Many relation - each one requires a nested subquery\n  // \tconst manyRelation = manyRelations[0];\n  // \tif (manyRelation) {\n  // \t\tconst {\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tqueryConfig: selectedRelationQueryConfig,\n  // \t\t\trelation,\n  // \t\t} = manyRelation;\n  // \t\tdistinct = {\n  // \t\t\ton: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),\n  // \t\t};\n  // \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n  // \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n  // \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n  // \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n  // \t\tconst joinOn = and(\n  // \t\t\t...normalizedRelation.fields.map((field, i) =>\n  // \t\t\t\teq(\n  // \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n  // \t\t\t\t\taliasedTableColumn(field, tableAlias),\n  // \t\t\t\t)\n  // \t\t\t),\n  // \t\t);\n  // \t\tconst builtRelationJoin = this.buildRelationalQueryWithPK({\n  // \t\t\tfullSchema,\n  // \t\t\tschema,\n  // \t\t\ttableNamesMap,\n  // \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n  // \t\t\ttableConfig: schema[relationTableTsName]!,\n  // \t\t\tqueryConfig: selectedRelationQueryConfig,\n  // \t\t\ttableAlias: relationTableAlias,\n  // \t\t\tjoinOn,\n  // \t\t});\n  // \t\tconst builtRelationSelectionField = sql`case when ${\n  // \t\t\tsql.identifier(relationTableAlias)\n  // \t\t} is null then '[]' else json_agg(json_build_array(${\n  // \t\t\tsql.join(\n  // \t\t\t\tbuiltRelationJoin.selection.map(({ field }) =>\n  // \t\t\t\t\tis(field, SQL.Aliased)\n  // \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n  // \t\t\t\t\t\t: is(field, Column)\n  // \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n  // \t\t\t\t\t\t: field\n  // \t\t\t\t),\n  // \t\t\t\tsql`, `,\n  // \t\t\t)\n  // \t\t})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);\n  // \t\tconst isLateralJoin = is(builtRelationJoin.sql, SQL);\n  // \t\tjoins.push({\n  // \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n  // \t\t\ttable: isLateralJoin\n  // \t\t\t\t? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)\n  // \t\t\t\t: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),\n  // \t\t\talias: relationTableAlias,\n  // \t\t\tjoinType: 'left',\n  // \t\t\tlateral: isLateralJoin,\n  // \t\t});\n  // \t\t// Build the \"from\" subquery with the remaining Many relations\n  // \t\tconst builtTableFrom = this.buildRelationalQueryWithPK({\n  // \t\t\tfullSchema,\n  // \t\t\tschema,\n  // \t\t\ttableNamesMap,\n  // \t\t\ttable,\n  // \t\t\ttableConfig,\n  // \t\t\tqueryConfig: {\n  // \t\t\t\t...config,\n  // \t\t\t\twhere: undefined,\n  // \t\t\t\torderBy: undefined,\n  // \t\t\t\tlimit: undefined,\n  // \t\t\t\toffset: undefined,\n  // \t\t\t\twith: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(\n  // \t\t\t\t\t(result, { tsKey, queryConfig: configValue }) => {\n  // \t\t\t\t\t\tresult[tsKey] = configValue;\n  // \t\t\t\t\t\treturn result;\n  // \t\t\t\t\t},\n  // \t\t\t\t\t{},\n  // \t\t\t\t),\n  // \t\t\t},\n  // \t\t\ttableAlias,\n  // \t\t});\n  // \t\tselectedRelations.push({\n  // \t\t\tdbKey: selectedRelationTsKey,\n  // \t\t\ttsKey: selectedRelationTsKey,\n  // \t\t\tfield: builtRelationSelectionField,\n  // \t\t\trelationTableTsKey: relationTableTsName,\n  // \t\t\tisJson: true,\n  // \t\t\tselection: builtRelationJoin.selection,\n  // \t\t});\n  // \t\t// selection = builtTableFrom.selection.map((item) =>\n  // \t\t// \tis(item.field, SQL.Aliased)\n  // \t\t// \t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n  // \t\t// \t\t: item\n  // \t\t// );\n  // \t\t// selectionForBuild = [{\n  // \t\t// \tdbKey: '*',\n  // \t\t// \ttsKey: '*',\n  // \t\t// \tfield: sql`${sql.identifier(tableAlias)}.*`,\n  // \t\t// \tselection: [],\n  // \t\t// \tisJson: false,\n  // \t\t// \trelationTableTsKey: undefined,\n  // \t\t// }];\n  // \t\t// const newSelectionItem: (typeof selection)[number] = {\n  // \t\t// \tdbKey: selectedRelationTsKey,\n  // \t\t// \ttsKey: selectedRelationTsKey,\n  // \t\t// \tfield,\n  // \t\t// \trelationTableTsKey: relationTableTsName,\n  // \t\t// \tisJson: true,\n  // \t\t// \tselection: builtRelationJoin.selection,\n  // \t\t// };\n  // \t\t// selection.push(newSelectionItem);\n  // \t\t// selectionForBuild.push(newSelectionItem);\n  // \t\ttableFrom = is(builtTableFrom.sql, PgTable)\n  // \t\t\t? builtTableFrom.sql\n  // \t\t\t: new Subquery(builtTableFrom.sql, {}, tableAlias);\n  // \t}\n  // \tif (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {\n  // \t\tthrow new DrizzleError(`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")`);\n  // \t}\n  // \tlet selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];\n  // \tfunction prepareSelectedColumns() {\n  // \t\treturn selectedColumns.map((key) => ({\n  // \t\t\tdbKey: tableConfig.columns[key]!.name,\n  // \t\t\ttsKey: key,\n  // \t\t\tfield: tableConfig.columns[key] as PgColumn,\n  // \t\t\trelationTableTsKey: undefined,\n  // \t\t\tisJson: false,\n  // \t\t\tselection: [],\n  // \t\t}));\n  // \t}\n  // \tfunction prepareSelectedExtras() {\n  // \t\treturn selectedExtras.map((item) => ({\n  // \t\t\tdbKey: item.value.fieldAlias,\n  // \t\t\ttsKey: item.tsKey,\n  // \t\t\tfield: item.value,\n  // \t\t\trelationTableTsKey: undefined,\n  // \t\t\tisJson: false,\n  // \t\t\tselection: [],\n  // \t\t}));\n  // \t}\n  // \tif (isRoot) {\n  // \t\tselection = [\n  // \t\t\t...prepareSelectedColumns(),\n  // \t\t\t...prepareSelectedExtras(),\n  // \t\t];\n  // \t}\n  // \tif (hasUserDefinedWhere || orderBy.length > 0) {\n  // \t\ttableFrom = new Subquery(\n  // \t\t\tthis.buildSelectQuery({\n  // \t\t\t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n  // \t\t\t\tfields: {},\n  // \t\t\t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n  // \t\t\t\t\tpath: [],\n  // \t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n  // \t\t\t\t})),\n  // \t\t\t\tjoins,\n  // \t\t\t\tdistinct,\n  // \t\t\t}),\n  // \t\t\t{},\n  // \t\t\ttableAlias,\n  // \t\t);\n  // \t\tselectionForBuild = selection.map((item) =>\n  // \t\t\tis(item.field, SQL.Aliased)\n  // \t\t\t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n  // \t\t\t\t: item\n  // \t\t);\n  // \t\tjoins = [];\n  // \t\tdistinct = undefined;\n  // \t}\n  // \tconst result = this.buildSelectQuery({\n  // \t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n  // \t\tfields: {},\n  // \t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n  // \t\t\tpath: [],\n  // \t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n  // \t\t})),\n  // \t\twhere,\n  // \t\tlimit,\n  // \t\toffset,\n  // \t\tjoins,\n  // \t\torderBy,\n  // \t\tdistinct,\n  // \t});\n  // \treturn {\n  // \t\ttableTsKey: tableConfig.tsName,\n  // \t\tsql: result,\n  // \t\tselection,\n  // \t};\n  // }\n  buildRelationalQueryWithoutPK({\n    fullSchema,\n    schema,\n    tableNamesMap,\n    table,\n    tableConfig,\n    queryConfig: config,\n    tableAlias,\n    nestedQueryRelation,\n    joinOn\n  }) {\n    let selection = [];\n    let limit, offset, orderBy = [], where;\n    const joins = [];\n    if (config === true) {\n      const selectionEntries = Object.entries(tableConfig.columns);\n      selection = selectionEntries.map(([key, value]) => ({\n        dbKey: value.name,\n        tsKey: key,\n        field: aliasedTableColumn(value, tableAlias),\n        relationTableTsKey: void 0,\n        isJson: false,\n        selection: []\n      }));\n    } else {\n      const aliasedColumns = Object.fromEntries(\n        Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])\n      );\n      if (config.where) {\n        const whereSql = typeof config.where === \"function\" ? config.where(aliasedColumns, getOperators()) : config.where;\n        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n      }\n      const fieldsSelection = [];\n      let selectedColumns = [];\n      if (config.columns) {\n        let isIncludeMode = false;\n        for (const [field, value] of Object.entries(config.columns)) {\n          if (value === void 0) {\n            continue;\n          }\n          if (field in tableConfig.columns) {\n            if (!isIncludeMode && value === true) {\n              isIncludeMode = true;\n            }\n            selectedColumns.push(field);\n          }\n        }\n        if (selectedColumns.length > 0) {\n          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n        }\n      } else {\n        selectedColumns = Object.keys(tableConfig.columns);\n      }\n      for (const field of selectedColumns) {\n        const column = tableConfig.columns[field];\n        fieldsSelection.push({ tsKey: field, value: column });\n      }\n      let selectedRelations = [];\n      if (config.with) {\n        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));\n      }\n      let extras;\n      if (config.extras) {\n        extras = typeof config.extras === \"function\" ? config.extras(aliasedColumns, { sql }) : config.extras;\n        for (const [tsKey, value] of Object.entries(extras)) {\n          fieldsSelection.push({\n            tsKey,\n            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)\n          });\n        }\n      }\n      for (const { tsKey, value } of fieldsSelection) {\n        selection.push({\n          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,\n          tsKey,\n          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n          relationTableTsKey: void 0,\n          isJson: false,\n          selection: []\n        });\n      }\n      let orderByOrig = typeof config.orderBy === \"function\" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];\n      if (!Array.isArray(orderByOrig)) {\n        orderByOrig = [orderByOrig];\n      }\n      orderBy = orderByOrig.map((orderByValue) => {\n        if (is(orderByValue, Column)) {\n          return aliasedTableColumn(orderByValue, tableAlias);\n        }\n        return mapColumnsInSQLToAlias(orderByValue, tableAlias);\n      });\n      limit = config.limit;\n      offset = config.offset;\n      for (const {\n        tsKey: selectedRelationTsKey,\n        queryConfig: selectedRelationConfigValue,\n        relation\n      } of selectedRelations) {\n        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n        const relationTableName = getTableUniqueName(relation.referencedTable);\n        const relationTableTsName = tableNamesMap[relationTableName];\n        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n        const joinOn2 = and(\n          ...normalizedRelation.fields.map(\n            (field2, i) => eq(\n              aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),\n              aliasedTableColumn(field2, tableAlias)\n            )\n          )\n        );\n        const builtRelation = this.buildRelationalQueryWithoutPK({\n          fullSchema,\n          schema,\n          tableNamesMap,\n          table: fullSchema[relationTableTsName],\n          tableConfig: schema[relationTableTsName],\n          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,\n          tableAlias: relationTableAlias,\n          joinOn: joinOn2,\n          nestedQueryRelation: relation\n        });\n        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier(\"data\")}`.as(selectedRelationTsKey);\n        joins.push({\n          on: sql`true`,\n          table: new Subquery(builtRelation.sql, {}, relationTableAlias),\n          alias: relationTableAlias,\n          joinType: \"left\",\n          lateral: true\n        });\n        selection.push({\n          dbKey: selectedRelationTsKey,\n          tsKey: selectedRelationTsKey,\n          field,\n          relationTableTsKey: relationTableTsName,\n          isJson: true,\n          selection: builtRelation.selection\n        });\n      }\n    }\n    if (selection.length === 0) {\n      throw new DrizzleError({ message: `No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")` });\n    }\n    let result;\n    where = and(joinOn, where);\n    if (nestedQueryRelation) {\n      let field = sql`json_build_array(${sql.join(\n        selection.map(\n          ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier(\"data\")}` : is(field2, SQL.Aliased) ? field2.sql : field2\n        ),\n        sql`, `\n      )})`;\n      if (is(nestedQueryRelation, Many)) {\n        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;\n      }\n      const nestedSelection = [{\n        dbKey: \"data\",\n        tsKey: \"data\",\n        field: field.as(\"data\"),\n        isJson: true,\n        relationTableTsKey: tableConfig.tsName,\n        selection\n      }];\n      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;\n      if (needsSubquery) {\n        result = this.buildSelectQuery({\n          table: aliasedTable(table, tableAlias),\n          fields: {},\n          fieldsFlat: [{\n            path: [],\n            field: sql.raw(\"*\")\n          }],\n          where,\n          limit,\n          offset,\n          orderBy,\n          setOperators: []\n        });\n        where = void 0;\n        limit = void 0;\n        offset = void 0;\n        orderBy = [];\n      } else {\n        result = aliasedTable(table, tableAlias);\n      }\n      result = this.buildSelectQuery({\n        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),\n        fields: {},\n        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({\n          path: [],\n          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2\n        })),\n        joins,\n        where,\n        limit,\n        offset,\n        orderBy,\n        setOperators: []\n      });\n    } else {\n      result = this.buildSelectQuery({\n        table: aliasedTable(table, tableAlias),\n        fields: {},\n        fieldsFlat: selection.map(({ field }) => ({\n          path: [],\n          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field\n        })),\n        joins,\n        where,\n        limit,\n        offset,\n        orderBy,\n        setOperators: []\n      });\n    }\n    return {\n      tableTsKey: tableConfig.tsName,\n      sql: result,\n      selection\n    };\n  }\n}\nexport {\n  PgDialect\n};\n//# sourceMappingURL=dialect.js.map",
    "import { entityKind } from \"../entity.js\";\nclass TypedQueryBuilder {\n  static [entityKind] = \"TypedQueryBuilder\";\n  /** @internal */\n  getSelectedFields() {\n    return this._.selectedFields;\n  }\n}\nexport {\n  TypedQueryBuilder\n};\n//# sourceMappingURL=query-builder.js.map",
    "import { entityKind, is } from \"../../entity.js\";\nimport { PgViewBase } from \"../view-base.js\";\nimport { TypedQueryBuilder } from \"../../query-builders/query-builder.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { SQL, View } from \"../../sql/sql.js\";\nimport { Subquery } from \"../../subquery.js\";\nimport { Table } from \"../../table.js\";\nimport { tracer } from \"../../tracing.js\";\nimport {\n  applyMixins,\n  getTableColumns,\n  getTableLikeName,\n  haveSameKeys\n} from \"../../utils.js\";\nimport { orderSelectedFields } from \"../../utils.js\";\nimport { ViewBaseConfig } from \"../../view-common.js\";\nimport { extractUsedTable } from \"../utils.js\";\nclass PgSelectBuilder {\n  static [entityKind] = \"PgSelectBuilder\";\n  fields;\n  session;\n  dialect;\n  withList = [];\n  distinct;\n  constructor(config) {\n    this.fields = config.fields;\n    this.session = config.session;\n    this.dialect = config.dialect;\n    if (config.withList) {\n      this.withList = config.withList;\n    }\n    this.distinct = config.distinct;\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  /**\n   * Specify the table, subquery, or other target that you're\n   * building a select query against.\n   *\n   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}\n   */\n  from(source) {\n    const isPartialSelect = !!this.fields;\n    const src = source;\n    let fields;\n    if (this.fields) {\n      fields = this.fields;\n    } else if (is(src, Subquery)) {\n      fields = Object.fromEntries(\n        Object.keys(src._.selectedFields).map((key) => [key, src[key]])\n      );\n    } else if (is(src, PgViewBase)) {\n      fields = src[ViewBaseConfig].selectedFields;\n    } else if (is(src, SQL)) {\n      fields = {};\n    } else {\n      fields = getTableColumns(src);\n    }\n    return new PgSelectBase({\n      table: src,\n      fields,\n      isPartialSelect,\n      session: this.session,\n      dialect: this.dialect,\n      withList: this.withList,\n      distinct: this.distinct\n    }).setToken(this.authToken);\n  }\n}\nclass PgSelectQueryBuilderBase extends TypedQueryBuilder {\n  static [entityKind] = \"PgSelectQueryBuilder\";\n  _;\n  config;\n  joinsNotNullableMap;\n  tableName;\n  isPartialSelect;\n  session;\n  dialect;\n  cacheConfig = void 0;\n  usedTables = /* @__PURE__ */ new Set();\n  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {\n    super();\n    this.config = {\n      withList,\n      table,\n      fields: { ...fields },\n      distinct,\n      setOperators: []\n    };\n    this.isPartialSelect = isPartialSelect;\n    this.session = session;\n    this.dialect = dialect;\n    this._ = {\n      selectedFields: fields,\n      config: this.config\n    };\n    this.tableName = getTableLikeName(table);\n    this.joinsNotNullableMap = typeof this.tableName === \"string\" ? { [this.tableName]: true } : {};\n    for (const item of extractUsedTable(table)) this.usedTables.add(item);\n  }\n  /** @internal */\n  getUsedTables() {\n    return [...this.usedTables];\n  }\n  createJoin(joinType, lateral) {\n    return (table, on) => {\n      const baseTableName = this.tableName;\n      const tableName = getTableLikeName(table);\n      for (const item of extractUsedTable(table)) this.usedTables.add(item);\n      if (typeof tableName === \"string\" && this.config.joins?.some((join) => join.alias === tableName)) {\n        throw new Error(`Alias \"${tableName}\" is already used in this query`);\n      }\n      if (!this.isPartialSelect) {\n        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === \"string\") {\n          this.config.fields = {\n            [baseTableName]: this.config.fields\n          };\n        }\n        if (typeof tableName === \"string\" && !is(table, SQL)) {\n          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];\n          this.config.fields[tableName] = selection;\n        }\n      }\n      if (typeof on === \"function\") {\n        on = on(\n          new Proxy(\n            this.config.fields,\n            new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n          )\n        );\n      }\n      if (!this.config.joins) {\n        this.config.joins = [];\n      }\n      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });\n      if (typeof tableName === \"string\") {\n        switch (joinType) {\n          case \"left\": {\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n          case \"right\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"cross\":\n          case \"inner\": {\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"full\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n        }\n      }\n      return this;\n    };\n  }\n  /**\n   * Executes a `left join` operation by adding another table to the current query.\n   *\n   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n   *\n   * @param table the table to join.\n   * @param on the `on` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all users and their pets\n   * const usersWithPets: { user: User; pets: Pet | null; }[] = await db.select()\n   *   .from(users)\n   *   .leftJoin(pets, eq(users.id, pets.ownerId))\n   *\n   * // Select userId and petId\n   * const usersIdsAndPetIds: { userId: number; petId: number | null; }[] = await db.select({\n   *   userId: users.id,\n   *   petId: pets.id,\n   * })\n   *   .from(users)\n   *   .leftJoin(pets, eq(users.id, pets.ownerId))\n   * ```\n   */\n  leftJoin = this.createJoin(\"left\", false);\n  /**\n   * Executes a `left join lateral` operation by adding subquery to the current query.\n   *\n   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n   *\n   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join-lateral}\n   *\n   * @param table the subquery to join.\n   * @param on the `on` clause.\n   */\n  leftJoinLateral = this.createJoin(\"left\", true);\n  /**\n   * Executes a `right join` operation by adding another table to the current query.\n   *\n   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n   *\n   * @param table the table to join.\n   * @param on the `on` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all users and their pets\n   * const usersWithPets: { user: User | null; pets: Pet; }[] = await db.select()\n   *   .from(users)\n   *   .rightJoin(pets, eq(users.id, pets.ownerId))\n   *\n   * // Select userId and petId\n   * const usersIdsAndPetIds: { userId: number | null; petId: number; }[] = await db.select({\n   *   userId: users.id,\n   *   petId: pets.id,\n   * })\n   *   .from(users)\n   *   .rightJoin(pets, eq(users.id, pets.ownerId))\n   * ```\n   */\n  rightJoin = this.createJoin(\"right\", false);\n  /**\n   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n   *\n   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n   *\n   * @param table the table to join.\n   * @param on the `on` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all users and their pets\n   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()\n   *   .from(users)\n   *   .innerJoin(pets, eq(users.id, pets.ownerId))\n   *\n   * // Select userId and petId\n   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({\n   *   userId: users.id,\n   *   petId: pets.id,\n   * })\n   *   .from(users)\n   *   .innerJoin(pets, eq(users.id, pets.ownerId))\n   * ```\n   */\n  innerJoin = this.createJoin(\"inner\", false);\n  /**\n   * Executes an `inner join lateral` operation, creating a new table by combining rows from two queries that have matching values.\n   *\n   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n   *\n   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join-lateral}\n   *\n   * @param table the subquery to join.\n   * @param on the `on` clause.\n   */\n  innerJoinLateral = this.createJoin(\"inner\", true);\n  /**\n   * Executes a `full join` operation by combining rows from two tables into a new table.\n   *\n   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n   *\n   * @param table the table to join.\n   * @param on the `on` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all users and their pets\n   * const usersWithPets: { user: User | null; pets: Pet | null; }[] = await db.select()\n   *   .from(users)\n   *   .fullJoin(pets, eq(users.id, pets.ownerId))\n   *\n   * // Select userId and petId\n   * const usersIdsAndPetIds: { userId: number | null; petId: number | null; }[] = await db.select({\n   *   userId: users.id,\n   *   petId: pets.id,\n   * })\n   *   .from(users)\n   *   .fullJoin(pets, eq(users.id, pets.ownerId))\n   * ```\n   */\n  fullJoin = this.createJoin(\"full\", false);\n  /**\n   * Executes a `cross join` operation by combining rows from two tables into a new table.\n   *\n   * Calling this method retrieves all rows from both main and joined tables, merging all rows from each table.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join}\n   *\n   * @param table the table to join.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all users, each user with every pet\n   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()\n   *   .from(users)\n   *   .crossJoin(pets)\n   *\n   * // Select userId and petId\n   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({\n   *   userId: users.id,\n   *   petId: pets.id,\n   * })\n   *   .from(users)\n   *   .crossJoin(pets)\n   * ```\n   */\n  crossJoin = this.createJoin(\"cross\", false);\n  /**\n   * Executes a `cross join lateral` operation by combining rows from two queries into a new table.\n   *\n   * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n   *\n   * Calling this method retrieves all rows from both main and joined queries, merging all rows from each query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join-lateral}\n   *\n   * @param table the query to join.\n   */\n  crossJoinLateral = this.createJoin(\"cross\", true);\n  createSetOperator(type, isAll) {\n    return (rightSelection) => {\n      const rightSelect = typeof rightSelection === \"function\" ? rightSelection(getPgSetOperators()) : rightSelection;\n      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n        throw new Error(\n          \"Set operator error (union / intersect / except): selected fields are not the same or are in a different order\"\n        );\n      }\n      this.config.setOperators.push({ type, isAll, rightSelect });\n      return this;\n    };\n  }\n  /**\n   * Adds `union` set operator to the query.\n   *\n   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all unique names from customers and users tables\n   * await db.select({ name: users.name })\n   *   .from(users)\n   *   .union(\n   *     db.select({ name: customers.name }).from(customers)\n   *   );\n   * // or\n   * import { union } from 'drizzle-orm/pg-core'\n   *\n   * await union(\n   *   db.select({ name: users.name }).from(users),\n   *   db.select({ name: customers.name }).from(customers)\n   * );\n   * ```\n   */\n  union = this.createSetOperator(\"union\", false);\n  /**\n   * Adds `union all` set operator to the query.\n   *\n   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all transaction ids from both online and in-store sales\n   * await db.select({ transaction: onlineSales.transactionId })\n   *   .from(onlineSales)\n   *   .unionAll(\n   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n   *   );\n   * // or\n   * import { unionAll } from 'drizzle-orm/pg-core'\n   *\n   * await unionAll(\n   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n   * );\n   * ```\n   */\n  unionAll = this.createSetOperator(\"union\", true);\n  /**\n   * Adds `intersect` set operator to the query.\n   *\n   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select course names that are offered in both departments A and B\n   * await db.select({ courseName: depA.courseName })\n   *   .from(depA)\n   *   .intersect(\n   *     db.select({ courseName: depB.courseName }).from(depB)\n   *   );\n   * // or\n   * import { intersect } from 'drizzle-orm/pg-core'\n   *\n   * await intersect(\n   *   db.select({ courseName: depA.courseName }).from(depA),\n   *   db.select({ courseName: depB.courseName }).from(depB)\n   * );\n   * ```\n   */\n  intersect = this.createSetOperator(\"intersect\", false);\n  /**\n   * Adds `intersect all` set operator to the query.\n   *\n   * Calling this method will retain only the rows that are present in both result sets including all duplicates.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all products and quantities that are ordered by both regular and VIP customers\n   * await db.select({\n   *   productId: regularCustomerOrders.productId,\n   *   quantityOrdered: regularCustomerOrders.quantityOrdered\n   * })\n   * .from(regularCustomerOrders)\n   * .intersectAll(\n   *   db.select({\n   *     productId: vipCustomerOrders.productId,\n   *     quantityOrdered: vipCustomerOrders.quantityOrdered\n   *   })\n   *   .from(vipCustomerOrders)\n   * );\n   * // or\n   * import { intersectAll } from 'drizzle-orm/pg-core'\n   *\n   * await intersectAll(\n   *   db.select({\n   *     productId: regularCustomerOrders.productId,\n   *     quantityOrdered: regularCustomerOrders.quantityOrdered\n   *   })\n   *   .from(regularCustomerOrders),\n   *   db.select({\n   *     productId: vipCustomerOrders.productId,\n   *     quantityOrdered: vipCustomerOrders.quantityOrdered\n   *   })\n   *   .from(vipCustomerOrders)\n   * );\n   * ```\n   */\n  intersectAll = this.createSetOperator(\"intersect\", true);\n  /**\n   * Adds `except` set operator to the query.\n   *\n   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all courses offered in department A but not in department B\n   * await db.select({ courseName: depA.courseName })\n   *   .from(depA)\n   *   .except(\n   *     db.select({ courseName: depB.courseName }).from(depB)\n   *   );\n   * // or\n   * import { except } from 'drizzle-orm/pg-core'\n   *\n   * await except(\n   *   db.select({ courseName: depA.courseName }).from(depA),\n   *   db.select({ courseName: depB.courseName }).from(depB)\n   * );\n   * ```\n   */\n  except = this.createSetOperator(\"except\", false);\n  /**\n   * Adds `except all` set operator to the query.\n   *\n   * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all products that are ordered by regular customers but not by VIP customers\n   * await db.select({\n   *   productId: regularCustomerOrders.productId,\n   *   quantityOrdered: regularCustomerOrders.quantityOrdered,\n   * })\n   * .from(regularCustomerOrders)\n   * .exceptAll(\n   *   db.select({\n   *     productId: vipCustomerOrders.productId,\n   *     quantityOrdered: vipCustomerOrders.quantityOrdered,\n   *   })\n   *   .from(vipCustomerOrders)\n   * );\n   * // or\n   * import { exceptAll } from 'drizzle-orm/pg-core'\n   *\n   * await exceptAll(\n   *   db.select({\n   *     productId: regularCustomerOrders.productId,\n   *     quantityOrdered: regularCustomerOrders.quantityOrdered\n   *   })\n   *   .from(regularCustomerOrders),\n   *   db.select({\n   *     productId: vipCustomerOrders.productId,\n   *     quantityOrdered: vipCustomerOrders.quantityOrdered\n   *   })\n   *   .from(vipCustomerOrders)\n   * );\n   * ```\n   */\n  exceptAll = this.createSetOperator(\"except\", true);\n  /** @internal */\n  addSetOperators(setOperators) {\n    this.config.setOperators.push(...setOperators);\n    return this;\n  }\n  /**\n   * Adds a `where` clause to the query.\n   *\n   * Calling this method will select only those rows that fulfill a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n   *\n   * @param where the `where` clause.\n   *\n   * @example\n   * You can use conditional operators and `sql function` to filter the rows to be selected.\n   *\n   * ```ts\n   * // Select all cars with green color\n   * await db.select().from(cars).where(eq(cars.color, 'green'));\n   * // or\n   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n   * ```\n   *\n   * You can logically combine conditional operators with `and()` and `or()` operators:\n   *\n   * ```ts\n   * // Select all BMW cars with a green color\n   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n   *\n   * // Select all cars with the green or blue color\n   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n   * ```\n   */\n  where(where) {\n    if (typeof where === \"function\") {\n      where = where(\n        new Proxy(\n          this.config.fields,\n          new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n        )\n      );\n    }\n    this.config.where = where;\n    return this;\n  }\n  /**\n   * Adds a `having` clause to the query.\n   *\n   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n   *\n   * @param having the `having` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Select all brands with more than one car\n   * await db.select({\n   * \tbrand: cars.brand,\n   * \tcount: sql<number>`cast(count(${cars.id}) as int)`,\n   * })\n   *   .from(cars)\n   *   .groupBy(cars.brand)\n   *   .having(({ count }) => gt(count, 1));\n   * ```\n   */\n  having(having) {\n    if (typeof having === \"function\") {\n      having = having(\n        new Proxy(\n          this.config.fields,\n          new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n        )\n      );\n    }\n    this.config.having = having;\n    return this;\n  }\n  groupBy(...columns) {\n    if (typeof columns[0] === \"function\") {\n      const groupBy = columns[0](\n        new Proxy(\n          this.config.fields,\n          new SelectionProxyHandler({ sqlAliasedBehavior: \"alias\", sqlBehavior: \"sql\" })\n        )\n      );\n      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n    } else {\n      this.config.groupBy = columns;\n    }\n    return this;\n  }\n  orderBy(...columns) {\n    if (typeof columns[0] === \"function\") {\n      const orderBy = columns[0](\n        new Proxy(\n          this.config.fields,\n          new SelectionProxyHandler({ sqlAliasedBehavior: \"alias\", sqlBehavior: \"sql\" })\n        )\n      );\n      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n      if (this.config.setOperators.length > 0) {\n        this.config.setOperators.at(-1).orderBy = orderByArray;\n      } else {\n        this.config.orderBy = orderByArray;\n      }\n    } else {\n      const orderByArray = columns;\n      if (this.config.setOperators.length > 0) {\n        this.config.setOperators.at(-1).orderBy = orderByArray;\n      } else {\n        this.config.orderBy = orderByArray;\n      }\n    }\n    return this;\n  }\n  /**\n   * Adds a `limit` clause to the query.\n   *\n   * Calling this method will set the maximum number of rows that will be returned by this query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n   *\n   * @param limit the `limit` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Get the first 10 people from this query.\n   * await db.select().from(people).limit(10);\n   * ```\n   */\n  limit(limit) {\n    if (this.config.setOperators.length > 0) {\n      this.config.setOperators.at(-1).limit = limit;\n    } else {\n      this.config.limit = limit;\n    }\n    return this;\n  }\n  /**\n   * Adds an `offset` clause to the query.\n   *\n   * Calling this method will skip a number of rows when returning results from this query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n   *\n   * @param offset the `offset` clause.\n   *\n   * @example\n   *\n   * ```ts\n   * // Get the 10th-20th people from this query.\n   * await db.select().from(people).offset(10).limit(10);\n   * ```\n   */\n  offset(offset) {\n    if (this.config.setOperators.length > 0) {\n      this.config.setOperators.at(-1).offset = offset;\n    } else {\n      this.config.offset = offset;\n    }\n    return this;\n  }\n  /**\n   * Adds a `for` clause to the query.\n   *\n   * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.\n   *\n   * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}\n   *\n   * @param strength the lock strength.\n   * @param config the lock configuration.\n   */\n  for(strength, config = {}) {\n    this.config.lockingClause = { strength, config };\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildSelectQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  as(alias) {\n    const usedTables = [];\n    usedTables.push(...extractUsedTable(this.config.table));\n    if (this.config.joins) {\n      for (const it of this.config.joins) usedTables.push(...extractUsedTable(it.table));\n    }\n    return new Proxy(\n      new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]),\n      new SelectionProxyHandler({ alias, sqlAliasedBehavior: \"alias\", sqlBehavior: \"error\" })\n    );\n  }\n  /** @internal */\n  getSelectedFields() {\n    return new Proxy(\n      this.config.fields,\n      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: \"alias\", sqlBehavior: \"error\" })\n    );\n  }\n  $dynamic() {\n    return this;\n  }\n  $withCache(config) {\n    this.cacheConfig = config === void 0 ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };\n    return this;\n  }\n}\nclass PgSelectBase extends PgSelectQueryBuilderBase {\n  static [entityKind] = \"PgSelect\";\n  /** @internal */\n  _prepare(name) {\n    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;\n    if (!session) {\n      throw new Error(\"Cannot execute a query on a query builder. Please use a database instance instead.\");\n    }\n    const { fields } = config;\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      const fieldsList = orderSelectedFields(fields);\n      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, void 0, {\n        type: \"select\",\n        tables: [...usedTables]\n      }, cacheConfig);\n      query.joinsNotNullableMap = joinsNotNullableMap;\n      return query.setToken(authToken);\n    });\n  }\n  /**\n   * Create a prepared statement for this query. This allows\n   * the database to remember this query for the given session\n   * and call it by name, rather than specifying the full query.\n   *\n   * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}\n   */\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n}\napplyMixins(PgSelectBase, [QueryPromise]);\nfunction createSetOperator(type, isAll) {\n  return (leftSelect, rightSelect, ...restSelects) => {\n    const setOperators = [rightSelect, ...restSelects].map((select) => ({\n      type,\n      isAll,\n      rightSelect: select\n    }));\n    for (const setOperator of setOperators) {\n      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n        throw new Error(\n          \"Set operator error (union / intersect / except): selected fields are not the same or are in a different order\"\n        );\n      }\n    }\n    return leftSelect.addSetOperators(setOperators);\n  };\n}\nconst getPgSetOperators = () => ({\n  union,\n  unionAll,\n  intersect,\n  intersectAll,\n  except,\n  exceptAll\n});\nconst union = createSetOperator(\"union\", false);\nconst unionAll = createSetOperator(\"union\", true);\nconst intersect = createSetOperator(\"intersect\", false);\nconst intersectAll = createSetOperator(\"intersect\", true);\nconst except = createSetOperator(\"except\", false);\nconst exceptAll = createSetOperator(\"except\", true);\nexport {\n  PgSelectBase,\n  PgSelectBuilder,\n  PgSelectQueryBuilderBase,\n  except,\n  exceptAll,\n  intersect,\n  intersectAll,\n  union,\n  unionAll\n};\n//# sourceMappingURL=select.js.map",
    "import { entityKind, is } from \"../../entity.js\";\nimport { PgDialect } from \"../dialect.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { WithSubquery } from \"../../subquery.js\";\nimport { PgSelectBuilder } from \"./select.js\";\nclass QueryBuilder {\n  static [entityKind] = \"PgQueryBuilder\";\n  dialect;\n  dialectConfig;\n  constructor(dialect) {\n    this.dialect = is(dialect, PgDialect) ? dialect : void 0;\n    this.dialectConfig = is(dialect, PgDialect) ? void 0 : dialect;\n  }\n  $with = (alias, selection) => {\n    const queryBuilder = this;\n    const as = (qb) => {\n      if (typeof qb === \"function\") {\n        qb = qb(queryBuilder);\n      }\n      return new Proxy(\n        new WithSubquery(\n          qb.getSQL(),\n          selection ?? (\"getSelectedFields\" in qb ? qb.getSelectedFields() ?? {} : {}),\n          alias,\n          true\n        ),\n        new SelectionProxyHandler({ alias, sqlAliasedBehavior: \"alias\", sqlBehavior: \"error\" })\n      );\n    };\n    return { as };\n  };\n  with(...queries) {\n    const self = this;\n    function select(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: void 0,\n        dialect: self.getDialect(),\n        withList: queries\n      });\n    }\n    function selectDistinct(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: void 0,\n        dialect: self.getDialect(),\n        distinct: true\n      });\n    }\n    function selectDistinctOn(on, fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: void 0,\n        dialect: self.getDialect(),\n        distinct: { on }\n      });\n    }\n    return { select, selectDistinct, selectDistinctOn };\n  }\n  select(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: void 0,\n      dialect: this.getDialect()\n    });\n  }\n  selectDistinct(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: void 0,\n      dialect: this.getDialect(),\n      distinct: true\n    });\n  }\n  selectDistinctOn(on, fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: void 0,\n      dialect: this.getDialect(),\n      distinct: { on }\n    });\n  }\n  // Lazy load dialect to avoid circular dependency\n  getDialect() {\n    if (!this.dialect) {\n      this.dialect = new PgDialect(this.dialectConfig);\n    }\n    return this.dialect;\n  }\n}\nexport {\n  QueryBuilder\n};\n//# sourceMappingURL=query-builder.js.map",
    "import { entityKind, is } from \"../entity.js\";\nimport { SelectionProxyHandler } from \"../selection-proxy.js\";\nimport { getTableColumns } from \"../utils.js\";\nimport { QueryBuilder } from \"./query-builders/query-builder.js\";\nimport { pgTable } from \"./table.js\";\nimport { PgViewBase } from \"./view-base.js\";\nimport { PgViewConfig } from \"./view-common.js\";\nclass DefaultViewBuilderCore {\n  constructor(name, schema) {\n    this.name = name;\n    this.schema = schema;\n  }\n  static [entityKind] = \"PgDefaultViewBuilderCore\";\n  config = {};\n  with(config) {\n    this.config.with = config;\n    return this;\n  }\n}\nclass ViewBuilder extends DefaultViewBuilderCore {\n  static [entityKind] = \"PgViewBuilder\";\n  as(qb) {\n    if (typeof qb === \"function\") {\n      qb = qb(new QueryBuilder());\n    }\n    const selectionProxy = new SelectionProxyHandler({\n      alias: this.name,\n      sqlBehavior: \"error\",\n      sqlAliasedBehavior: \"alias\",\n      replaceOriginalName: true\n    });\n    const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);\n    return new Proxy(\n      new PgView({\n        pgConfig: this.config,\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: aliasedSelection,\n          query: qb.getSQL().inlineParams()\n        }\n      }),\n      selectionProxy\n    );\n  }\n}\nclass ManualViewBuilder extends DefaultViewBuilderCore {\n  static [entityKind] = \"PgManualViewBuilder\";\n  columns;\n  constructor(name, columns, schema) {\n    super(name, schema);\n    this.columns = getTableColumns(pgTable(name, columns));\n  }\n  existing() {\n    return new Proxy(\n      new PgView({\n        pgConfig: void 0,\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: this.columns,\n          query: void 0\n        }\n      }),\n      new SelectionProxyHandler({\n        alias: this.name,\n        sqlBehavior: \"error\",\n        sqlAliasedBehavior: \"alias\",\n        replaceOriginalName: true\n      })\n    );\n  }\n  as(query) {\n    return new Proxy(\n      new PgView({\n        pgConfig: this.config,\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: this.columns,\n          query: query.inlineParams()\n        }\n      }),\n      new SelectionProxyHandler({\n        alias: this.name,\n        sqlBehavior: \"error\",\n        sqlAliasedBehavior: \"alias\",\n        replaceOriginalName: true\n      })\n    );\n  }\n}\nclass MaterializedViewBuilderCore {\n  constructor(name, schema) {\n    this.name = name;\n    this.schema = schema;\n  }\n  static [entityKind] = \"PgMaterializedViewBuilderCore\";\n  config = {};\n  using(using) {\n    this.config.using = using;\n    return this;\n  }\n  with(config) {\n    this.config.with = config;\n    return this;\n  }\n  tablespace(tablespace) {\n    this.config.tablespace = tablespace;\n    return this;\n  }\n  withNoData() {\n    this.config.withNoData = true;\n    return this;\n  }\n}\nclass MaterializedViewBuilder extends MaterializedViewBuilderCore {\n  static [entityKind] = \"PgMaterializedViewBuilder\";\n  as(qb) {\n    if (typeof qb === \"function\") {\n      qb = qb(new QueryBuilder());\n    }\n    const selectionProxy = new SelectionProxyHandler({\n      alias: this.name,\n      sqlBehavior: \"error\",\n      sqlAliasedBehavior: \"alias\",\n      replaceOriginalName: true\n    });\n    const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);\n    return new Proxy(\n      new PgMaterializedView({\n        pgConfig: {\n          with: this.config.with,\n          using: this.config.using,\n          tablespace: this.config.tablespace,\n          withNoData: this.config.withNoData\n        },\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: aliasedSelection,\n          query: qb.getSQL().inlineParams()\n        }\n      }),\n      selectionProxy\n    );\n  }\n}\nclass ManualMaterializedViewBuilder extends MaterializedViewBuilderCore {\n  static [entityKind] = \"PgManualMaterializedViewBuilder\";\n  columns;\n  constructor(name, columns, schema) {\n    super(name, schema);\n    this.columns = getTableColumns(pgTable(name, columns));\n  }\n  existing() {\n    return new Proxy(\n      new PgMaterializedView({\n        pgConfig: {\n          tablespace: this.config.tablespace,\n          using: this.config.using,\n          with: this.config.with,\n          withNoData: this.config.withNoData\n        },\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: this.columns,\n          query: void 0\n        }\n      }),\n      new SelectionProxyHandler({\n        alias: this.name,\n        sqlBehavior: \"error\",\n        sqlAliasedBehavior: \"alias\",\n        replaceOriginalName: true\n      })\n    );\n  }\n  as(query) {\n    return new Proxy(\n      new PgMaterializedView({\n        pgConfig: {\n          tablespace: this.config.tablespace,\n          using: this.config.using,\n          with: this.config.with,\n          withNoData: this.config.withNoData\n        },\n        config: {\n          name: this.name,\n          schema: this.schema,\n          selectedFields: this.columns,\n          query: query.inlineParams()\n        }\n      }),\n      new SelectionProxyHandler({\n        alias: this.name,\n        sqlBehavior: \"error\",\n        sqlAliasedBehavior: \"alias\",\n        replaceOriginalName: true\n      })\n    );\n  }\n}\nclass PgView extends PgViewBase {\n  static [entityKind] = \"PgView\";\n  [PgViewConfig];\n  constructor({ pgConfig, config }) {\n    super(config);\n    if (pgConfig) {\n      this[PgViewConfig] = {\n        with: pgConfig.with\n      };\n    }\n  }\n}\nconst PgMaterializedViewConfig = Symbol.for(\"drizzle:PgMaterializedViewConfig\");\nclass PgMaterializedView extends PgViewBase {\n  static [entityKind] = \"PgMaterializedView\";\n  [PgMaterializedViewConfig];\n  constructor({ pgConfig, config }) {\n    super(config);\n    this[PgMaterializedViewConfig] = {\n      with: pgConfig?.with,\n      using: pgConfig?.using,\n      tablespace: pgConfig?.tablespace,\n      withNoData: pgConfig?.withNoData\n    };\n  }\n}\nfunction pgViewWithSchema(name, selection, schema) {\n  if (selection) {\n    return new ManualViewBuilder(name, selection, schema);\n  }\n  return new ViewBuilder(name, schema);\n}\nfunction pgMaterializedViewWithSchema(name, selection, schema) {\n  if (selection) {\n    return new ManualMaterializedViewBuilder(name, selection, schema);\n  }\n  return new MaterializedViewBuilder(name, schema);\n}\nfunction pgView(name, columns) {\n  return pgViewWithSchema(name, columns, void 0);\n}\nfunction pgMaterializedView(name, columns) {\n  return pgMaterializedViewWithSchema(name, columns, void 0);\n}\nfunction isPgView(obj) {\n  return is(obj, PgView);\n}\nfunction isPgMaterializedView(obj) {\n  return is(obj, PgMaterializedView);\n}\nexport {\n  DefaultViewBuilderCore,\n  ManualMaterializedViewBuilder,\n  ManualViewBuilder,\n  MaterializedViewBuilder,\n  MaterializedViewBuilderCore,\n  PgMaterializedView,\n  PgMaterializedViewConfig,\n  PgView,\n  ViewBuilder,\n  isPgMaterializedView,\n  isPgView,\n  pgMaterializedView,\n  pgMaterializedViewWithSchema,\n  pgView,\n  pgViewWithSchema\n};\n//# sourceMappingURL=view.js.map",
    "import { is } from \"../entity.js\";\nimport { PgTable } from \"./table.js\";\nimport { SQL } from \"../sql/sql.js\";\nimport { Subquery } from \"../subquery.js\";\nimport { Schema, Table } from \"../table.js\";\nimport { ViewBaseConfig } from \"../view-common.js\";\nimport { CheckBuilder } from \"./checks.js\";\nimport { ForeignKeyBuilder } from \"./foreign-keys.js\";\nimport { IndexBuilder } from \"./indexes.js\";\nimport { PgPolicy } from \"./policies.js\";\nimport { PrimaryKeyBuilder } from \"./primary-keys.js\";\nimport { UniqueConstraintBuilder } from \"./unique-constraint.js\";\nimport { PgViewConfig } from \"./view-common.js\";\nimport { PgMaterializedViewConfig } from \"./view.js\";\nfunction getTableConfig(table) {\n  const columns = Object.values(table[Table.Symbol.Columns]);\n  const indexes = [];\n  const checks = [];\n  const primaryKeys = [];\n  const foreignKeys = Object.values(table[PgTable.Symbol.InlineForeignKeys]);\n  const uniqueConstraints = [];\n  const name = table[Table.Symbol.Name];\n  const schema = table[Table.Symbol.Schema];\n  const policies = [];\n  const enableRLS = table[PgTable.Symbol.EnableRLS];\n  const extraConfigBuilder = table[PgTable.Symbol.ExtraConfigBuilder];\n  if (extraConfigBuilder !== void 0) {\n    const extraConfig = extraConfigBuilder(table[Table.Symbol.ExtraConfigColumns]);\n    const extraValues = Array.isArray(extraConfig) ? extraConfig.flat(1) : Object.values(extraConfig);\n    for (const builder of extraValues) {\n      if (is(builder, IndexBuilder)) {\n        indexes.push(builder.build(table));\n      } else if (is(builder, CheckBuilder)) {\n        checks.push(builder.build(table));\n      } else if (is(builder, UniqueConstraintBuilder)) {\n        uniqueConstraints.push(builder.build(table));\n      } else if (is(builder, PrimaryKeyBuilder)) {\n        primaryKeys.push(builder.build(table));\n      } else if (is(builder, ForeignKeyBuilder)) {\n        foreignKeys.push(builder.build(table));\n      } else if (is(builder, PgPolicy)) {\n        policies.push(builder);\n      }\n    }\n  }\n  return {\n    columns,\n    indexes,\n    foreignKeys,\n    checks,\n    primaryKeys,\n    uniqueConstraints,\n    name,\n    schema,\n    policies,\n    enableRLS\n  };\n}\nfunction extractUsedTable(table) {\n  if (is(table, PgTable)) {\n    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];\n  }\n  if (is(table, Subquery)) {\n    return table._.usedTables ?? [];\n  }\n  if (is(table, SQL)) {\n    return table.usedTables ?? [];\n  }\n  return [];\n}\nfunction getViewConfig(view) {\n  return {\n    ...view[ViewBaseConfig],\n    ...view[PgViewConfig]\n  };\n}\nfunction getMaterializedViewConfig(view) {\n  return {\n    ...view[ViewBaseConfig],\n    ...view[PgMaterializedViewConfig]\n  };\n}\nexport {\n  extractUsedTable,\n  getMaterializedViewConfig,\n  getTableConfig,\n  getViewConfig\n};\n//# sourceMappingURL=utils.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { getTableName, Table } from \"../../table.js\";\nimport { tracer } from \"../../tracing.js\";\nimport { orderSelectedFields } from \"../../utils.js\";\nimport { extractUsedTable } from \"../utils.js\";\nclass PgDeleteBase extends QueryPromise {\n  constructor(table, session, dialect, withList) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { table, withList };\n  }\n  static [entityKind] = \"PgDelete\";\n  config;\n  cacheConfig;\n  /**\n   * Adds a `where` clause to the query.\n   *\n   * Calling this method will delete only those rows that fulfill a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/delete}\n   *\n   * @param where the `where` clause.\n   *\n   * @example\n   * You can use conditional operators and `sql function` to filter the rows to be deleted.\n   *\n   * ```ts\n   * // Delete all cars with green color\n   * await db.delete(cars).where(eq(cars.color, 'green'));\n   * // or\n   * await db.delete(cars).where(sql`${cars.color} = 'green'`)\n   * ```\n   *\n   * You can logically combine conditional operators with `and()` and `or()` operators:\n   *\n   * ```ts\n   * // Delete all BMW cars with a green color\n   * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n   *\n   * // Delete all cars with the green or blue color\n   * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n   * ```\n   */\n  where(where) {\n    this.config.where = where;\n    return this;\n  }\n  returning(fields = this.config.table[Table.Symbol.Columns]) {\n    this.config.returningFields = fields;\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildDeleteQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {\n        type: \"delete\",\n        tables: extractUsedTable(this.config.table)\n      }, this.cacheConfig);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n  /** @internal */\n  getSelectedFields() {\n    return this.config.returningFields ? new Proxy(\n      this.config.returningFields,\n      new SelectionProxyHandler({\n        alias: getTableName(this.config.table),\n        sqlAliasedBehavior: \"alias\",\n        sqlBehavior: \"error\"\n      })\n    ) : void 0;\n  }\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgDeleteBase\n};\n//# sourceMappingURL=delete.js.map",
    "import { entityKind, is } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { Param, SQL, sql } from \"../../sql/sql.js\";\nimport { Columns, getTableName, Table } from \"../../table.js\";\nimport { tracer } from \"../../tracing.js\";\nimport { haveSameKeys, mapUpdateSet, orderSelectedFields } from \"../../utils.js\";\nimport { extractUsedTable } from \"../utils.js\";\nimport { QueryBuilder } from \"./query-builder.js\";\nclass PgInsertBuilder {\n  constructor(table, session, dialect, withList, overridingSystemValue_) {\n    this.table = table;\n    this.session = session;\n    this.dialect = dialect;\n    this.withList = withList;\n    this.overridingSystemValue_ = overridingSystemValue_;\n  }\n  static [entityKind] = \"PgInsertBuilder\";\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  overridingSystemValue() {\n    this.overridingSystemValue_ = true;\n    return this;\n  }\n  values(values) {\n    values = Array.isArray(values) ? values : [values];\n    if (values.length === 0) {\n      throw new Error(\"values() must be called with at least one value\");\n    }\n    const mappedValues = values.map((entry) => {\n      const result = {};\n      const cols = this.table[Table.Symbol.Columns];\n      for (const colKey of Object.keys(entry)) {\n        const colValue = entry[colKey];\n        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n      }\n      return result;\n    });\n    return new PgInsertBase(\n      this.table,\n      mappedValues,\n      this.session,\n      this.dialect,\n      this.withList,\n      false,\n      this.overridingSystemValue_\n    ).setToken(this.authToken);\n  }\n  select(selectQuery) {\n    const select = typeof selectQuery === \"function\" ? selectQuery(new QueryBuilder()) : selectQuery;\n    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {\n      throw new Error(\n        \"Insert select error: selected fields are not the same or are in a different order compared to the table definition\"\n      );\n    }\n    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);\n  }\n}\nclass PgInsertBase extends QueryPromise {\n  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { table, values, withList, select, overridingSystemValue_ };\n  }\n  static [entityKind] = \"PgInsert\";\n  config;\n  cacheConfig;\n  returning(fields = this.config.table[Table.Symbol.Columns]) {\n    this.config.returningFields = fields;\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /**\n   * Adds an `on conflict do nothing` clause to the query.\n   *\n   * Calling this method simply avoids inserting a row as its alternative action.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}\n   *\n   * @param config The `target` and `where` clauses.\n   *\n   * @example\n   * ```ts\n   * // Insert one row and cancel the insert if there's a conflict\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoNothing();\n   *\n   * // Explicitly specify conflict target\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoNothing({ target: cars.id });\n   * ```\n   */\n  onConflictDoNothing(config = {}) {\n    if (config.target === void 0) {\n      this.config.onConflict = sql`do nothing`;\n    } else {\n      let targetColumn = \"\";\n      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(\",\") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n      const whereSql = config.where ? sql` where ${config.where}` : void 0;\n      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;\n    }\n    return this;\n  }\n  /**\n   * Adds an `on conflict do update` clause to the query.\n   *\n   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}\n   *\n   * @param config The `target`, `set` and `where` clauses.\n   *\n   * @example\n   * ```ts\n   * // Update the row if there's a conflict\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoUpdate({\n   *     target: cars.id,\n   *     set: { brand: 'Porsche' }\n   *   });\n   *\n   * // Upsert with 'where' clause\n   * await db.insert(cars)\n   *   .values({ id: 1, brand: 'BMW' })\n   *   .onConflictDoUpdate({\n   *     target: cars.id,\n   *     set: { brand: 'newBMW' },\n   *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,\n   *   });\n   * ```\n   */\n  onConflictDoUpdate(config) {\n    if (config.where && (config.targetWhere || config.setWhere)) {\n      throw new Error(\n        'You cannot use both \"where\" and \"targetWhere\"/\"setWhere\" at the same time - \"where\" is deprecated, use \"targetWhere\" or \"setWhere\" instead.'\n      );\n    }\n    const whereSql = config.where ? sql` where ${config.where}` : void 0;\n    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : void 0;\n    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : void 0;\n    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));\n    let targetColumn = \"\";\n    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(\",\") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildInsertQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {\n        type: \"insert\",\n        tables: extractUsedTable(this.config.table)\n      }, this.cacheConfig);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n  /** @internal */\n  getSelectedFields() {\n    return this.config.returningFields ? new Proxy(\n      this.config.returningFields,\n      new SelectionProxyHandler({\n        alias: getTableName(this.config.table),\n        sqlAliasedBehavior: \"alias\",\n        sqlBehavior: \"error\"\n      })\n    ) : void 0;\n  }\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgInsertBase,\n  PgInsertBuilder\n};\n//# sourceMappingURL=insert.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { tracer } from \"../../tracing.js\";\nclass PgRefreshMaterializedView extends QueryPromise {\n  constructor(view, session, dialect) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { view };\n  }\n  static [entityKind] = \"PgRefreshMaterializedView\";\n  config;\n  concurrently() {\n    if (this.config.withNoData !== void 0) {\n      throw new Error(\"Cannot use concurrently and withNoData together\");\n    }\n    this.config.concurrently = true;\n    return this;\n  }\n  withNoData() {\n    if (this.config.concurrently !== void 0) {\n      throw new Error(\"Cannot use concurrently and withNoData together\");\n    }\n    this.config.withNoData = true;\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildRefreshMaterializedViewQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(placeholderValues, this.authToken);\n    });\n  };\n}\nexport {\n  PgRefreshMaterializedView\n};\n//# sourceMappingURL=refresh-materialized-view.js.map",
    "import { entityKind, is } from \"../../entity.js\";\nimport { PgTable } from \"../table.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport { SelectionProxyHandler } from \"../../selection-proxy.js\";\nimport { SQL } from \"../../sql/sql.js\";\nimport { Subquery } from \"../../subquery.js\";\nimport { getTableName, Table } from \"../../table.js\";\nimport {\n  getTableLikeName,\n  mapUpdateSet,\n  orderSelectedFields\n} from \"../../utils.js\";\nimport { ViewBaseConfig } from \"../../view-common.js\";\nimport { extractUsedTable } from \"../utils.js\";\nclass PgUpdateBuilder {\n  constructor(table, session, dialect, withList) {\n    this.table = table;\n    this.session = session;\n    this.dialect = dialect;\n    this.withList = withList;\n  }\n  static [entityKind] = \"PgUpdateBuilder\";\n  authToken;\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  set(values) {\n    return new PgUpdateBase(\n      this.table,\n      mapUpdateSet(this.table, values),\n      this.session,\n      this.dialect,\n      this.withList\n    ).setToken(this.authToken);\n  }\n}\nclass PgUpdateBase extends QueryPromise {\n  constructor(table, set, session, dialect, withList) {\n    super();\n    this.session = session;\n    this.dialect = dialect;\n    this.config = { set, table, withList, joins: [] };\n    this.tableName = getTableLikeName(table);\n    this.joinsNotNullableMap = typeof this.tableName === \"string\" ? { [this.tableName]: true } : {};\n  }\n  static [entityKind] = \"PgUpdate\";\n  config;\n  tableName;\n  joinsNotNullableMap;\n  cacheConfig;\n  from(source) {\n    const src = source;\n    const tableName = getTableLikeName(src);\n    if (typeof tableName === \"string\") {\n      this.joinsNotNullableMap[tableName] = true;\n    }\n    this.config.from = src;\n    return this;\n  }\n  getTableLikeFields(table) {\n    if (is(table, PgTable)) {\n      return table[Table.Symbol.Columns];\n    } else if (is(table, Subquery)) {\n      return table._.selectedFields;\n    }\n    return table[ViewBaseConfig].selectedFields;\n  }\n  createJoin(joinType) {\n    return (table, on) => {\n      const tableName = getTableLikeName(table);\n      if (typeof tableName === \"string\" && this.config.joins.some((join) => join.alias === tableName)) {\n        throw new Error(`Alias \"${tableName}\" is already used in this query`);\n      }\n      if (typeof on === \"function\") {\n        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : void 0;\n        on = on(\n          new Proxy(\n            this.config.table[Table.Symbol.Columns],\n            new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n          ),\n          from && new Proxy(\n            from,\n            new SelectionProxyHandler({ sqlAliasedBehavior: \"sql\", sqlBehavior: \"sql\" })\n          )\n        );\n      }\n      this.config.joins.push({ on, table, joinType, alias: tableName });\n      if (typeof tableName === \"string\") {\n        switch (joinType) {\n          case \"left\": {\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n          case \"right\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"inner\": {\n            this.joinsNotNullableMap[tableName] = true;\n            break;\n          }\n          case \"full\": {\n            this.joinsNotNullableMap = Object.fromEntries(\n              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])\n            );\n            this.joinsNotNullableMap[tableName] = false;\n            break;\n          }\n        }\n      }\n      return this;\n    };\n  }\n  leftJoin = this.createJoin(\"left\");\n  rightJoin = this.createJoin(\"right\");\n  innerJoin = this.createJoin(\"inner\");\n  fullJoin = this.createJoin(\"full\");\n  /**\n   * Adds a 'where' clause to the query.\n   *\n   * Calling this method will update only those rows that fulfill a specified condition.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/update}\n   *\n   * @param where the 'where' clause.\n   *\n   * @example\n   * You can use conditional operators and `sql function` to filter the rows to be updated.\n   *\n   * ```ts\n   * // Update all cars with green color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(eq(cars.color, 'green'));\n   * // or\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(sql`${cars.color} = 'green'`)\n   * ```\n   *\n   * You can logically combine conditional operators with `and()` and `or()` operators:\n   *\n   * ```ts\n   * // Update all BMW cars with a green color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n   *\n   * // Update all cars with the green or blue color\n   * await db.update(cars).set({ color: 'red' })\n   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n   * ```\n   */\n  where(where) {\n    this.config.where = where;\n    return this;\n  }\n  returning(fields) {\n    if (!fields) {\n      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);\n      if (this.config.from) {\n        const tableName = getTableLikeName(this.config.from);\n        if (typeof tableName === \"string\" && this.config.from && !is(this.config.from, SQL)) {\n          const fromFields = this.getTableLikeFields(this.config.from);\n          fields[tableName] = fromFields;\n        }\n        for (const join of this.config.joins) {\n          const tableName2 = getTableLikeName(join.table);\n          if (typeof tableName2 === \"string\" && !is(join.table, SQL)) {\n            const fromFields = this.getTableLikeFields(join.table);\n            fields[tableName2] = fromFields;\n          }\n        }\n      }\n    }\n    this.config.returningFields = fields;\n    this.config.returning = orderSelectedFields(fields);\n    return this;\n  }\n  /** @internal */\n  getSQL() {\n    return this.dialect.buildUpdateQuery(this.config);\n  }\n  toSQL() {\n    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n    return rest;\n  }\n  /** @internal */\n  _prepare(name) {\n    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, void 0, {\n      type: \"insert\",\n      tables: extractUsedTable(this.config.table)\n    }, this.cacheConfig);\n    query.joinsNotNullableMap = this.joinsNotNullableMap;\n    return query;\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute = (placeholderValues) => {\n    return this._prepare().execute(placeholderValues, this.authToken);\n  };\n  /** @internal */\n  getSelectedFields() {\n    return this.config.returningFields ? new Proxy(\n      this.config.returningFields,\n      new SelectionProxyHandler({\n        alias: getTableName(this.config.table),\n        sqlAliasedBehavior: \"alias\",\n        sqlBehavior: \"error\"\n      })\n    ) : void 0;\n  }\n  $dynamic() {\n    return this;\n  }\n}\nexport {\n  PgUpdateBase,\n  PgUpdateBuilder\n};\n//# sourceMappingURL=update.js.map",
    "export * from \"./delete.js\";\nexport * from \"./insert.js\";\nexport * from \"./query-builder.js\";\nexport * from \"./refresh-materialized-view.js\";\nexport * from \"./select.js\";\nexport * from \"./select.types.js\";\nexport * from \"./update.js\";\n//# sourceMappingURL=index.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { SQL, sql } from \"../../sql/sql.js\";\nclass PgCountBuilder extends SQL {\n  constructor(params) {\n    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);\n    this.params = params;\n    this.mapWith(Number);\n    this.session = params.session;\n    this.sql = PgCountBuilder.buildCount(\n      params.source,\n      params.filters\n    );\n  }\n  sql;\n  token;\n  static [entityKind] = \"PgCountBuilder\";\n  [Symbol.toStringTag] = \"PgCountBuilder\";\n  session;\n  static buildEmbeddedCount(source, filters) {\n    return sql`(select count(*) from ${source}${sql.raw(\" where \").if(filters)}${filters})`;\n  }\n  static buildCount(source, filters) {\n    return sql`select count(*) as count from ${source}${sql.raw(\" where \").if(filters)}${filters};`;\n  }\n  /** @intrnal */\n  setToken(token) {\n    this.token = token;\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    return Promise.resolve(this.session.count(this.sql, this.token)).then(\n      onfulfilled,\n      onrejected\n    );\n  }\n  catch(onRejected) {\n    return this.then(void 0, onRejected);\n  }\n  finally(onFinally) {\n    return this.then(\n      (value) => {\n        onFinally?.();\n        return value;\n      },\n      (reason) => {\n        onFinally?.();\n        throw reason;\n      }\n    );\n  }\n}\nexport {\n  PgCountBuilder\n};\n//# sourceMappingURL=count.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nimport {\n  mapRelationalRow\n} from \"../../relations.js\";\nimport { tracer } from \"../../tracing.js\";\nclass RelationalQueryBuilder {\n  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {\n    this.fullSchema = fullSchema;\n    this.schema = schema;\n    this.tableNamesMap = tableNamesMap;\n    this.table = table;\n    this.tableConfig = tableConfig;\n    this.dialect = dialect;\n    this.session = session;\n  }\n  static [entityKind] = \"PgRelationalQueryBuilder\";\n  findMany(config) {\n    return new PgRelationalQuery(\n      this.fullSchema,\n      this.schema,\n      this.tableNamesMap,\n      this.table,\n      this.tableConfig,\n      this.dialect,\n      this.session,\n      config ? config : {},\n      \"many\"\n    );\n  }\n  findFirst(config) {\n    return new PgRelationalQuery(\n      this.fullSchema,\n      this.schema,\n      this.tableNamesMap,\n      this.table,\n      this.tableConfig,\n      this.dialect,\n      this.session,\n      config ? { ...config, limit: 1 } : { limit: 1 },\n      \"first\"\n    );\n  }\n}\nclass PgRelationalQuery extends QueryPromise {\n  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {\n    super();\n    this.fullSchema = fullSchema;\n    this.schema = schema;\n    this.tableNamesMap = tableNamesMap;\n    this.table = table;\n    this.tableConfig = tableConfig;\n    this.dialect = dialect;\n    this.session = session;\n    this.config = config;\n    this.mode = mode;\n  }\n  static [entityKind] = \"PgRelationalQuery\";\n  /** @internal */\n  _prepare(name) {\n    return tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n      const { query, builtQuery } = this._toSQL();\n      return this.session.prepareQuery(\n        builtQuery,\n        void 0,\n        name,\n        true,\n        (rawRows, mapColumnValue) => {\n          const rows = rawRows.map(\n            (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)\n          );\n          if (this.mode === \"first\") {\n            return rows[0];\n          }\n          return rows;\n        }\n      );\n    });\n  }\n  prepare(name) {\n    return this._prepare(name);\n  }\n  _getQuery() {\n    return this.dialect.buildRelationalQueryWithoutPK({\n      fullSchema: this.fullSchema,\n      schema: this.schema,\n      tableNamesMap: this.tableNamesMap,\n      table: this.table,\n      tableConfig: this.tableConfig,\n      queryConfig: this.config,\n      tableAlias: this.tableConfig.tsName\n    });\n  }\n  /** @internal */\n  getSQL() {\n    return this._getQuery().sql;\n  }\n  _toSQL() {\n    const query = this._getQuery();\n    const builtQuery = this.dialect.sqlToQuery(query.sql);\n    return { query, builtQuery };\n  }\n  toSQL() {\n    return this._toSQL().builtQuery;\n  }\n  authToken;\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  execute() {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      return this._prepare().execute(void 0, this.authToken);\n    });\n  }\n}\nexport {\n  PgRelationalQuery,\n  RelationalQueryBuilder\n};\n//# sourceMappingURL=query.js.map",
    "import { entityKind } from \"../../entity.js\";\nimport { QueryPromise } from \"../../query-promise.js\";\nclass PgRaw extends QueryPromise {\n  constructor(execute, sql, query, mapBatchResult) {\n    super();\n    this.execute = execute;\n    this.sql = sql;\n    this.query = query;\n    this.mapBatchResult = mapBatchResult;\n  }\n  static [entityKind] = \"PgRaw\";\n  /** @internal */\n  getSQL() {\n    return this.sql;\n  }\n  getQuery() {\n    return this.query;\n  }\n  mapResult(result, isFromBatch) {\n    return isFromBatch ? this.mapBatchResult(result) : result;\n  }\n  _prepare() {\n    return this;\n  }\n  /** @internal */\n  isResponseInArrayMode() {\n    return false;\n  }\n}\nexport {\n  PgRaw\n};\n//# sourceMappingURL=raw.js.map",
    "import { entityKind } from \"../entity.js\";\nimport {\n  PgDeleteBase,\n  PgInsertBuilder,\n  PgSelectBuilder,\n  PgUpdateBuilder,\n  QueryBuilder\n} from \"./query-builders/index.js\";\nimport { SelectionProxyHandler } from \"../selection-proxy.js\";\nimport { sql } from \"../sql/sql.js\";\nimport { WithSubquery } from \"../subquery.js\";\nimport { PgCountBuilder } from \"./query-builders/count.js\";\nimport { RelationalQueryBuilder } from \"./query-builders/query.js\";\nimport { PgRaw } from \"./query-builders/raw.js\";\nimport { PgRefreshMaterializedView } from \"./query-builders/refresh-materialized-view.js\";\nclass PgDatabase {\n  constructor(dialect, session, schema) {\n    this.dialect = dialect;\n    this.session = session;\n    this._ = schema ? {\n      schema: schema.schema,\n      fullSchema: schema.fullSchema,\n      tableNamesMap: schema.tableNamesMap,\n      session\n    } : {\n      schema: void 0,\n      fullSchema: {},\n      tableNamesMap: {},\n      session\n    };\n    this.query = {};\n    if (this._.schema) {\n      for (const [tableName, columns] of Object.entries(this._.schema)) {\n        this.query[tableName] = new RelationalQueryBuilder(\n          schema.fullSchema,\n          this._.schema,\n          this._.tableNamesMap,\n          schema.fullSchema[tableName],\n          columns,\n          dialect,\n          session\n        );\n      }\n    }\n    this.$cache = { invalidate: async (_params) => {\n    } };\n  }\n  static [entityKind] = \"PgDatabase\";\n  query;\n  /**\n   * Creates a subquery that defines a temporary named result set as a CTE.\n   *\n   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n   *\n   * @param alias The alias for the subquery.\n   *\n   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a subquery with alias 'sq' and use it in the select query\n   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n   *\n   * const result = await db.with(sq).select().from(sq);\n   * ```\n   *\n   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:\n   *\n   * ```ts\n   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query\n   * const sq = db.$with('sq').as(db.select({\n   *   name: sql<string>`upper(${users.name})`.as('name'),\n   * })\n   * .from(users));\n   *\n   * const result = await db.with(sq).select({ name: sq.name }).from(sq);\n   * ```\n   */\n  $with = (alias, selection) => {\n    const self = this;\n    const as = (qb) => {\n      if (typeof qb === \"function\") {\n        qb = qb(new QueryBuilder(self.dialect));\n      }\n      return new Proxy(\n        new WithSubquery(\n          qb.getSQL(),\n          selection ?? (\"getSelectedFields\" in qb ? qb.getSelectedFields() ?? {} : {}),\n          alias,\n          true\n        ),\n        new SelectionProxyHandler({ alias, sqlAliasedBehavior: \"alias\", sqlBehavior: \"error\" })\n      );\n    };\n    return { as };\n  };\n  $count(source, filters) {\n    return new PgCountBuilder({ source, filters, session: this.session });\n  }\n  $cache;\n  /**\n   * Incorporates a previously defined CTE (using `$with`) into the main query.\n   *\n   * This method allows the main query to reference a temporary named result set.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n   *\n   * @param queries The CTEs to incorporate into the main query.\n   *\n   * @example\n   *\n   * ```ts\n   * // Define a subquery 'sq' as a CTE using $with\n   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n   *\n   * // Incorporate the CTE 'sq' into the main query and select from it\n   * const result = await db.with(sq).select().from(sq);\n   * ```\n   */\n  with(...queries) {\n    const self = this;\n    function select(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries\n      });\n    }\n    function selectDistinct(fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries,\n        distinct: true\n      });\n    }\n    function selectDistinctOn(on, fields) {\n      return new PgSelectBuilder({\n        fields: fields ?? void 0,\n        session: self.session,\n        dialect: self.dialect,\n        withList: queries,\n        distinct: { on }\n      });\n    }\n    function update(table) {\n      return new PgUpdateBuilder(table, self.session, self.dialect, queries);\n    }\n    function insert(table) {\n      return new PgInsertBuilder(table, self.session, self.dialect, queries);\n    }\n    function delete_(table) {\n      return new PgDeleteBase(table, self.session, self.dialect, queries);\n    }\n    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };\n  }\n  select(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect\n    });\n  }\n  selectDistinct(fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect,\n      distinct: true\n    });\n  }\n  selectDistinctOn(on, fields) {\n    return new PgSelectBuilder({\n      fields: fields ?? void 0,\n      session: this.session,\n      dialect: this.dialect,\n      distinct: { on }\n    });\n  }\n  /**\n   * Creates an update query.\n   *\n   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n   *\n   * Use `.set()` method to specify which values to update.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/update}\n   *\n   * @param table The table to update.\n   *\n   * @example\n   *\n   * ```ts\n   * // Update all rows in the 'cars' table\n   * await db.update(cars).set({ color: 'red' });\n   *\n   * // Update rows with filters and conditions\n   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n   *\n   * // Update with returning clause\n   * const updatedCar: Car[] = await db.update(cars)\n   *   .set({ color: 'red' })\n   *   .where(eq(cars.id, 1))\n   *   .returning();\n   * ```\n   */\n  update(table) {\n    return new PgUpdateBuilder(table, this.session, this.dialect);\n  }\n  /**\n   * Creates an insert query.\n   *\n   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/insert}\n   *\n   * @param table The table to insert into.\n   *\n   * @example\n   *\n   * ```ts\n   * // Insert one row\n   * await db.insert(cars).values({ brand: 'BMW' });\n   *\n   * // Insert multiple rows\n   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n   *\n   * // Insert with returning clause\n   * const insertedCar: Car[] = await db.insert(cars)\n   *   .values({ brand: 'BMW' })\n   *   .returning();\n   * ```\n   */\n  insert(table) {\n    return new PgInsertBuilder(table, this.session, this.dialect);\n  }\n  /**\n   * Creates a delete query.\n   *\n   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n   *\n   * See docs: {@link https://orm.drizzle.team/docs/delete}\n   *\n   * @param table The table to delete from.\n   *\n   * @example\n   *\n   * ```ts\n   * // Delete all rows in the 'cars' table\n   * await db.delete(cars);\n   *\n   * // Delete rows with filters and conditions\n   * await db.delete(cars).where(eq(cars.color, 'green'));\n   *\n   * // Delete with returning clause\n   * const deletedCar: Car[] = await db.delete(cars)\n   *   .where(eq(cars.id, 1))\n   *   .returning();\n   * ```\n   */\n  delete(table) {\n    return new PgDeleteBase(table, this.session, this.dialect);\n  }\n  refreshMaterializedView(view) {\n    return new PgRefreshMaterializedView(view, this.session, this.dialect);\n  }\n  authToken;\n  execute(query) {\n    const sequel = typeof query === \"string\" ? sql.raw(query) : query.getSQL();\n    const builtQuery = this.dialect.sqlToQuery(sequel);\n    const prepared = this.session.prepareQuery(\n      builtQuery,\n      void 0,\n      void 0,\n      false\n    );\n    return new PgRaw(\n      () => prepared.execute(void 0, this.authToken),\n      sequel,\n      builtQuery,\n      (result) => prepared.mapResult(result, true)\n    );\n  }\n  transaction(transaction, config) {\n    return this.session.transaction(transaction, config);\n  }\n}\nconst withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {\n  const select = (...args) => getReplica(replicas).select(...args);\n  const selectDistinct = (...args) => getReplica(replicas).selectDistinct(...args);\n  const selectDistinctOn = (...args) => getReplica(replicas).selectDistinctOn(...args);\n  const $count = (...args) => getReplica(replicas).$count(...args);\n  const _with = (...args) => getReplica(replicas).with(...args);\n  const $with = (arg) => getReplica(replicas).$with(arg);\n  const update = (...args) => primary.update(...args);\n  const insert = (...args) => primary.insert(...args);\n  const $delete = (...args) => primary.delete(...args);\n  const execute = (...args) => primary.execute(...args);\n  const transaction = (...args) => primary.transaction(...args);\n  const refreshMaterializedView = (...args) => primary.refreshMaterializedView(...args);\n  return {\n    ...primary,\n    update,\n    insert,\n    delete: $delete,\n    execute,\n    transaction,\n    refreshMaterializedView,\n    $primary: primary,\n    select,\n    selectDistinct,\n    selectDistinctOn,\n    $count,\n    $with,\n    with: _with,\n    get query() {\n      return getReplica(replicas).query;\n    }\n  };\n};\nexport {\n  PgDatabase,\n  withReplicas\n};\n//# sourceMappingURL=db.js.map",
    "import { entityKind } from \"../../entity.js\";\nclass Cache {\n  static [entityKind] = \"Cache\";\n}\nclass NoopCache extends Cache {\n  strategy() {\n    return \"all\";\n  }\n  static [entityKind] = \"NoopCache\";\n  async get(_key) {\n    return void 0;\n  }\n  async put(_hashedQuery, _response, _tables, _config) {\n  }\n  async onMutate(_params) {\n  }\n}\nasync function hashQuery(sql, params) {\n  const dataToHash = `${sql}-${JSON.stringify(params)}`;\n  const encoder = new TextEncoder();\n  const data = encoder.encode(dataToHash);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = [...new Uint8Array(hashBuffer)];\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hashHex;\n}\nexport {\n  Cache,\n  NoopCache,\n  hashQuery\n};\n//# sourceMappingURL=cache.js.map",
    "import { hashQuery, NoopCache } from \"../cache/core/cache.js\";\nimport { entityKind, is } from \"../entity.js\";\nimport { DrizzleQueryError, TransactionRollbackError } from \"../errors.js\";\nimport { sql } from \"../sql/index.js\";\nimport { tracer } from \"../tracing.js\";\nimport { PgDatabase } from \"./db.js\";\nclass PgPreparedQuery {\n  constructor(query, cache, queryMetadata, cacheConfig) {\n    this.query = query;\n    this.cache = cache;\n    this.queryMetadata = queryMetadata;\n    this.cacheConfig = cacheConfig;\n    if (cache && cache.strategy() === \"all\" && cacheConfig === void 0) {\n      this.cacheConfig = { enable: true, autoInvalidate: true };\n    }\n    if (!this.cacheConfig?.enable) {\n      this.cacheConfig = void 0;\n    }\n  }\n  authToken;\n  getQuery() {\n    return this.query;\n  }\n  mapResult(response, _isFromBatch) {\n    return response;\n  }\n  /** @internal */\n  setToken(token) {\n    this.authToken = token;\n    return this;\n  }\n  static [entityKind] = \"PgPreparedQuery\";\n  /** @internal */\n  joinsNotNullableMap;\n  /** @internal */\n  async queryWithCache(queryString, params, query) {\n    if (this.cache === void 0 || is(this.cache, NoopCache) || this.queryMetadata === void 0) {\n      try {\n        return await query();\n      } catch (e) {\n        throw new DrizzleQueryError(queryString, params, e);\n      }\n    }\n    if (this.cacheConfig && !this.cacheConfig.enable) {\n      try {\n        return await query();\n      } catch (e) {\n        throw new DrizzleQueryError(queryString, params, e);\n      }\n    }\n    if ((this.queryMetadata.type === \"insert\" || this.queryMetadata.type === \"update\" || this.queryMetadata.type === \"delete\") && this.queryMetadata.tables.length > 0) {\n      try {\n        const [res] = await Promise.all([\n          query(),\n          this.cache.onMutate({ tables: this.queryMetadata.tables })\n        ]);\n        return res;\n      } catch (e) {\n        throw new DrizzleQueryError(queryString, params, e);\n      }\n    }\n    if (!this.cacheConfig) {\n      try {\n        return await query();\n      } catch (e) {\n        throw new DrizzleQueryError(queryString, params, e);\n      }\n    }\n    if (this.queryMetadata.type === \"select\") {\n      const fromCache = await this.cache.get(\n        this.cacheConfig.tag ?? (await hashQuery(queryString, params)),\n        this.queryMetadata.tables,\n        this.cacheConfig.tag !== void 0,\n        this.cacheConfig.autoInvalidate\n      );\n      if (fromCache === void 0) {\n        let result;\n        try {\n          result = await query();\n        } catch (e) {\n          throw new DrizzleQueryError(queryString, params, e);\n        }\n        await this.cache.put(\n          this.cacheConfig.tag ?? (await hashQuery(queryString, params)),\n          result,\n          // make sure we send tables that were used in a query only if user wants to invalidate it on each write\n          this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [],\n          this.cacheConfig.tag !== void 0,\n          this.cacheConfig.config\n        );\n        return result;\n      }\n      return fromCache;\n    }\n    try {\n      return await query();\n    } catch (e) {\n      throw new DrizzleQueryError(queryString, params, e);\n    }\n  }\n}\nclass PgSession {\n  constructor(dialect) {\n    this.dialect = dialect;\n  }\n  static [entityKind] = \"PgSession\";\n  /** @internal */\n  execute(query, token) {\n    return tracer.startActiveSpan(\"drizzle.operation\", () => {\n      const prepared = tracer.startActiveSpan(\"drizzle.prepareQuery\", () => {\n        return this.prepareQuery(\n          this.dialect.sqlToQuery(query),\n          void 0,\n          void 0,\n          false\n        );\n      });\n      return prepared.setToken(token).execute(void 0, token);\n    });\n  }\n  all(query) {\n    return this.prepareQuery(\n      this.dialect.sqlToQuery(query),\n      void 0,\n      void 0,\n      false\n    ).all();\n  }\n  /** @internal */\n  async count(sql2, token) {\n    const res = await this.execute(sql2, token);\n    return Number(\n      res[0][\"count\"]\n    );\n  }\n}\nclass PgTransaction extends PgDatabase {\n  constructor(dialect, session, schema, nestedIndex = 0) {\n    super(dialect, session, schema);\n    this.schema = schema;\n    this.nestedIndex = nestedIndex;\n  }\n  static [entityKind] = \"PgTransaction\";\n  rollback() {\n    throw new TransactionRollbackError();\n  }\n  /** @internal */\n  getTransactionConfigSQL(config) {\n    const chunks = [];\n    if (config.isolationLevel) {\n      chunks.push(`isolation level ${config.isolationLevel}`);\n    }\n    if (config.accessMode) {\n      chunks.push(config.accessMode);\n    }\n    if (typeof config.deferrable === \"boolean\") {\n      chunks.push(config.deferrable ? \"deferrable\" : \"not deferrable\");\n    }\n    return sql.raw(chunks.join(\" \"));\n  }\n  setTransaction(config) {\n    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n  }\n}\nexport {\n  PgPreparedQuery,\n  PgSession,\n  PgTransaction\n};\n//# sourceMappingURL=session.js.map",
    "export * from \"./array.js\";\n//# sourceMappingURL=index.js.map",
    "export * from \"./alias.js\";\nexport * from \"./checks.js\";\nexport * from \"./columns/index.js\";\nexport * from \"./db.js\";\nexport * from \"./dialect.js\";\nexport * from \"./foreign-keys.js\";\nexport * from \"./indexes.js\";\nexport * from \"./policies.js\";\nexport * from \"./primary-keys.js\";\nexport * from \"./query-builders/index.js\";\nexport * from \"./roles.js\";\nexport * from \"./schema.js\";\nexport * from \"./sequence.js\";\nexport * from \"./session.js\";\nexport * from \"./subquery.js\";\nexport * from \"./table.js\";\nexport * from \"./unique-constraint.js\";\nexport * from \"./utils.js\";\nexport * from \"./utils/index.js\";\nexport * from \"./view-common.js\";\nexport * from \"./view.js\";\n//# sourceMappingURL=index.js.map",
    "export * from \"./alias.js\";\nexport * from \"./column-builder.js\";\nexport * from \"./column.js\";\nexport * from \"./entity.js\";\nexport * from \"./errors.js\";\nexport * from \"./logger.js\";\nexport * from \"./operations.js\";\nexport * from \"./query-promise.js\";\nexport * from \"./relations.js\";\nexport * from \"./sql/index.js\";\nexport * from \"./subquery.js\";\nexport * from \"./table.js\";\nexport * from \"./utils.js\";\nexport * from \"./view-common.js\";\n//# sourceMappingURL=index.js.map",
    "import { sql } from 'drizzle-orm';\nimport type { DrizzleDB } from '../types';\n\nexport class MigrationTracker {\n  constructor(private db: DrizzleDB) {}\n\n  async ensureSchema(): Promise<void> {\n    await this.db.execute(sql`CREATE SCHEMA IF NOT EXISTS migrations`);\n  }\n\n  async ensureTables(): Promise<void> {\n    // Ensure schema exists\n    await this.ensureSchema();\n\n    // Create migrations table (like Drizzle's __drizzle_migrations)\n    await this.db.execute(sql`\n      CREATE TABLE IF NOT EXISTS migrations._migrations (\n        id SERIAL PRIMARY KEY,\n        plugin_name TEXT NOT NULL,\n        hash TEXT NOT NULL,\n        created_at BIGINT NOT NULL\n      )\n    `);\n\n    // Create journal table (replaces _journal.json)\n    await this.db.execute(sql`\n      CREATE TABLE IF NOT EXISTS migrations._journal (\n        plugin_name TEXT PRIMARY KEY,\n        version TEXT NOT NULL,\n        dialect TEXT NOT NULL DEFAULT 'postgresql',\n        entries JSONB NOT NULL DEFAULT '[]'\n      )\n    `);\n\n    // Create snapshots table (replaces snapshot JSON files)\n    await this.db.execute(sql`\n      CREATE TABLE IF NOT EXISTS migrations._snapshots (\n        id SERIAL PRIMARY KEY,\n        plugin_name TEXT NOT NULL,\n        idx INTEGER NOT NULL,\n        snapshot JSONB NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        UNIQUE(plugin_name, idx)\n      )\n    `);\n  }\n\n  async getLastMigration(pluginName: string): Promise<{\n    id: number;\n    hash: string;\n    created_at: string;\n  } | null> {\n    const result = await this.db.execute(\n      sql`SELECT id, hash, created_at \n          FROM migrations._migrations \n          WHERE plugin_name = ${pluginName} \n          ORDER BY created_at DESC \n          LIMIT 1`\n    );\n    return (result.rows[0] as any) || null;\n  }\n\n  async recordMigration(pluginName: string, hash: string, createdAt: number): Promise<void> {\n    await this.db.execute(\n      sql`INSERT INTO migrations._migrations (plugin_name, hash, created_at) \n          VALUES (${pluginName}, ${hash}, ${createdAt})`\n    );\n  }\n}\n",
    "import { sql } from 'drizzle-orm';\nimport type { DrizzleDB, Journal, JournalEntry } from '../types';\n\nexport class JournalStorage {\n  constructor(private db: DrizzleDB) {}\n\n  async loadJournal(pluginName: string): Promise<Journal | null> {\n    const result = await this.db.execute(\n      sql`SELECT version, dialect, entries \n          FROM migrations._journal \n          WHERE plugin_name = ${pluginName}`\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0] as any;\n    return {\n      version: row.version,\n      dialect: row.dialect,\n      entries: row.entries as JournalEntry[],\n    };\n  }\n\n  async saveJournal(pluginName: string, journal: Journal): Promise<void> {\n    await this.db.execute(\n      sql`INSERT INTO migrations._journal (plugin_name, version, dialect, entries)\n          VALUES (${pluginName}, ${journal.version}, ${journal.dialect}, ${JSON.stringify(journal.entries)}::jsonb)\n          ON CONFLICT (plugin_name) \n          DO UPDATE SET \n            version = EXCLUDED.version,\n            dialect = EXCLUDED.dialect,\n            entries = EXCLUDED.entries`\n    );\n  }\n\n  async addEntry(pluginName: string, entry: JournalEntry): Promise<void> {\n    // First, get the current journal\n    let journal = await this.loadJournal(pluginName);\n\n    // If no journal exists, create a new one\n    if (!journal) {\n      journal = {\n        version: '7', // Latest Drizzle version\n        dialect: 'postgresql',\n        entries: [],\n      };\n    }\n\n    // Add the new entry\n    journal.entries.push(entry);\n\n    // Save the updated journal\n    await this.saveJournal(pluginName, journal);\n  }\n\n  async getNextIdx(pluginName: string): Promise<number> {\n    const journal = await this.loadJournal(pluginName);\n\n    if (!journal || journal.entries.length === 0) {\n      return 0;\n    }\n\n    const lastEntry = journal.entries[journal.entries.length - 1];\n    return lastEntry.idx + 1;\n  }\n\n  async updateJournal(\n    pluginName: string,\n    idx: number,\n    tag: string,\n    breakpoints: boolean = true\n  ): Promise<void> {\n    const entry: JournalEntry = {\n      idx,\n      version: '7',\n      when: Date.now(),\n      tag,\n      breakpoints,\n    };\n\n    await this.addEntry(pluginName, entry);\n  }\n}\n",
    "import { sql } from 'drizzle-orm';\nimport type { DrizzleDB, SchemaSnapshot } from '../types';\n\nexport class SnapshotStorage {\n  constructor(private db: DrizzleDB) {}\n\n  async saveSnapshot(pluginName: string, idx: number, snapshot: SchemaSnapshot): Promise<void> {\n    await this.db.execute(\n      sql`INSERT INTO migrations._snapshots (plugin_name, idx, snapshot)\n          VALUES (${pluginName}, ${idx}, ${JSON.stringify(snapshot)}::jsonb)\n          ON CONFLICT (plugin_name, idx) \n          DO UPDATE SET \n            snapshot = EXCLUDED.snapshot,\n            created_at = NOW()`\n    );\n  }\n\n  async loadSnapshot(pluginName: string, idx: number): Promise<SchemaSnapshot | null> {\n    const result = await this.db.execute(\n      sql`SELECT snapshot \n          FROM migrations._snapshots \n          WHERE plugin_name = ${pluginName} AND idx = ${idx}`\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return result.rows[0].snapshot as SchemaSnapshot;\n  }\n\n  async getLatestSnapshot(pluginName: string): Promise<SchemaSnapshot | null> {\n    const result = await this.db.execute(\n      sql`SELECT snapshot \n          FROM migrations._snapshots \n          WHERE plugin_name = ${pluginName}\n          ORDER BY idx DESC\n          LIMIT 1`\n    );\n\n    if (result.rows.length === 0) {\n      return null;\n    }\n\n    return result.rows[0].snapshot as SchemaSnapshot;\n  }\n\n  async getAllSnapshots(pluginName: string): Promise<SchemaSnapshot[]> {\n    const result = await this.db.execute(\n      sql`SELECT snapshot \n          FROM migrations._snapshots \n          WHERE plugin_name = ${pluginName}\n          ORDER BY idx ASC`\n    );\n\n    return result.rows.map((row) => row.snapshot as SchemaSnapshot);\n  }\n}\n",
    "import { sql } from 'drizzle-orm';\nimport { logger } from '@elizaos/core';\nimport type { DrizzleDB } from './types';\n\nexport class ExtensionManager {\n  constructor(private db: DrizzleDB) {}\n\n  async installRequiredExtensions(extensions: string[]): Promise<void> {\n    for (const extension of extensions) {\n      try {\n        // Validate extension name to prevent SQL injection\n        // Extension names should only contain alphanumeric characters, underscores, and hyphens\n        if (!/^[a-zA-Z0-9_-]+$/.test(extension)) {\n          logger.warn(\n            `[RuntimeMigrator] Invalid extension name \"${extension}\" - contains invalid characters`\n          );\n          continue;\n        }\n\n        // Use sql.identifier for safe escaping of SQL identifiers\n        await this.db.execute(sql`CREATE EXTENSION IF NOT EXISTS ${sql.identifier(extension)}`);\n        logger.debug(`[RuntimeMigrator] Extension installed: ${extension}`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.warn(`[RuntimeMigrator] Could not install extension ${extension}: ${errorMessage}`);\n        // Some extensions might not be available or already installed\n        // This shouldn't stop the migration process\n      }\n    }\n  }\n}\n",
    "import { createHash } from 'crypto';\nimport { is, SQL } from 'drizzle-orm';\nimport { PgTable, getTableConfig, PgDialect, type PgColumn } from 'drizzle-orm/pg-core';\nimport type { SchemaSnapshot } from '../types';\n\n/**\n * Utility functions from Drizzle's code\n */\nfunction escapeSingleQuotes(str: string): string {\n  return str.replace(/'/g, \"''\");\n}\n\nfunction isPgArrayType(sqlType: string): boolean {\n  return sqlType.match(/.*\\[\\d*\\].*|.*\\[\\].*/g) !== null;\n}\n\nfunction buildArrayString(array: any[], sqlType: string): string {\n  sqlType = sqlType.split('[')[0];\n  const values = array\n    .map((value) => {\n      if (typeof value === 'number' || typeof value === 'bigint') {\n        return value.toString();\n      } else if (typeof value === 'boolean') {\n        return value ? 'true' : 'false';\n      } else if (Array.isArray(value)) {\n        return buildArrayString(value, sqlType);\n      } else if (value instanceof Date) {\n        if (sqlType === 'date') {\n          return `\"${value.toISOString().split('T')[0]}\"`;\n        } else if (sqlType === 'timestamp') {\n          return `\"${value.toISOString().replace('T', ' ').slice(0, 23)}\"`;\n        } else {\n          return `\"${value.toISOString()}\"`;\n        }\n      } else if (typeof value === 'object') {\n        return `\"${JSON.stringify(value).replaceAll('\"', '\\\\\"')}\"`;\n      }\n\n      return `\"${value}\"`;\n    })\n    .join(',');\n\n  return `{${values}}`;\n}\n\nconst sqlToStr = (sql: SQL, casing: any) => {\n  return sql.toQuery({\n    escapeName: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    escapeParam: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    escapeString: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    casing,\n  }).sql;\n};\n\n/**\n * Extract Drizzle tables from a schema object\n */\nfunction extractTablesFromSchema(schema: any): PgTable[] {\n  const tables: PgTable[] = [];\n\n  // Iterate through all exports in the schema\n  const exports = Object.values(schema);\n  exports.forEach((t: any) => {\n    // Check if it's a PgTable using Drizzle's is() function\n    if (is(t, PgTable)) {\n      tables.push(t);\n    }\n  });\n\n  return tables;\n}\n\n/**\n * Generate a snapshot from a Drizzle schema\n * This is a port of Drizzle's pgSerializer.generatePgSnapshot\n */\nexport async function generateSnapshot(schema: any): Promise<SchemaSnapshot> {\n  const dialect = new PgDialect({ casing: undefined });\n  const tables: any = {};\n  const schemas: any = {};\n  const enums: any = {};\n\n  // Extract tables from schema\n  const pgTables = extractTablesFromSchema(schema);\n\n  // Process each table\n  for (const table of pgTables) {\n    const config = getTableConfig(table);\n    const {\n      name: tableName,\n      columns,\n      indexes,\n      foreignKeys,\n      schema: tableSchema,\n      primaryKeys,\n      uniqueConstraints,\n      checks,\n    } = config;\n\n    const columnsObject: any = {};\n    const indexesObject: any = {};\n    const foreignKeysObject: any = {};\n    const primaryKeysObject: any = {};\n    const uniqueConstraintObject: any = {};\n    const checksObject: any = {};\n\n    // Process columns - EXACT copy of Drizzle's logic\n    columns.forEach((column: PgColumn) => {\n      const name = column.name;\n      const notNull = column.notNull;\n      const primaryKey = column.primary;\n      const sqlType = column.getSQLType();\n      const sqlTypeLowered = sqlType.toLowerCase();\n\n      const columnToSet: any = {\n        name,\n        type: sqlType,\n        primaryKey,\n        notNull,\n      };\n\n      // Handle defaults - EXACT copy from Drizzle's pgSerializer.ts lines 247-273\n      if (column.default !== undefined) {\n        if (is(column.default, SQL)) {\n          columnToSet.default = sqlToStr(column.default, undefined);\n        } else {\n          if (typeof column.default === 'string') {\n            columnToSet.default = `'${escapeSingleQuotes(column.default)}'`;\n          } else {\n            if (sqlTypeLowered === 'jsonb' || sqlTypeLowered === 'json') {\n              columnToSet.default = `'${JSON.stringify(column.default)}'::${sqlTypeLowered}`;\n            } else if (column.default instanceof Date) {\n              if (sqlTypeLowered === 'date') {\n                columnToSet.default = `'${column.default.toISOString().split('T')[0]}'`;\n              } else if (sqlTypeLowered === 'timestamp') {\n                columnToSet.default = `'${column.default.toISOString().replace('T', ' ').slice(0, 23)}'`;\n              } else {\n                columnToSet.default = `'${column.default.toISOString()}'`;\n              }\n            } else if (isPgArrayType(sqlTypeLowered) && Array.isArray(column.default)) {\n              columnToSet.default = `'${buildArrayString(column.default, sqlTypeLowered)}'`;\n            } else {\n              // Should do for all types\n              // columnToSet.default = `'${column.default}'::${sqlTypeLowered}`;\n              columnToSet.default = column.default;\n            }\n          }\n        }\n      }\n\n      // Handle column-level unique constraints\n      // IMPORTANT: Check isUnique, not just uniqueName presence!\n      // Drizzle sets uniqueName for all columns but only unique ones should have constraints\n      if ((column as any).isUnique && (column as any).config?.uniqueName) {\n        uniqueConstraintObject[(column as any).config.uniqueName] = {\n          name: (column as any).config.uniqueName,\n          columns: [name],\n          nullsNotDistinct: (column as any).config?.uniqueType === 'not distinct',\n        };\n      }\n\n      columnsObject[name] = columnToSet;\n    });\n\n    // Process primary keys\n    primaryKeys.forEach((pk: any) => {\n      const columnNames = pk.columns.map((c: any) => c.name);\n      const name = pk.getName();\n\n      primaryKeysObject[name] = {\n        name,\n        columns: columnNames,\n      };\n    });\n\n    // Process unique constraints\n    uniqueConstraints?.forEach((unq: any) => {\n      const columnNames = unq.columns.map((c: any) => c.name);\n      const name = unq.name || `${tableName}_${columnNames.join('_')}_unique`;\n\n      uniqueConstraintObject[name] = {\n        name,\n        columns: columnNames,\n        nullsNotDistinct: unq.nullsNotDistinct,\n      };\n    });\n\n    // Process foreign keys - includes both explicit foreignKeys and inline references\n    // Drizzle's getTableConfig automatically collects inline .references() into foreignKeys\n    foreignKeys.forEach((fk: any) => {\n      const reference = fk.reference();\n      const columnsFrom = reference.columns.map((it: any) => it.name);\n      const columnsTo = reference.foreignColumns.map((it: any) => it.name);\n      const tableTo = getTableConfig(reference.foreignTable).name;\n      const schemaTo = getTableConfig(reference.foreignTable).schema || 'public';\n\n      const name = fk.getName();\n\n      foreignKeysObject[name] = {\n        name,\n        tableFrom: tableName,\n        schemaFrom: tableSchema, // Add source table schema\n        tableTo,\n        schemaTo,\n        columnsFrom,\n        columnsTo,\n        onDelete: fk.onDelete || 'no action',\n        onUpdate: fk.onUpdate || 'no action',\n      };\n    });\n\n    // Process indexes\n    indexes.forEach((idx: any) => {\n      const columns = idx.config.columns;\n      const indexColumns = columns.map((col: any) => {\n        if (is(col, SQL)) {\n          return {\n            expression: dialect.sqlToQuery(col).sql,\n            isExpression: true,\n          };\n        } else {\n          const indexCol: any = {\n            expression: col.name,\n            isExpression: false,\n            asc: col.indexConfig?.order === 'asc',\n          };\n          // Only add nulls if explicitly specified in the config\n          if (col.indexConfig?.nulls) {\n            indexCol.nulls = col.indexConfig.nulls;\n          }\n          return indexCol;\n        }\n      });\n\n      const name =\n        idx.config.name ||\n        `${tableName}_${indexColumns.map((c: any) => c.expression).join('_')}_index`;\n\n      indexesObject[name] = {\n        name,\n        columns: indexColumns,\n        isUnique: idx.config.unique || false,\n        method: idx.config.method || 'btree',\n      };\n    });\n\n    // Process check constraints\n    if (checks) {\n      checks.forEach((check: any) => {\n        const checkName = check.name;\n        checksObject[checkName] = {\n          name: checkName,\n          value: dialect.sqlToQuery(check.value).sql,\n        };\n      });\n    }\n\n    // Build the table object\n    tables[`${tableSchema || 'public'}.${tableName}`] = {\n      name: tableName,\n      schema: tableSchema || 'public',\n      columns: columnsObject,\n      indexes: indexesObject,\n      foreignKeys: foreignKeysObject,\n      compositePrimaryKeys: primaryKeysObject,\n      uniqueConstraints: uniqueConstraintObject,\n      checkConstraints: checksObject,\n    };\n\n    // Track schemas\n    if (tableSchema && tableSchema !== 'public') {\n      schemas[tableSchema] = tableSchema;\n    }\n  }\n\n  // Create snapshot in Drizzle's format\n  const snapshot: SchemaSnapshot = {\n    version: '7',\n    dialect: 'postgresql',\n    tables,\n    schemas,\n    enums,\n    _meta: {\n      schemas: {},\n      tables: {},\n      columns: {},\n    },\n  };\n\n  return snapshot;\n}\n\n/**\n * Calculate hash of a snapshot for change detection\n */\nexport function hashSnapshot(snapshot: SchemaSnapshot): string {\n  const content = JSON.stringify(snapshot);\n  return createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Create an empty snapshot for initial migration\n */\nexport function createEmptySnapshot(): SchemaSnapshot {\n  return {\n    version: '7',\n    dialect: 'postgresql',\n    tables: {},\n    schemas: {},\n    enums: {},\n    _meta: {\n      schemas: {},\n      tables: {},\n      columns: {},\n    },\n  };\n}\n\n/**\n * Compare two snapshots and detect if there are changes\n */\nexport function hasChanges(\n  previousSnapshot: SchemaSnapshot | null,\n  currentSnapshot: SchemaSnapshot\n): boolean {\n  // If no previous snapshot, there are definitely changes\n  if (!previousSnapshot) {\n    return Object.keys(currentSnapshot.tables).length > 0;\n  }\n\n  // Simple comparison for now - in production, use deep comparison\n  const prevHash = hashSnapshot(previousSnapshot);\n  const currHash = hashSnapshot(currentSnapshot);\n\n  return prevHash !== currHash;\n}\n",
    "import type { SchemaSnapshot } from '../types';\n\n/**\n * Normalize SQL types for comparison\n * Handles equivalent type variations between introspected DB and schema definitions\n */\nfunction normalizeType(type: string | undefined): string {\n  if (!type) return '';\n\n  const normalized = type.toLowerCase().trim();\n\n  // Handle timestamp variations\n  if (normalized === 'timestamp without time zone' || normalized === 'timestamp with time zone') {\n    return 'timestamp';\n  }\n\n  // Handle serial vs integer with identity\n  // serial is essentially integer with auto-increment\n  if (normalized === 'serial') {\n    return 'integer';\n  }\n  if (normalized === 'bigserial') {\n    return 'bigint';\n  }\n  if (normalized === 'smallserial') {\n    return 'smallint';\n  }\n\n  // Handle numeric/decimal equivalence\n  if (normalized.startsWith('numeric') || normalized.startsWith('decimal')) {\n    // Extract precision and scale if present\n    const match = normalized.match(/\\((\\d+)(?:,\\s*(\\d+))?\\)/);\n    if (match) {\n      return `numeric(${match[1]}${match[2] ? `,${match[2]}` : ''})`;\n    }\n    return 'numeric';\n  }\n\n  // Handle varchar/character varying\n  if (normalized.startsWith('character varying')) {\n    return normalized.replace('character varying', 'varchar');\n  }\n\n  // Handle text array variations\n  if (normalized === 'text[]' || normalized === '_text') {\n    return 'text[]';\n  }\n\n  return normalized;\n}\n\n/**\n * Helper function to compare two index definitions\n * Returns true if indexes are different and need to be recreated\n */\nfunction isIndexChanged(prevIndex: any, currIndex: any): boolean {\n  // Compare basic properties\n  if (prevIndex.isUnique !== currIndex.isUnique) return true;\n  if (prevIndex.method !== currIndex.method) return true;\n  if (prevIndex.where !== currIndex.where) return true;\n  if (prevIndex.concurrently !== currIndex.concurrently) return true;\n\n  // Compare columns array - must be same columns in same order\n  const prevColumns = prevIndex.columns || [];\n  const currColumns = currIndex.columns || [];\n\n  if (prevColumns.length !== currColumns.length) return true;\n\n  for (let i = 0; i < prevColumns.length; i++) {\n    const prevCol = prevColumns[i];\n    const currCol = currColumns[i];\n\n    // Handle both string columns and expression columns\n    if (typeof prevCol === 'string' && typeof currCol === 'string') {\n      if (prevCol !== currCol) return true;\n    } else if (typeof prevCol === 'object' && typeof currCol === 'object') {\n      // Compare expression columns\n      if (prevCol.expression !== currCol.expression) return true;\n      if (prevCol.isExpression !== currCol.isExpression) return true;\n      if (prevCol.asc !== currCol.asc) return true;\n      if (prevCol.nulls !== currCol.nulls) return true;\n    } else {\n      // Type mismatch (one is string, other is object)\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport interface SchemaDiff {\n  tables: {\n    created: string[];\n    deleted: string[];\n    modified: Array<{\n      name: string;\n      changes: any;\n    }>;\n  };\n  columns: {\n    added: Array<{\n      table: string;\n      column: string;\n      definition: any;\n    }>;\n    deleted: Array<{\n      table: string;\n      column: string;\n    }>;\n    modified: Array<{\n      table: string;\n      column: string;\n      changes: any;\n    }>;\n  };\n  indexes: {\n    created: any[];\n    deleted: any[];\n    altered: Array<{\n      // Indexes with same name but different definition\n      old: any;\n      new: any;\n    }>;\n  };\n  foreignKeys: {\n    created: any[];\n    deleted: any[];\n    altered: Array<{\n      // FKs with modified CASCADE behavior\n      old: any;\n      new: any;\n    }>;\n  };\n  uniqueConstraints: {\n    created: any[];\n    deleted: any[];\n  };\n  checkConstraints: {\n    created: any[];\n    deleted: any[];\n  };\n}\n\n/**\n * Calculate the difference between two snapshots\n */\nexport async function calculateDiff(\n  previousSnapshot: SchemaSnapshot | null,\n  currentSnapshot: SchemaSnapshot\n): Promise<SchemaDiff> {\n  const diff: SchemaDiff = {\n    tables: {\n      created: [],\n      deleted: [],\n      modified: [],\n    },\n    columns: {\n      added: [],\n      deleted: [],\n      modified: [],\n    },\n    indexes: {\n      created: [],\n      deleted: [],\n      altered: [],\n    },\n    foreignKeys: {\n      created: [],\n      deleted: [],\n      altered: [],\n    },\n    uniqueConstraints: {\n      created: [],\n      deleted: [],\n    },\n    checkConstraints: {\n      created: [],\n      deleted: [],\n    },\n  };\n\n  // If no previous snapshot, all tables are new\n  if (!previousSnapshot) {\n    diff.tables.created = Object.keys(currentSnapshot.tables);\n\n    // Also track indexes and foreign keys from new tables\n    for (const tableName in currentSnapshot.tables) {\n      const table = currentSnapshot.tables[tableName];\n\n      // Add indexes\n      if (table.indexes) {\n        for (const indexName in table.indexes) {\n          diff.indexes.created.push({\n            ...table.indexes[indexName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Add foreign keys\n      if (table.foreignKeys) {\n        for (const fkName in table.foreignKeys) {\n          diff.foreignKeys.created.push(table.foreignKeys[fkName]);\n        }\n      }\n    }\n\n    return diff;\n  }\n\n  const prevTables = previousSnapshot.tables || {};\n  const currTables = currentSnapshot.tables || {};\n\n  // Find created tables\n  for (const tableName in currTables) {\n    if (!(tableName in prevTables)) {\n      diff.tables.created.push(tableName);\n\n      const table = currTables[tableName];\n\n      // Add indexes for new table\n      if (table.indexes) {\n        for (const indexName in table.indexes) {\n          diff.indexes.created.push({\n            ...table.indexes[indexName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Add unique constraints for new table\n      if (table.uniqueConstraints) {\n        for (const uqName in table.uniqueConstraints) {\n          diff.uniqueConstraints.created.push({\n            ...table.uniqueConstraints[uqName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Add check constraints for new table\n      if (table.checkConstraints) {\n        for (const checkName in table.checkConstraints) {\n          diff.checkConstraints.created.push({\n            ...table.checkConstraints[checkName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Add foreign keys for new table\n      if (table.foreignKeys) {\n        for (const fkName in table.foreignKeys) {\n          diff.foreignKeys.created.push(table.foreignKeys[fkName]);\n        }\n      }\n    }\n  }\n\n  // Find deleted tables\n  for (const tableName in prevTables) {\n    if (!(tableName in currTables)) {\n      diff.tables.deleted.push(tableName);\n    }\n  }\n\n  // Find modified tables (check columns, indexes, foreign keys)\n  for (const tableName in currTables) {\n    if (tableName in prevTables) {\n      const prevTable = prevTables[tableName];\n      const currTable = currTables[tableName];\n\n      // Early check: if the table schemas are identical, skip it entirely\n      // This prevents false positives when other tables are modified\n      const prevTableJson = JSON.stringify({\n        columns: prevTable.columns || {},\n        indexes: prevTable.indexes || {},\n        foreignKeys: prevTable.foreignKeys || {},\n        uniqueConstraints: prevTable.uniqueConstraints || {},\n        checkConstraints: prevTable.checkConstraints || {},\n      });\n\n      const currTableJson = JSON.stringify({\n        columns: currTable.columns || {},\n        indexes: currTable.indexes || {},\n        foreignKeys: currTable.foreignKeys || {},\n        uniqueConstraints: currTable.uniqueConstraints || {},\n        checkConstraints: currTable.checkConstraints || {},\n      });\n\n      // If tables are identical, skip all processing for this table\n      if (prevTableJson === currTableJson) {\n        continue;\n      }\n\n      // Compare columns\n      const prevColumns = prevTable.columns || {};\n      const currColumns = currTable.columns || {};\n\n      // Find added columns\n      for (const colName in currColumns) {\n        if (!(colName in prevColumns)) {\n          diff.columns.added.push({\n            table: tableName,\n            column: colName,\n            definition: currColumns[colName],\n          });\n        }\n      }\n\n      // Find deleted columns\n      for (const colName in prevColumns) {\n        if (!(colName in currColumns)) {\n          diff.columns.deleted.push({\n            table: tableName,\n            column: colName,\n          });\n        }\n      }\n\n      // Find modified columns\n      for (const colName in currColumns) {\n        if (colName in prevColumns) {\n          const prevCol = prevColumns[colName];\n          const currCol = currColumns[colName];\n\n          // Check for changes in column properties\n          // Use normalized type comparison\n          const typeChanged = normalizeType(prevCol.type) !== normalizeType(currCol.type);\n          const hasChanges =\n            typeChanged ||\n            prevCol.notNull !== currCol.notNull ||\n            prevCol.default !== currCol.default ||\n            prevCol.primaryKey !== currCol.primaryKey;\n\n          if (hasChanges) {\n            diff.columns.modified.push({\n              table: tableName,\n              column: colName,\n              changes: {\n                from: prevCol,\n                to: currCol,\n              },\n            });\n          }\n        }\n      }\n\n      // Compare indexes\n      const prevIndexes = prevTable.indexes || {};\n      const currIndexes = currTable.indexes || {};\n\n      // Find new, deleted, and altered indexes\n      for (const indexName in currIndexes) {\n        if (!(indexName in prevIndexes)) {\n          // New index\n          diff.indexes.created.push({\n            ...currIndexes[indexName],\n            table: tableName,\n          });\n        } else {\n          // Check if index definition changed\n          const prevIndex = prevIndexes[indexName];\n          const currIndex = currIndexes[indexName];\n\n          // Deep comparison of index properties\n          const indexChanged = isIndexChanged(prevIndex, currIndex);\n\n          if (indexChanged) {\n            // Index definition changed - need to drop and recreate\n            diff.indexes.altered.push({\n              old: {\n                ...prevIndex,\n                table: tableName,\n                name: indexName,\n              },\n              new: {\n                ...currIndex,\n                table: tableName,\n                name: indexName,\n              },\n            });\n          }\n        }\n      }\n\n      // Find deleted indexes (not altered)\n      for (const indexName in prevIndexes) {\n        if (!(indexName in currIndexes)) {\n          diff.indexes.deleted.push({\n            name: indexName,\n            table: tableName,\n          });\n        }\n      }\n\n      // Compare unique constraints\n      const prevUniqueConstraints = prevTable.uniqueConstraints || {};\n      const currUniqueConstraints = currTable.uniqueConstraints || {};\n\n      // Find new unique constraints\n      for (const uqName in currUniqueConstraints) {\n        if (!(uqName in prevUniqueConstraints)) {\n          diff.uniqueConstraints.created.push({\n            ...currUniqueConstraints[uqName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Find deleted unique constraints\n      for (const uqName in prevUniqueConstraints) {\n        if (!(uqName in currUniqueConstraints)) {\n          diff.uniqueConstraints.deleted.push({\n            name: uqName,\n            table: tableName,\n          });\n        }\n      }\n\n      // Compare check constraints\n      const prevCheckConstraints = prevTable.checkConstraints || {};\n      const currCheckConstraints = currTable.checkConstraints || {};\n\n      // Find new check constraints\n      for (const checkName in currCheckConstraints) {\n        if (!(checkName in prevCheckConstraints)) {\n          diff.checkConstraints.created.push({\n            ...currCheckConstraints[checkName],\n            table: tableName,\n          });\n        }\n      }\n\n      // Find deleted check constraints\n      for (const checkName in prevCheckConstraints) {\n        if (!(checkName in currCheckConstraints)) {\n          diff.checkConstraints.deleted.push({\n            name: checkName,\n            table: tableName,\n          });\n        }\n      }\n\n      // Compare foreign keys\n      const prevFKs = prevTable.foreignKeys || {};\n      const currFKs = currTable.foreignKeys || {};\n\n      // Find new, deleted, and altered foreign keys\n      for (const fkName in currFKs) {\n        if (!(fkName in prevFKs)) {\n          // New FK\n          diff.foreignKeys.created.push(currFKs[fkName]);\n        } else {\n          // Check if FK definition changed (CASCADE behavior, etc.)\n          const prevFK = prevFKs[fkName];\n          const currFK = currFKs[fkName];\n\n          // Compare FK properties\n          const prevOnDelete = prevFK.onDelete || 'no action';\n          const currOnDelete = currFK.onDelete || 'no action';\n          const prevOnUpdate = prevFK.onUpdate || 'no action';\n          const currOnUpdate = currFK.onUpdate || 'no action';\n\n          if (prevOnDelete !== currOnDelete || prevOnUpdate !== currOnUpdate) {\n            // FK CASCADE behavior changed - need to drop and recreate\n            diff.foreignKeys.altered.push({\n              old: prevFK,\n              new: currFK,\n            });\n          }\n        }\n      }\n\n      // Find deleted foreign keys (not altered)\n      for (const fkName in prevFKs) {\n        if (!(fkName in currFKs)) {\n          diff.foreignKeys.deleted.push({\n            name: fkName,\n            tableFrom: tableName,\n          });\n        }\n      }\n    }\n  }\n\n  return diff;\n}\n\n/**\n * Check if a diff has any changes\n */\nexport function hasDiffChanges(diff: SchemaDiff): boolean {\n  return (\n    diff.tables.created.length > 0 ||\n    diff.tables.deleted.length > 0 ||\n    diff.tables.modified.length > 0 ||\n    diff.columns.added.length > 0 ||\n    diff.columns.deleted.length > 0 ||\n    diff.columns.modified.length > 0 ||\n    diff.indexes.created.length > 0 ||\n    diff.indexes.deleted.length > 0 ||\n    diff.indexes.altered.length > 0 ||\n    diff.foreignKeys.created.length > 0 ||\n    diff.foreignKeys.deleted.length > 0 ||\n    diff.foreignKeys.altered.length > 0 ||\n    diff.uniqueConstraints.created.length > 0 ||\n    diff.uniqueConstraints.deleted.length > 0 ||\n    diff.checkConstraints.created.length > 0 ||\n    diff.checkConstraints.deleted.length > 0\n  );\n}\n",
    "import type { SchemaSnapshot } from '../types';\nimport type { SchemaDiff } from './diff-calculator';\nimport { logger } from '@elizaos/core';\n\n/**\n * Data loss detection result\n * Based on Drizzle's pgPushUtils approach\n */\nexport interface DataLossCheck {\n  hasDataLoss: boolean;\n  tablesToRemove: string[];\n  columnsToRemove: string[];\n  tablesToTruncate: string[];\n  typeChanges: Array<{\n    table: string;\n    column: string;\n    from: string;\n    to: string;\n  }>;\n  warnings: string[];\n  requiresConfirmation: boolean;\n}\n\n/**\n * Check for potential data loss in schema changes\n * Based on Drizzle's pgSuggestions function\n */\nexport function checkForDataLoss(diff: SchemaDiff): DataLossCheck {\n  const result: DataLossCheck = {\n    hasDataLoss: false,\n    tablesToRemove: [],\n    columnsToRemove: [],\n    tablesToTruncate: [],\n    typeChanges: [],\n    warnings: [],\n    requiresConfirmation: false,\n  };\n\n  // Check for table deletions\n  if (diff.tables.deleted.length > 0) {\n    result.hasDataLoss = true;\n    result.requiresConfirmation = true;\n    result.tablesToRemove = [...diff.tables.deleted];\n    for (const table of diff.tables.deleted) {\n      result.warnings.push(`Table \"${table}\" will be dropped with all its data`);\n    }\n  }\n\n  // Check for column deletions\n  if (diff.columns.deleted.length > 0) {\n    result.hasDataLoss = true;\n    result.requiresConfirmation = true;\n    for (const col of diff.columns.deleted) {\n      result.columnsToRemove.push(`${col.table}.${col.column}`);\n      result.warnings.push(`Column \"${col.column}\" in table \"${col.table}\" will be dropped`);\n    }\n  }\n\n  // Check for column type changes that might cause data loss\n  for (const modified of diff.columns.modified) {\n    const from = modified.changes.from;\n    const to = modified.changes.to;\n\n    // Check if type change is destructive\n    if (from.type !== to.type) {\n      const isDestructive = checkIfTypeChangeIsDestructive(from.type, to.type);\n\n      if (isDestructive) {\n        result.hasDataLoss = true;\n        result.requiresConfirmation = true;\n        result.typeChanges.push({\n          table: modified.table,\n          column: modified.column,\n          from: from.type,\n          to: to.type,\n        });\n        result.tablesToTruncate.push(modified.table);\n        result.warnings.push(\n          `Column \"${modified.column}\" in table \"${modified.table}\" changes type from \"${from.type}\" to \"${to.type}\". ` +\n            `This may require truncating the table to avoid data conversion errors.`\n        );\n      }\n    }\n\n    // Check for adding NOT NULL without default to existing column\n    if (!from.notNull && to.notNull && !to.default) {\n      result.hasDataLoss = true;\n      result.requiresConfirmation = true;\n      result.warnings.push(\n        `Column \"${modified.column}\" in table \"${modified.table}\" is becoming NOT NULL without a default value. ` +\n          `This will fail if the table contains NULL values.`\n      );\n    }\n  }\n\n  // Check for adding NOT NULL columns without defaults\n  for (const added of diff.columns.added) {\n    if (added.definition.notNull && !added.definition.default) {\n      // This is only a problem if the table already has data\n      // We'll flag it as a potential issue\n      result.warnings.push(\n        `Column \"${added.column}\" is being added to table \"${added.table}\" as NOT NULL without a default value. ` +\n          `This will fail if the table contains data.`\n      );\n      // Don't set requiresConfirmation here - it's only a warning\n    }\n  }\n\n  return result;\n}\n\n/**\n * Normalize SQL types for comparison\n * Handles equivalent type variations between introspected DB and schema definitions\n */\nfunction normalizeType(type: string | undefined): string {\n  if (!type) return '';\n\n  const normalized = type.toLowerCase().trim();\n\n  // Handle timestamp variations - all are equivalent\n  if (\n    normalized === 'timestamp without time zone' ||\n    normalized === 'timestamp with time zone' ||\n    normalized === 'timestamptz'\n  ) {\n    return 'timestamp';\n  }\n\n  // Handle serial vs integer with identity\n  // serial is essentially integer with auto-increment\n  if (normalized === 'serial') {\n    return 'integer';\n  }\n  if (normalized === 'bigserial') {\n    return 'bigint';\n  }\n  if (normalized === 'smallserial') {\n    return 'smallint';\n  }\n\n  // Handle numeric/decimal equivalence\n  if (normalized.startsWith('numeric') || normalized.startsWith('decimal')) {\n    // Extract precision and scale if present\n    const match = normalized.match(/\\((\\d+)(?:,\\s*(\\d+))?\\)/);\n    if (match) {\n      return `numeric(${match[1]}${match[2] ? `,${match[2]}` : ''})`;\n    }\n    return 'numeric';\n  }\n\n  // Handle varchar/character varying\n  if (normalized.startsWith('character varying')) {\n    return normalized.replace('character varying', 'varchar');\n  }\n\n  // Handle text array variations\n  if (normalized === 'text[]' || normalized === '_text') {\n    return 'text[]';\n  }\n\n  return normalized;\n}\n\n/**\n * Check if a type change is destructive\n * Based on PostgreSQL's type casting rules\n */\nfunction checkIfTypeChangeIsDestructive(fromType: string, toType: string): boolean {\n  // First normalize the types to handle equivalent variations\n  const normalizedFrom = normalizeType(fromType);\n  const normalizedTo = normalizeType(toType);\n\n  // If normalized types match, it's not destructive\n  if (normalizedFrom === normalizedTo) {\n    return false;\n  }\n\n  // Safe conversions (PostgreSQL) - based on Drizzle's logic\n  const safeConversions: Record<string, string[]> = {\n    smallint: ['integer', 'bigint', 'numeric', 'real', 'double precision'],\n    integer: ['bigint', 'numeric', 'real', 'double precision'],\n    bigint: ['numeric'],\n    real: ['double precision'],\n    varchar: ['text'],\n    char: ['varchar', 'text'],\n    citext: ['text'],\n    text: ['citext'],\n    // UUID to text is safe\n    uuid: ['text', 'varchar'],\n    // Timestamp variations are generally safe (now handled by normalization)\n    timestamp: ['timestamp'], // Simplified since normalization handles variations\n    // Date/time conversions\n    date: ['timestamp'],\n    time: ['timetz'],\n  };\n\n  const fromBase = normalizedFrom.split('(')[0];\n  const toBase = normalizedTo.split('(')[0];\n\n  // Same type is always safe\n  if (fromBase === toBase) {\n    return false;\n  }\n\n  // Check if it's a safe conversion\n  const safeTo = safeConversions[fromBase];\n  if (safeTo && safeTo.includes(toBase)) {\n    return false;\n  }\n\n  // All other conversions are considered potentially destructive\n  return true;\n}\n\n/**\n * Generate SQL statements from a schema diff\n * This follows Drizzle's approach: create all tables first, then add foreign keys\n */\nexport async function generateMigrationSQL(\n  previousSnapshot: SchemaSnapshot | null,\n  currentSnapshot: SchemaSnapshot,\n  diff?: SchemaDiff\n): Promise<string[]> {\n  const statements: string[] = [];\n\n  // If no diff provided, calculate it\n  if (!diff) {\n    const { calculateDiff } = await import('./diff-calculator');\n    diff = await calculateDiff(previousSnapshot, currentSnapshot);\n  }\n\n  // Check for data loss\n  const dataLossCheck = checkForDataLoss(diff);\n\n  // Log warnings if any\n  if (dataLossCheck.warnings.length > 0) {\n    logger.warn('[RuntimeMigrator] Schema changes may cause data loss:');\n    for (const warning of dataLossCheck.warnings) {\n      logger.warn(`  - ${warning}`);\n    }\n  }\n\n  // Phase 1: Collect unique schemas and create them first\n  const schemasToCreate = new Set<string>();\n  for (const tableName of diff.tables.created) {\n    const table = currentSnapshot.tables[tableName];\n    if (table) {\n      const schema = table.schema || 'public';\n      if (schema !== 'public') {\n        schemasToCreate.add(schema);\n      }\n    }\n  }\n\n  // Create schemas first (following drizzle-kit pattern)\n  for (const schema of schemasToCreate) {\n    statements.push(`CREATE SCHEMA IF NOT EXISTS \"${schema}\";`);\n  }\n\n  // Phase 2: Generate CREATE TABLE statements for new tables (WITHOUT foreign keys)\n  const createTableStatements: string[] = [];\n  const foreignKeyStatements: string[] = [];\n\n  for (const tableName of diff.tables.created) {\n    const table = currentSnapshot.tables[tableName];\n    if (table) {\n      const { tableSQL, fkSQLs } = generateCreateTableSQL(tableName, table);\n      createTableStatements.push(tableSQL);\n      foreignKeyStatements.push(...fkSQLs);\n    }\n  }\n\n  // Add all CREATE TABLE statements\n  statements.push(...createTableStatements);\n\n  // Phase 3: Add all foreign keys AFTER tables are created\n  // Deduplicate foreign key statements to avoid duplicate constraints\n  const uniqueFKs = new Set<string>();\n  const dedupedFKStatements: string[] = [];\n\n  for (const fkSQL of foreignKeyStatements) {\n    // Extract constraint name to check for duplicates\n    const match = fkSQL.match(/ADD CONSTRAINT \"([^\"]+)\"/);\n    if (match) {\n      const constraintName = match[1];\n      if (!uniqueFKs.has(constraintName)) {\n        uniqueFKs.add(constraintName);\n        dedupedFKStatements.push(fkSQL);\n      }\n    } else {\n      dedupedFKStatements.push(fkSQL);\n    }\n  }\n\n  statements.push(...dedupedFKStatements);\n\n  // Phase 4: Handle table modifications\n\n  // Generate DROP TABLE statements for deleted tables\n  for (const tableName of diff.tables.deleted) {\n    const [schema, name] = tableName.includes('.') ? tableName.split('.') : ['public', tableName];\n    statements.push(`DROP TABLE IF EXISTS \"${schema}\".\"${name}\" CASCADE;`);\n  }\n\n  // Generate ALTER TABLE statements for column changes\n  // Handle column additions\n  for (const added of diff.columns.added) {\n    statements.push(generateAddColumnSQL(added.table, added.column, added.definition));\n  }\n\n  // Handle column deletions\n  for (const deleted of diff.columns.deleted) {\n    statements.push(generateDropColumnSQL(deleted.table, deleted.column));\n  }\n\n  // Handle column modifications\n  for (const modified of diff.columns.modified) {\n    const alterStatements = generateAlterColumnSQL(\n      modified.table,\n      modified.column,\n      modified.changes\n    );\n    statements.push(...alterStatements);\n  }\n\n  // Generate DROP INDEX statements (including altered ones - drop old version)\n  for (const index of diff.indexes.deleted) {\n    statements.push(generateDropIndexSQL(index));\n  }\n\n  // Drop old version of altered indexes\n  for (const alteredIndex of diff.indexes.altered) {\n    statements.push(generateDropIndexSQL(alteredIndex.old));\n  }\n\n  // Generate CREATE INDEX statements (including altered ones - create new version)\n  for (const index of diff.indexes.created) {\n    statements.push(generateCreateIndexSQL(index));\n  }\n\n  // Create new version of altered indexes\n  for (const alteredIndex of diff.indexes.altered) {\n    statements.push(generateCreateIndexSQL(alteredIndex.new));\n  }\n\n  // Generate CREATE UNIQUE CONSTRAINT statements\n  for (const constraint of diff.uniqueConstraints.created) {\n    // Skip if it's part of a new table (already handled)\n    const isNewTable = diff.tables.created.some((tableName) => {\n      const [schema, table] = tableName.includes('.')\n        ? tableName.split('.')\n        : ['public', tableName];\n      const constraintTable = constraint.table || '';\n      const [constraintSchema, constraintTableName] = constraintTable.includes('.')\n        ? constraintTable.split('.')\n        : ['public', constraintTable];\n      return table === constraintTableName && schema === constraintSchema;\n    });\n\n    if (!isNewTable) {\n      statements.push(generateCreateUniqueConstraintSQL(constraint));\n    }\n  }\n\n  // Generate DROP UNIQUE CONSTRAINT statements\n  for (const constraint of diff.uniqueConstraints.deleted) {\n    statements.push(generateDropUniqueConstraintSQL(constraint));\n  }\n\n  // Generate CREATE CHECK CONSTRAINT statements\n  for (const constraint of diff.checkConstraints.created) {\n    // Skip if it's part of a new table (already handled)\n    const isNewTable = diff.tables.created.some((tableName) => {\n      const [schema, table] = tableName.includes('.')\n        ? tableName.split('.')\n        : ['public', tableName];\n      const constraintTable = constraint.table || '';\n      const [constraintSchema, constraintTableName] = constraintTable.includes('.')\n        ? constraintTable.split('.')\n        : ['public', constraintTable];\n      return table === constraintTableName && schema === constraintSchema;\n    });\n\n    if (!isNewTable) {\n      statements.push(generateCreateCheckConstraintSQL(constraint));\n    }\n  }\n\n  // Generate DROP CHECK CONSTRAINT statements\n  for (const constraint of diff.checkConstraints.deleted) {\n    statements.push(generateDropCheckConstraintSQL(constraint));\n  }\n\n  // Handle foreign key deletions first (including altered ones)\n  for (const fk of diff.foreignKeys.deleted) {\n    statements.push(generateDropForeignKeySQL(fk));\n  }\n\n  // Drop old version of altered foreign keys\n  for (const alteredFK of diff.foreignKeys.altered) {\n    statements.push(generateDropForeignKeySQL(alteredFK.old));\n  }\n\n  // Handle foreign key creations (for existing tables)\n  for (const fk of diff.foreignKeys.created) {\n    // Only add if it's not part of a new table (those were handled above)\n    // Check both with and without schema prefix\n    const tableFrom = fk.tableFrom || '';\n    const schemaFrom = fk.schemaFrom || 'public';\n\n    const isNewTable = diff.tables.created.some((tableName) => {\n      // Compare table names, handling schema prefixes\n      const [createdSchema, createdTable] = tableName.includes('.')\n        ? tableName.split('.')\n        : ['public', tableName];\n\n      // Compare using the actual schema and table from the FK\n      return createdTable === tableFrom && createdSchema === schemaFrom;\n    });\n\n    if (!isNewTable) {\n      statements.push(generateCreateForeignKeySQL(fk));\n    }\n  }\n\n  // Create new version of altered foreign keys\n  for (const alteredFK of diff.foreignKeys.altered) {\n    statements.push(generateCreateForeignKeySQL(alteredFK.new));\n  }\n\n  return statements;\n}\n\n/**\n * Generate CREATE TABLE SQL (following Drizzle's pattern)\n * Returns the table creation SQL and separate foreign key SQLs\n */\nfunction generateCreateTableSQL(\n  fullTableName: string,\n  table: any\n): { tableSQL: string; fkSQLs: string[] } {\n  const [schema, tableName] = fullTableName.includes('.')\n    ? fullTableName.split('.')\n    : ['public', fullTableName];\n  const columns: string[] = [];\n  const fkSQLs: string[] = [];\n\n  // Add columns\n  for (const [colName, colDef] of Object.entries(table.columns || {})) {\n    columns.push(generateColumnDefinition(colName, colDef as any));\n  }\n\n  // Add composite primary keys if exists\n  const primaryKeys = table.compositePrimaryKeys || {};\n  for (const [pkName, pkDef] of Object.entries(primaryKeys)) {\n    const pk = pkDef as any;\n    if (pk.columns && pk.columns.length > 0) {\n      columns.push(\n        `CONSTRAINT \"${pkName}\" PRIMARY KEY (${pk.columns.map((c: string) => `\"${c}\"`).join(', ')})`\n      );\n    }\n  }\n\n  // Add unique constraints\n  const uniqueConstraints = table.uniqueConstraints || {};\n  for (const [uqName, uqDef] of Object.entries(uniqueConstraints)) {\n    const uq = uqDef as any;\n    if (uq.columns && uq.columns.length > 0) {\n      const uniqueDef = uq.nullsNotDistinct\n        ? `CONSTRAINT \"${uqName}\" UNIQUE NULLS NOT DISTINCT (${uq.columns.map((c: string) => `\"${c}\"`).join(', ')})`\n        : `CONSTRAINT \"${uqName}\" UNIQUE (${uq.columns.map((c: string) => `\"${c}\"`).join(', ')})`;\n      columns.push(uniqueDef);\n    }\n  }\n\n  // Add check constraints\n  const checkConstraints = table.checkConstraints || {};\n  for (const [checkName, checkDef] of Object.entries(checkConstraints)) {\n    const check = checkDef as any;\n    if (check.value) {\n      columns.push(`CONSTRAINT \"${checkName}\" CHECK (${check.value})`);\n    }\n  }\n\n  // Following drizzle-kit pattern: don't create schema here, it's handled separately\n  const tableSQL = `CREATE TABLE IF NOT EXISTS \"${schema}\".\"${tableName}\" (\\n  ${columns.join(',\\n  ')}\\n);`;\n\n  // Collect foreign keys to be added AFTER all tables are created\n  const foreignKeys = table.foreignKeys || {};\n  for (const [fkName, fkDef] of Object.entries(foreignKeys)) {\n    const fk = fkDef as any;\n    const fkSQL = `ALTER TABLE \"${schema}\".\"${tableName}\" ADD CONSTRAINT \"${fkName}\" FOREIGN KEY (${fk.columnsFrom.map((c: string) => `\"${c}\"`).join(', ')}) REFERENCES \"${fk.schemaTo || 'public'}\".\"${fk.tableTo}\" (${fk.columnsTo.map((c: string) => `\"${c}\"`).join(', ')})${fk.onDelete ? ` ON DELETE ${fk.onDelete}` : ''}${fk.onUpdate ? ` ON UPDATE ${fk.onUpdate}` : ''};`;\n    fkSQLs.push(fkSQL);\n  }\n\n  return { tableSQL, fkSQLs };\n}\n\n/**\n * Generate column definition (following Drizzle's pattern)\n */\nfunction generateColumnDefinition(name: string, def: any): string {\n  let sql = `\"${name}\" ${def.type}`;\n\n  // Handle primary key that's not part of composite\n  if (def.primaryKey && !def.type.includes('SERIAL')) {\n    sql += ' PRIMARY KEY';\n  }\n\n  // Add NOT NULL constraint\n  if (def.notNull) {\n    sql += ' NOT NULL';\n  }\n\n  // Add DEFAULT value - properly formatted\n  if (def.default !== undefined) {\n    const defaultValue = formatDefaultValue(def.default, def.type);\n    sql += ` DEFAULT ${defaultValue}`;\n  }\n\n  return sql;\n}\n\n/**\n * Generate ALTER TABLE ADD COLUMN SQL\n * Based on Drizzle's PgAlterTableAddColumnConvertor\n */\nfunction generateAddColumnSQL(table: string, column: string, definition: any): string {\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n  const tableNameWithSchema = `\"${schema}\".\"${tableName}\"`;\n\n  // Build column definition parts in the correct order (like Drizzle)\n  const parts: string[] = [`\"${column}\"`];\n\n  // Type\n  parts.push(definition.type);\n\n  // Primary key\n  if (definition.primaryKey) {\n    parts.push('PRIMARY KEY');\n  }\n\n  // Default value - needs proper formatting based on type\n  if (definition.default !== undefined) {\n    const defaultValue = formatDefaultValue(definition.default, definition.type);\n    if (defaultValue) {\n      parts.push(`DEFAULT ${defaultValue}`);\n    }\n  }\n\n  // Generated columns\n  if (definition.generated) {\n    parts.push(`GENERATED ALWAYS AS (${definition.generated}) STORED`);\n  }\n\n  // NOT NULL constraint - comes after DEFAULT\n  if (definition.notNull) {\n    parts.push('NOT NULL');\n  }\n\n  return `ALTER TABLE ${tableNameWithSchema} ADD COLUMN ${parts.join(' ')};`;\n}\n\n/**\n * Generate ALTER TABLE DROP COLUMN SQL\n * Based on Drizzle's approach with CASCADE\n */\nfunction generateDropColumnSQL(table: string, column: string): string {\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n  const tableNameWithSchema = `\"${schema}\".\"${tableName}\"`;\n  // Use CASCADE to handle dependent objects\n  return `ALTER TABLE ${tableNameWithSchema} DROP COLUMN \"${column}\" CASCADE;`;\n}\n\n/**\n * Generate ALTER TABLE ALTER COLUMN SQL\n * Based on Drizzle's approach with proper type casting and handling\n */\nfunction generateAlterColumnSQL(table: string, column: string, changes: any): string[] {\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n  const tableNameWithSchema = `\"${schema}\".\"${tableName}\"`;\n  const statements: string[] = [];\n\n  // Handle type changes - need to handle enums and complex types\n  if (changes.to?.type !== changes.from?.type) {\n    const newType = changes.to?.type || 'TEXT';\n\n    // Check if we need a USING clause for type conversion\n    const needsUsing = checkIfNeedsUsingClause(changes.from?.type, newType);\n\n    if (needsUsing) {\n      // For complex type changes, use USING clause like Drizzle\n      statements.push(\n        `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" TYPE ${newType} USING \"${column}\"::text::${newType};`\n      );\n    } else {\n      statements.push(\n        `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" SET DATA TYPE ${newType};`\n      );\n    }\n  }\n\n  // Handle NOT NULL changes\n  if (changes.to?.notNull !== changes.from?.notNull) {\n    if (changes.to?.notNull) {\n      // When adding NOT NULL, might need to set defaults for existing NULL values\n      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" SET NOT NULL;`);\n    } else {\n      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" DROP NOT NULL;`);\n    }\n  }\n\n  // Handle default value changes\n  if (changes.to?.default !== changes.from?.default) {\n    if (changes.to?.default !== undefined) {\n      const defaultValue = formatDefaultValue(changes.to.default, changes.to?.type);\n      statements.push(\n        `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" SET DEFAULT ${defaultValue};`\n      );\n    } else {\n      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN \"${column}\" DROP DEFAULT;`);\n    }\n  }\n\n  return statements;\n}\n\n/**\n * Check if a type change needs a USING clause\n * Based on Drizzle's type conversion logic\n */\nfunction checkIfNeedsUsingClause(fromType: string, toType: string): boolean {\n  if (!fromType || !toType) return false;\n\n  // Enum changes always need USING\n  if (fromType.includes('enum') || toType.includes('enum')) {\n    return true;\n  }\n\n  const fromBase = fromType.split('(')[0].toLowerCase();\n  const toBase = toType.split('(')[0].toLowerCase();\n\n  // Text/varchar to JSONB always needs USING\n  if (\n    (fromBase === 'text' || fromBase === 'varchar' || fromBase === 'character varying') &&\n    (toBase === 'jsonb' || toBase === 'json')\n  ) {\n    return true;\n  }\n\n  // Some specific type conversions need USING\n  const needsUsingPairs = [\n    ['integer', 'boolean'],\n    ['boolean', 'integer'],\n    ['text', 'integer'],\n    ['text', 'numeric'],\n    ['text', 'boolean'],\n    ['text', 'uuid'],\n    ['text', 'jsonb'],\n    ['text', 'json'],\n    ['varchar', 'integer'],\n    ['varchar', 'numeric'],\n    ['varchar', 'boolean'],\n    ['varchar', 'uuid'],\n    ['varchar', 'jsonb'],\n    ['varchar', 'json'],\n    ['character varying', 'jsonb'],\n    ['character varying', 'json'],\n    // Add more as needed based on PostgreSQL casting rules\n  ];\n\n  for (const [from, to] of needsUsingPairs) {\n    if ((fromBase === from && toBase === to) || (fromBase === to && toBase === from)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Format a default value for SQL\n * Based on Drizzle's default value formatting\n */\nfunction formatDefaultValue(value: any, type: string): string {\n  // Handle NULL\n  if (value === null || value === 'NULL') {\n    return 'NULL';\n  }\n\n  // Handle boolean\n  if (type && (type.toLowerCase().includes('boolean') || type.toLowerCase() === 'bool')) {\n    if (value === true || value === 'true' || value === 't' || value === 1) {\n      return 'true';\n    }\n    if (value === false || value === 'false' || value === 'f' || value === 0) {\n      return 'false';\n    }\n  }\n\n  // Handle numeric types\n  if (type && type.match(/^(integer|bigint|smallint|numeric|decimal|real|double)/i)) {\n    return String(value);\n  }\n\n  // Handle SQL expressions and pre-formatted defaults\n  if (typeof value === 'string') {\n    // Already formatted with type cast (e.g., '[]'::jsonb, '{}'::jsonb)\n    // These come from the snapshot and are already properly formatted\n    if (value.includes('::')) {\n      return value;\n    }\n\n    // Already quoted string literals (from snapshot)\n    // These start and end with single quotes\n    if (value.startsWith(\"'\") && value.endsWith(\"'\")) {\n      return value;\n    }\n\n    // SQL functions like now(), gen_random_uuid(), etc.\n    if (value.match(/^\\w+\\(\\)/i) || (value.includes('(') && value.includes(')'))) {\n      return value;\n    }\n\n    // SQL expressions starting with CURRENT_\n    if (value.toUpperCase().startsWith('CURRENT_')) {\n      return value;\n    }\n\n    // Otherwise, it's an unquoted string literal - wrap and escape\n    return `'${value.replace(/'/g, \"''\")}'`;\n  }\n\n  // Default: return as-is\n  return String(value);\n}\n\n/**\n * Generate CREATE INDEX SQL\n */\nfunction generateCreateIndexSQL(index: any): string {\n  const unique = index.isUnique ? 'UNIQUE ' : '';\n  const method = index.method || 'btree';\n  const columns = index.columns\n    .map((c: any) => {\n      if (c.isExpression) {\n        return c.expression;\n      }\n      // Only add DESC if explicitly set to false, no NULLS clause by default\n      return `\"${c.expression}\"${c.asc === false ? ' DESC' : ''}`;\n    })\n    .join(', ');\n\n  // Extract index name and table with proper schema handling\n  const indexName = index.name.includes('.') ? index.name.split('.')[1] : index.name;\n\n  // Keep the full table name with schema if present\n  let tableRef: string;\n  if (index.table && index.table.includes('.')) {\n    const [schema, table] = index.table.split('.');\n    tableRef = `\"${schema}\".\"${table}\"`;\n  } else {\n    tableRef = `\"${index.table || ''}\"`;\n  }\n\n  // Include schema in table reference for correct index creation\n  return `CREATE ${unique}INDEX \"${indexName}\" ON ${tableRef} USING ${method} (${columns});`;\n}\n\n/**\n * Generate DROP INDEX SQL\n */\nfunction generateDropIndexSQL(index: any): string {\n  // Extract just the index name without schema\n  const indexName = index.name\n    ? index.name.includes('.')\n      ? index.name.split('.')[1]\n      : index.name\n    : index;\n  // Match Drizzle's format - no schema qualification\n  return `DROP INDEX IF EXISTS \"${indexName}\";`;\n}\n\n/**\n * Generate CREATE FOREIGN KEY SQL (for existing tables)\n */\nfunction generateCreateForeignKeySQL(fk: any): string {\n  const schemaFrom = fk.schemaFrom || 'public';\n  const schemaTo = fk.schemaTo || 'public';\n  const tableFrom = fk.tableFrom;\n  const columnsFrom = fk.columnsFrom.map((c: string) => `\"${c}\"`).join(', ');\n  const columnsTo = fk.columnsTo.map((c: string) => `\"${c}\"`).join(', ');\n\n  let sql = `ALTER TABLE \"${schemaFrom}\".\"${tableFrom}\" ADD CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnsFrom}) REFERENCES \"${schemaTo}\".\"${fk.tableTo}\" (${columnsTo})`;\n\n  if (fk.onDelete) {\n    sql += ` ON DELETE ${fk.onDelete}`;\n  }\n\n  if (fk.onUpdate) {\n    sql += ` ON UPDATE ${fk.onUpdate}`;\n  }\n\n  return sql + ';';\n}\n\n/**\n * Generate DROP FOREIGN KEY SQL\n */\nfunction generateDropForeignKeySQL(fk: any): string {\n  const [schema, tableName] = fk.tableFrom\n    ? fk.tableFrom.includes('.')\n      ? fk.tableFrom.split('.')\n      : ['public', fk.tableFrom]\n    : ['public', ''];\n  return `ALTER TABLE \"${schema}\".\"${tableName}\" DROP CONSTRAINT \"${fk.name}\";`;\n}\n\n/**\n * Generate SQL for renaming a table\n */\nexport function generateRenameTableSQL(oldName: string, newName: string): string {\n  const [oldSchema, oldTable] = oldName.includes('.') ? oldName.split('.') : ['public', oldName];\n  const [, newTable] = newName.includes('.') ? newName.split('.') : ['public', newName];\n  return `ALTER TABLE \"${oldSchema}\".\"${oldTable}\" RENAME TO \"${newTable}\";`;\n}\n\n/**\n * Generate SQL for renaming a column\n */\nexport function generateRenameColumnSQL(table: string, oldName: string, newName: string): string {\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n  return `ALTER TABLE \"${schema}\".\"${tableName}\" RENAME COLUMN \"${oldName}\" TO \"${newName}\";`;\n}\n\n/**\n * Generate CREATE UNIQUE CONSTRAINT SQL\n */\nfunction generateCreateUniqueConstraintSQL(constraint: any): string {\n  const table = constraint.table || '';\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n\n  const name = constraint.name;\n  const columns = constraint.columns.map((c: string) => `\"${c}\"`).join(', ');\n\n  let sql = `ALTER TABLE \"${schema}\".\"${tableName}\" ADD CONSTRAINT \"${name}\" UNIQUE`;\n\n  // Handle NULLS NOT DISTINCT if specified (PostgreSQL 15+)\n  if (constraint.nullsNotDistinct) {\n    sql += ` NULLS NOT DISTINCT`;\n  }\n\n  sql += ` (${columns});`;\n\n  return sql;\n}\n\n/**\n * Generate DROP UNIQUE CONSTRAINT SQL\n */\nfunction generateDropUniqueConstraintSQL(constraint: any): string {\n  const table = constraint.table || '';\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n\n  return `ALTER TABLE \"${schema}\".\"${tableName}\" DROP CONSTRAINT \"${constraint.name}\";`;\n}\n\n/**\n * Generate CREATE CHECK CONSTRAINT SQL\n */\nfunction generateCreateCheckConstraintSQL(constraint: any): string {\n  const table = constraint.table || '';\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n\n  const name = constraint.name;\n  const value = constraint.value;\n\n  return `ALTER TABLE \"${schema}\".\"${tableName}\" ADD CONSTRAINT \"${name}\" CHECK (${value});`;\n}\n\n/**\n * Generate DROP CHECK CONSTRAINT SQL\n */\nfunction generateDropCheckConstraintSQL(constraint: any): string {\n  const table = constraint.table || '';\n  const [schema, tableName] = table.includes('.') ? table.split('.') : ['public', table];\n\n  return `ALTER TABLE \"${schema}\".\"${tableName}\" DROP CONSTRAINT \"${constraint.name}\";`;\n}\n",
    "import { pgSchema } from 'drizzle-orm/pg-core';\nimport { getTableConfig } from 'drizzle-orm/pg-core';\nimport { logger } from '@elizaos/core';\n\n/**\n * Transform a plugin's schema to use the appropriate namespace\n *\n * @elizaos/plugin-sql uses 'public' schema (no transformation)\n * Other plugins get their tables wrapped in a namespaced schema\n */\nexport function transformPluginSchema(pluginName: string, schema: any): any {\n  // Core plugin uses public schema - no transformation needed\n  if (pluginName === '@elizaos/plugin-sql') {\n    return schema;\n  }\n\n  // Derive schema name from plugin name\n  const schemaName = deriveSchemaName(pluginName);\n\n  // If schema is already using pgSchema, return as-is\n  if (isAlreadyNamespaced(schema, schemaName)) {\n    logger.debug(`[SchemaTransformer] Plugin '${pluginName}' already uses schema '${schemaName}'`);\n    return schema;\n  }\n\n  logger.info(\n    `[SchemaTransformer] Transforming plugin '${pluginName}' to use schema '${schemaName}'`\n  );\n\n  // Transform the schema object\n  const transformed: any = {};\n\n  for (const [key, value] of Object.entries(schema)) {\n    if (isPgTable(value)) {\n      // Get the table configuration\n      const config = getTableConfig(value as any);\n\n      // If the table doesn't have a schema or is in public, warn about it\n      if (!config.schema || config.schema === 'public') {\n        // Note: We can't easily transform existing tables to use a different schema\n        // as it would require reconstructing all column definitions, constraints, etc.\n        // For now, we'll log a warning and return the original\n        logger.warn(\n          `[SchemaTransformer] Table '${config.name}' in plugin '${pluginName}' should use pgSchema('${schemaName}').table(...) ` +\n            `for proper isolation. Manual migration may be required.`\n        );\n        transformed[key] = value;\n      } else {\n        // Table already has a schema, keep it as-is\n        transformed[key] = value;\n      }\n    } else if (typeof value === 'object' && value !== null) {\n      // Check if this is a schema object (created with pgSchema)\n      // Cast to any to access properties since we're doing runtime checks\n      const obj = value as any;\n      if (obj._schema && obj.table) {\n        // This is already a pgSchema object, keep it\n        transformed[key] = value;\n      } else {\n        // Regular object, keep as-is\n        transformed[key] = value;\n      }\n    } else {\n      // Not a table, keep as-is\n      transformed[key] = value;\n    }\n  }\n\n  return transformed;\n}\n\n/**\n * Derive a valid PostgreSQL schema name from a plugin name\n */\nexport function deriveSchemaName(pluginName: string): string {\n  // Remove common prefixes and convert to lowercase with underscores\n  let schemaName = pluginName\n    .replace(/^@[^/]+\\//, '') // Remove npm scope like @elizaos/\n    .replace(/^plugin-/, '') // Remove plugin- prefix\n    .toLowerCase();\n\n  // Replace non-alphanumeric characters with underscores (avoid polynomial regex)\n  schemaName = normalizeSchemaName(schemaName);\n\n  // Ensure schema name is valid (not empty, not a reserved word)\n  const reserved = ['public', 'pg_catalog', 'information_schema', 'migrations'];\n  if (!schemaName || reserved.includes(schemaName)) {\n    // Fallback to using the full plugin name with safe characters\n    schemaName = 'plugin_' + normalizeSchemaName(pluginName.toLowerCase());\n  }\n\n  // Ensure it starts with a letter (PostgreSQL requirement)\n  if (!/^[a-z]/.test(schemaName)) {\n    schemaName = 'p_' + schemaName;\n  }\n\n  // Truncate if too long (PostgreSQL identifier limit is 63 chars)\n  if (schemaName.length > 63) {\n    schemaName = schemaName.substring(0, 63);\n  }\n\n  return schemaName;\n}\n\n/**\n * Normalize a string to be a valid PostgreSQL identifier\n * Avoids polynomial regex by using string manipulation instead\n */\nfunction normalizeSchemaName(input: string): string {\n  const chars: string[] = [];\n  let prevWasUnderscore = false;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n\n    if (/[a-z0-9]/.test(char)) {\n      chars.push(char);\n      prevWasUnderscore = false;\n    } else if (!prevWasUnderscore) {\n      // Only add underscore if previous char wasn't already an underscore\n      chars.push('_');\n      prevWasUnderscore = true;\n    }\n    // Skip consecutive non-alphanumeric characters\n  }\n\n  // Remove leading and trailing underscores\n  const result = chars.join('');\n\n  // Trim underscores from start and end efficiently\n  let start = 0;\n  let end = result.length;\n\n  while (start < end && result[start] === '_') {\n    start++;\n  }\n\n  while (end > start && result[end - 1] === '_') {\n    end--;\n  }\n\n  return result.slice(start, end);\n}\n\n/**\n * Check if a value is a PgTable\n */\nfunction isPgTable(value: any): boolean {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  // Check for table-like properties\n  // This is a heuristic since we can't use instanceof across module boundaries\n  try {\n    const config = getTableConfig(value);\n    return config && typeof config.name === 'string';\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if a schema is already properly namespaced\n */\nfunction isAlreadyNamespaced(schema: any, expectedSchemaName: string): boolean {\n  for (const value of Object.values(schema)) {\n    if (isPgTable(value)) {\n      try {\n        const config = getTableConfig(value as any);\n        if (config.schema === expectedSchemaName) {\n          return true;\n        }\n      } catch {\n        // Not a table, continue\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Create a namespaced schema helper for plugins\n * This is what plugins should ideally use to define their tables\n */\nexport function createPluginSchema(pluginName: string) {\n  const schemaName = deriveSchemaName(pluginName);\n  return pgSchema(schemaName);\n}\n",
    "import { sql } from 'drizzle-orm';\nimport { logger } from '@elizaos/core';\nimport type { DrizzleDB, SchemaSnapshot } from '../types';\n\n/**\n * Introspect the current database state and generate a snapshot\n * This is used when no previous snapshot exists for a plugin\n * to capture the existing database state before migrations\n */\nexport class DatabaseIntrospector {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Introspect all tables in the database and generate a snapshot\n   * @param schemaName - Schema to introspect (default: 'public')\n   * @returns Schema snapshot of current database state\n   */\n  async introspectSchema(schemaName: string = 'public'): Promise<SchemaSnapshot> {\n    logger.info(`[DatabaseIntrospector] Starting introspection for schema: ${schemaName}`);\n\n    const tables: any = {};\n    const schemas: any = {};\n    const enums: any = {};\n\n    // Get all tables in the schema\n    const allTables = await this.getTables(schemaName);\n\n    for (const tableInfo of allTables) {\n      const tableName = tableInfo.table_name;\n      const tableSchema = tableInfo.table_schema || 'public';\n\n      logger.debug(`[DatabaseIntrospector] Introspecting table: ${tableSchema}.${tableName}`);\n\n      // Get columns for this table\n      const columns = await this.getColumns(tableSchema, tableName);\n      const columnsObject: any = {};\n      const uniqueConstraintObject: any = {};\n\n      for (const col of columns) {\n        columnsObject[col.column_name] = {\n          name: col.column_name,\n          type: col.data_type,\n          primaryKey: col.is_primary || false,\n          notNull: col.is_nullable === 'NO',\n          default: col.column_default\n            ? this.parseDefault(col.column_default, col.data_type)\n            : undefined,\n        };\n      }\n\n      // Get indexes\n      const indexes = await this.getIndexes(tableSchema, tableName);\n      const indexesObject: any = {};\n\n      for (const idx of indexes) {\n        if (!idx.is_primary && !idx.is_unique_constraint) {\n          // Skip primary keys and unique constraints\n          indexesObject[idx.name] = {\n            name: idx.name,\n            columns: idx.columns.map((col) => ({\n              expression: col,\n              isExpression: false,\n            })),\n            isUnique: idx.is_unique,\n            method: idx.method || 'btree',\n          };\n        }\n      }\n\n      // Get foreign keys\n      const foreignKeys = await this.getForeignKeys(tableSchema, tableName);\n      const foreignKeysObject: any = {};\n\n      for (const fk of foreignKeys) {\n        foreignKeysObject[fk.name] = {\n          name: fk.name,\n          tableFrom: tableName,\n          schemaFrom: tableSchema,\n          tableTo: fk.foreign_table_name,\n          schemaTo: fk.foreign_table_schema || 'public',\n          columnsFrom: [fk.column_name],\n          columnsTo: [fk.foreign_column_name],\n          onDelete: fk.delete_rule?.toLowerCase() || 'no action',\n          onUpdate: fk.update_rule?.toLowerCase() || 'no action',\n        };\n      }\n\n      // Get primary keys\n      const primaryKeys = await this.getPrimaryKeys(tableSchema, tableName);\n      const primaryKeysObject: any = {};\n\n      for (const pk of primaryKeys) {\n        primaryKeysObject[pk.name] = {\n          name: pk.name,\n          columns: pk.columns,\n        };\n      }\n\n      // Get unique constraints\n      const uniqueConstraints = await this.getUniqueConstraints(tableSchema, tableName);\n\n      for (const unq of uniqueConstraints) {\n        uniqueConstraintObject[unq.name] = {\n          name: unq.name,\n          columns: unq.columns,\n          nullsNotDistinct: false, // Default value\n        };\n      }\n\n      // Get check constraints\n      const checkConstraints = await this.getCheckConstraints(tableSchema, tableName);\n      const checksObject: any = {};\n\n      for (const check of checkConstraints) {\n        checksObject[check.name] = {\n          name: check.name,\n          value: check.definition,\n        };\n      }\n\n      // Build the table object\n      tables[`${tableSchema}.${tableName}`] = {\n        name: tableName,\n        schema: tableSchema,\n        columns: columnsObject,\n        indexes: indexesObject,\n        foreignKeys: foreignKeysObject,\n        compositePrimaryKeys: primaryKeysObject,\n        uniqueConstraints: uniqueConstraintObject,\n        checkConstraints: checksObject,\n      };\n\n      // Track schemas\n      if (tableSchema && tableSchema !== 'public') {\n        schemas[tableSchema] = tableSchema;\n      }\n    }\n\n    // Get enums if any\n    const enumsResult = await this.getEnums(schemaName);\n    for (const enumInfo of enumsResult) {\n      const key = `${enumInfo.schema}.${enumInfo.name}`;\n      if (!enums[key]) {\n        enums[key] = {\n          name: enumInfo.name,\n          schema: enumInfo.schema,\n          values: [],\n        };\n      }\n      enums[key].values.push(enumInfo.value);\n    }\n\n    logger.info(\n      `[DatabaseIntrospector] Introspection complete. Found ${Object.keys(tables).length} tables`\n    );\n\n    return {\n      version: '7',\n      dialect: 'postgresql',\n      tables,\n      schemas,\n      enums,\n      _meta: {\n        schemas: {},\n        tables: {},\n        columns: {},\n      },\n    };\n  }\n\n  /**\n   * Get all tables in a schema\n   */\n  private async getTables(schemaName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            table_schema,\n            table_name\n          FROM information_schema.tables\n          WHERE table_schema = ${schemaName}\n            AND table_type = 'BASE TABLE'\n          ORDER BY table_name`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get columns for a table\n   */\n  private async getColumns(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            a.attname AS column_name,\n            CASE \n              WHEN a.attnotnull THEN 'NO'\n              ELSE 'YES'\n            END AS is_nullable,\n            CASE \n              WHEN a.atttypid = ANY ('{int,int8,int2}'::regtype[]) \n              AND EXISTS (\n                SELECT FROM pg_attrdef ad\n                WHERE ad.adrelid = a.attrelid \n                AND ad.adnum = a.attnum \n                AND pg_get_expr(ad.adbin, ad.adrelid) = 'nextval(''' \n                    || pg_get_serial_sequence(a.attrelid::regclass::text, a.attname)::regclass || '''::regclass)'\n              )\n              THEN CASE a.atttypid\n                WHEN 'int'::regtype THEN 'serial'\n                WHEN 'int8'::regtype THEN 'bigserial'\n                WHEN 'int2'::regtype THEN 'smallserial'\n              END\n              ELSE format_type(a.atttypid, a.atttypmod)\n            END AS data_type,\n            pg_get_expr(ad.adbin, ad.adrelid) AS column_default,\n            CASE \n              WHEN con.contype = 'p' THEN true\n              ELSE false\n            END AS is_primary\n          FROM pg_attribute a\n          JOIN pg_class cls ON cls.oid = a.attrelid\n          JOIN pg_namespace ns ON ns.oid = cls.relnamespace\n          LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n          LEFT JOIN pg_constraint con ON con.conrelid = a.attrelid \n            AND a.attnum = ANY(con.conkey) \n            AND con.contype = 'p'\n          WHERE \n            a.attnum > 0\n            AND NOT a.attisdropped\n            AND ns.nspname = ${schemaName}\n            AND cls.relname = ${tableName}\n          ORDER BY a.attnum`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get indexes for a table\n   */\n  private async getIndexes(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            i.relname AS name,\n            idx.indisunique AS is_unique,\n            idx.indisprimary AS is_primary,\n            con.contype = 'u' AS is_unique_constraint,\n            ARRAY(\n              SELECT a.attname\n              FROM pg_attribute a\n              WHERE a.attrelid = idx.indrelid\n                AND a.attnum = ANY(idx.indkey::int[])\n              ORDER BY a.attnum\n            ) AS columns,\n            am.amname AS method\n          FROM pg_index idx\n          JOIN pg_class i ON i.oid = idx.indexrelid\n          JOIN pg_class c ON c.oid = idx.indrelid\n          JOIN pg_namespace n ON n.oid = c.relnamespace\n          JOIN pg_am am ON am.oid = i.relam\n          LEFT JOIN pg_constraint con ON con.conindid = idx.indexrelid\n          WHERE n.nspname = ${schemaName}\n            AND c.relname = ${tableName}`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get foreign keys for a table\n   */\n  private async getForeignKeys(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT\n            con.conname AS name,\n            att.attname AS column_name,\n            fnsp.nspname AS foreign_table_schema,\n            frel.relname AS foreign_table_name,\n            fatt.attname AS foreign_column_name,\n            CASE con.confupdtype\n              WHEN 'a' THEN 'NO ACTION'\n              WHEN 'r' THEN 'RESTRICT'\n              WHEN 'n' THEN 'SET NULL'\n              WHEN 'c' THEN 'CASCADE'\n              WHEN 'd' THEN 'SET DEFAULT'\n            END AS update_rule,\n            CASE con.confdeltype\n              WHEN 'a' THEN 'NO ACTION'\n              WHEN 'r' THEN 'RESTRICT'\n              WHEN 'n' THEN 'SET NULL'\n              WHEN 'c' THEN 'CASCADE'\n              WHEN 'd' THEN 'SET DEFAULT'\n            END AS delete_rule\n          FROM pg_catalog.pg_constraint con\n          JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid\n          JOIN pg_catalog.pg_namespace nsp ON nsp.oid = con.connamespace\n          LEFT JOIN pg_catalog.pg_attribute att ON att.attnum = ANY (con.conkey)\n            AND att.attrelid = con.conrelid\n          LEFT JOIN pg_catalog.pg_class frel ON frel.oid = con.confrelid\n          LEFT JOIN pg_catalog.pg_namespace fnsp ON fnsp.oid = frel.relnamespace\n          LEFT JOIN pg_catalog.pg_attribute fatt ON fatt.attnum = ANY (con.confkey)\n            AND fatt.attrelid = con.confrelid\n          WHERE con.contype = 'f'\n            AND nsp.nspname = ${schemaName}\n            AND rel.relname = ${tableName}`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get primary keys for a table\n   */\n  private async getPrimaryKeys(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            con.conname AS name,\n            ARRAY(\n              SELECT a.attname\n              FROM pg_attribute a\n              WHERE a.attrelid = con.conrelid\n                AND a.attnum = ANY(con.conkey)\n              ORDER BY a.attnum\n            ) AS columns\n          FROM pg_constraint con\n          JOIN pg_class rel ON rel.oid = con.conrelid\n          JOIN pg_namespace nsp ON nsp.oid = con.connamespace\n          WHERE con.contype = 'p'\n            AND nsp.nspname = ${schemaName}\n            AND rel.relname = ${tableName}`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get unique constraints for a table\n   */\n  private async getUniqueConstraints(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            con.conname AS name,\n            ARRAY(\n              SELECT a.attname\n              FROM pg_attribute a\n              WHERE a.attrelid = con.conrelid\n                AND a.attnum = ANY(con.conkey)\n              ORDER BY a.attnum\n            ) AS columns\n          FROM pg_constraint con\n          JOIN pg_class rel ON rel.oid = con.conrelid\n          JOIN pg_namespace nsp ON nsp.oid = con.connamespace\n          WHERE con.contype = 'u'\n            AND nsp.nspname = ${schemaName}\n            AND rel.relname = ${tableName}`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get check constraints for a table\n   */\n  private async getCheckConstraints(schemaName: string, tableName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            con.conname AS name,\n            pg_get_constraintdef(con.oid) AS definition\n          FROM pg_constraint con\n          JOIN pg_class rel ON rel.oid = con.conrelid\n          JOIN pg_namespace nsp ON nsp.oid = con.connamespace\n          WHERE con.contype = 'c'\n            AND nsp.nspname = ${schemaName}\n            AND rel.relname = ${tableName}`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Get enums in a schema\n   */\n  private async getEnums(schemaName: string): Promise<any[]> {\n    const result = await this.db.execute(\n      sql`SELECT \n            n.nspname AS schema,\n            t.typname AS name,\n            e.enumlabel AS value,\n            e.enumsortorder AS sort_order\n          FROM pg_type t\n          JOIN pg_enum e ON t.oid = e.enumtypid\n          JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n          WHERE n.nspname = ${schemaName}\n          ORDER BY schema, name, sort_order`\n    );\n    return result.rows;\n  }\n\n  /**\n   * Parse default value for a column\n   */\n  private parseDefault(defaultValue: string, dataType: string): string | undefined {\n    if (!defaultValue) return undefined;\n\n    // Remove the type cast if present (e.g., \"'value'::text\" -> \"'value'\")\n    const match = defaultValue.match(/^'(.*)'::/);\n    if (match) {\n      return `'${match[1]}'`;\n    }\n\n    // Handle nextval for sequences\n    if (defaultValue.includes('nextval(')) {\n      return undefined; // Serial types handle this automatically\n    }\n\n    // Handle boolean defaults\n    if (dataType === 'boolean') {\n      if (defaultValue === 'true') return 'true';\n      if (defaultValue === 'false') return 'false';\n    }\n\n    // Return as-is for other cases\n    return defaultValue;\n  }\n\n  /**\n   * Check if tables exist for a plugin by checking if any tables exist in its schema\n   * @param pluginName - Name of the plugin\n   * @returns True if tables exist, false otherwise\n   */\n  async hasExistingTables(pluginName: string): Promise<boolean> {\n    const schemaName =\n      pluginName === '@elizaos/plugin-sql' ? 'public' : this.deriveSchemaName(pluginName);\n\n    const result = await this.db.execute(\n      sql`SELECT COUNT(*) AS count\n          FROM information_schema.tables\n          WHERE table_schema = ${schemaName}\n            AND table_type = 'BASE TABLE'`\n    );\n\n    const count = parseInt((result.rows[0]?.count as string) || '0', 10);\n    return count > 0;\n  }\n\n  /**\n   * Derive schema name from plugin name\n   */\n  private deriveSchemaName(pluginName: string): string {\n    // Same logic as in schema-transformer.ts\n    return pluginName.replace('@', '').replace('/', '_').replace(/-/g, '_').toLowerCase();\n  }\n}\n",
    "import { sql } from 'drizzle-orm';\nimport { logger } from '@elizaos/core';\nimport type { DrizzleDB, RuntimeMigrationOptions, SchemaSnapshot } from './types';\nimport { MigrationTracker } from './storage/migration-tracker';\nimport { JournalStorage } from './storage/journal-storage';\nimport { SnapshotStorage } from './storage/snapshot-storage';\nimport { ExtensionManager } from './extension-manager';\nimport { generateSnapshot, hashSnapshot, hasChanges } from './drizzle-adapters/snapshot-generator';\nimport { calculateDiff, hasDiffChanges } from './drizzle-adapters/diff-calculator';\nimport {\n  generateMigrationSQL,\n  checkForDataLoss,\n  type DataLossCheck,\n} from './drizzle-adapters/sql-generator';\nimport { deriveSchemaName } from './schema-transformer';\nimport { DatabaseIntrospector } from './drizzle-adapters/database-introspector';\nimport { createHash } from 'crypto';\n\nexport class RuntimeMigrator {\n  private migrationTracker: MigrationTracker;\n  private journalStorage: JournalStorage;\n  private snapshotStorage: SnapshotStorage;\n  private extensionManager: ExtensionManager;\n  private introspector: DatabaseIntrospector;\n\n  constructor(private db: DrizzleDB) {\n    this.migrationTracker = new MigrationTracker(db);\n    this.journalStorage = new JournalStorage(db);\n    this.snapshotStorage = new SnapshotStorage(db);\n    this.extensionManager = new ExtensionManager(db);\n    this.introspector = new DatabaseIntrospector(db);\n  }\n\n  /**\n   * Get expected schema name for a plugin\n   * @elizaos/plugin-sql uses 'public' schema (core application)\n   * All other plugins should use namespaced schemas\n   */\n  private getExpectedSchemaName(pluginName: string): string {\n    // Core plugin uses public schema\n    if (pluginName === '@elizaos/plugin-sql') {\n      return 'public';\n    }\n\n    // Use the schema transformer's logic for consistency\n    return deriveSchemaName(pluginName);\n  }\n\n  /**\n   * Ensure all schemas used in the snapshot exist\n   */\n  private async ensureSchemasExist(snapshot: SchemaSnapshot): Promise<void> {\n    const schemasToCreate = new Set<string>();\n\n    // Collect all schemas from tables\n    for (const table of Object.values(snapshot.tables)) {\n      const tableData = table as any; // Tables in snapshot have schema property\n      const schema = tableData.schema || 'public';\n      if (schema !== 'public') {\n        schemasToCreate.add(schema);\n      }\n    }\n\n    // Also add schemas from the snapshot's schemas object\n    for (const schema of Object.keys(snapshot.schemas || {})) {\n      if (schema !== 'public') {\n        schemasToCreate.add(schema);\n      }\n    }\n\n    // Create all non-public schemas\n    for (const schemaName of schemasToCreate) {\n      logger.debug(`[RuntimeMigrator] Ensuring schema '${schemaName}' exists`);\n      await this.db.execute(sql.raw(`CREATE SCHEMA IF NOT EXISTS \"${schemaName}\"`));\n    }\n  }\n\n  /**\n   * Validate schema usage and provide warnings\n   */\n  private validateSchemaUsage(pluginName: string, snapshot: SchemaSnapshot): void {\n    const expectedSchema = this.getExpectedSchemaName(pluginName);\n    const isCorePLugin = pluginName === '@elizaos/plugin-sql';\n\n    for (const table of Object.values(snapshot.tables)) {\n      const tableData = table as any; // Tables in snapshot have schema and name properties\n      const actualSchema = tableData.schema || 'public';\n\n      // Warn if non-core plugin is using public schema\n      if (!isCorePLugin && actualSchema === 'public') {\n        logger.warn(\n          `[RuntimeMigrator] WARNING: Plugin '${pluginName}' table '${tableData.name}' is using public schema. ` +\n            `Consider using pgSchema('${expectedSchema}').table(...) for better isolation.`\n        );\n      }\n\n      // Warn if core plugin is not using public schema\n      if (isCorePLugin && actualSchema !== 'public') {\n        logger.warn(\n          `[RuntimeMigrator] WARNING: Core plugin '@elizaos/plugin-sql' table '${tableData.name}' is using schema '${actualSchema}'. ` +\n            `Core tables should use public schema.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Generate a stable advisory lock ID from plugin name\n   * PostgreSQL advisory locks use bigint, so we need to hash the plugin name\n   * and convert to a stable bigint value\n   */\n  private getAdvisoryLockId(pluginName: string): bigint {\n    // Create a hash of the plugin name\n    const hash = createHash('sha256').update(pluginName).digest();\n\n    // Take first 8 bytes for a 64-bit integer\n    const buffer = hash.slice(0, 8);\n\n    // Convert to bigint\n    let lockId = BigInt('0x' + buffer.toString('hex'));\n\n    // Ensure the value fits in PostgreSQL's positive bigint range\n    // Use a mask to keep only 63 bits (ensures positive in signed 64-bit)\n    // This preserves uniqueness better than modulo and avoids collisions\n    const mask63Bits = 0x7fffffffffffffffn; // 63 bits set to 1\n    lockId = lockId & mask63Bits;\n\n    // Ensure non-zero (extremely unlikely but handle it)\n    if (lockId === 0n) {\n      lockId = 1n;\n    }\n\n    return lockId;\n  }\n\n  /**\n   * Validate that a value is a valid PostgreSQL bigint\n   * PostgreSQL bigint range: -9223372036854775808 to 9223372036854775807\n   */\n  private validateBigInt(value: bigint): boolean {\n    const MIN_BIGINT = -9223372036854775808n;\n    const MAX_BIGINT = 9223372036854775807n;\n    return value >= MIN_BIGINT && value <= MAX_BIGINT;\n  }\n\n  /**\n   * Detect if a connection string represents a real PostgreSQL database\n   * (not PGLite, in-memory, or other non-PostgreSQL databases)\n   *\n   * This method handles various connection string formats including:\n   * - Standard postgres:// and postgresql:// URLs\n   * - Cloud provider URLs (AWS, Azure, GCP, Supabase, Neon, etc.)\n   * - Connection strings with query parameters\n   * - Non-standard schemes (pgbouncer://, etc.)\n   * - IP addresses with ports\n   *\n   * @param connectionUrl - Database connection string to check\n   * @returns true if this is a real PostgreSQL database connection\n   */\n  private isRealPostgresDatabase(connectionUrl: string): boolean {\n    // Empty or undefined URL means not PostgreSQL\n    if (!connectionUrl || connectionUrl.trim() === '') {\n      return false;\n    }\n\n    // Trim and then convert to lowercase for consistent pattern matching\n    const trimmedUrl = connectionUrl.trim();\n    const url = trimmedUrl.toLowerCase();\n    const originalUrl = trimmedUrl; // Preserve case for pattern matching\n\n    // First, explicitly reject other database schemes\n    // These are non-PostgreSQL databases that should be rejected immediately\n    const nonPostgresSchemes = [\n      'mysql://',\n      'mysqli://',\n      'mariadb://',\n      'mongodb://',\n      'mongodb+srv://',\n    ];\n\n    for (const scheme of nonPostgresSchemes) {\n      if (url.startsWith(scheme)) {\n        return false;\n      }\n    }\n\n    // Second, check for definitive non-PostgreSQL patterns\n    // These patterns indicate PGLite, in-memory, or SQLite databases\n    const excludePatterns = [\n      ':memory:', // In-memory database\n      'pglite://', // PGLite with scheme\n      '/pglite', // PGLite path\n      'sqlite://', // SQLite with scheme\n      'sqlite3://', // SQLite3 with scheme\n      '.sqlite', // SQLite file extension\n      '.sqlite3', // SQLite3 file extension\n      'file::memory:', // SQLite in-memory with file scheme\n      'file:', // File-based database (when not followed by // for URL schemes)\n    ];\n\n    // Check for file extensions at the end of the URL (before query params)\n    const urlWithoutQuery = url.split('?')[0];\n    if (\n      urlWithoutQuery.endsWith('.db') ||\n      urlWithoutQuery.endsWith('.sqlite') ||\n      urlWithoutQuery.endsWith('.sqlite3')\n    ) {\n      return false;\n    }\n\n    for (const pattern of excludePatterns) {\n      if (url.includes(pattern)) {\n        // Special case: file:// can be part of a valid postgres URL in some contexts\n        if (pattern === 'file:' && url.includes('postgres')) {\n          continue;\n        }\n        return false;\n      }\n    }\n\n    // Check for PostgreSQL URL schemes (including variations and proxies)\n    const postgresSchemes = [\n      'postgres://', // Standard PostgreSQL URL scheme\n      'postgresql://', // Alternative PostgreSQL URL scheme\n      'postgis://', // PostGIS (PostgreSQL with GIS extension)\n      'pgbouncer://', // PgBouncer connection pooler\n      'pgpool://', // PgPool connection pooler\n      'cockroach://', // CockroachDB (PostgreSQL compatible)\n      'cockroachdb://', // CockroachDB alternative scheme\n      'redshift://', // AWS Redshift (PostgreSQL compatible)\n      'timescaledb://', // TimescaleDB (PostgreSQL with time-series)\n      'yugabyte://', // YugabyteDB (PostgreSQL compatible)\n    ];\n\n    for (const scheme of postgresSchemes) {\n      if (url.startsWith(scheme)) {\n        return true;\n      }\n    }\n\n    // Check for PostgreSQL connection string parameters\n    // These indicate libpq-style connection strings\n    const connectionParams = [\n      'host=',\n      'dbname=',\n      'sslmode=',\n      'connect_timeout=',\n      'application_name=',\n      'user=',\n      'password=',\n      'port=',\n      'options=',\n      'sslcert=',\n      'sslkey=',\n      'sslrootcert=',\n    ];\n\n    for (const param of connectionParams) {\n      if (url.includes(param)) {\n        return true;\n      }\n    }\n\n    // Check for user@host format (common in PostgreSQL connection strings)\n    if (url.includes('@') && (url.includes('postgres') || /:\\d{4,5}/.test(url))) {\n      return true;\n    }\n\n    // Check for common PostgreSQL ports\n    const postgresPorts = [\n      ':5432', // Default PostgreSQL port\n      ':5433', // Common alternative PostgreSQL port\n      ':5434', // Another common alternative\n      ':25060', // DigitalOcean Managed Databases default port\n      ':26257', // CockroachDB default port\n      ':6432', // PgBouncer default port\n      ':9999', // PgPool default port\n      ':8432', // Supabase Pooler port\n    ];\n\n    for (const port of postgresPorts) {\n      if (url.includes(port)) {\n        return true;\n      }\n    }\n\n    // Check for cloud provider hostnames and patterns\n    const cloudProviderPatterns = [\n      // AWS\n      'amazonaws.com',\n      'rds.amazonaws.com',\n      '.rds.',\n      'redshift.amazonaws.com',\n      // Azure\n      'azure.com',\n      'database.azure.com',\n      'postgres.database.azure.com',\n      // Google Cloud\n      'googleusercontent',\n      'cloudsql',\n      'cloud.google.com',\n      // Supabase\n      'supabase',\n      '.supabase.co',\n      '.supabase.com',\n      'pooler.supabase',\n      // Neon\n      'neon.tech',\n      '.neon.tech',\n      'neon.build',\n      // Railway\n      'railway.app',\n      '.railway.app',\n      'railway.internal',\n      // Render\n      'render.com',\n      '.render.com',\n      'onrender.com',\n      // Heroku\n      'heroku.com',\n      'herokuapp.com',\n      '.heroku.com',\n      // TimescaleDB\n      'timescale',\n      'timescaledb',\n      '.tsdb.cloud',\n      // CockroachDB\n      'cockroachlabs',\n      'cockroachdb.cloud',\n      '.crdb.io',\n      // DigitalOcean\n      'digitalocean.com',\n      'db.ondigitalocean',\n      'do-user-',\n      '.db.ondigitalocean.com',\n      // Aiven\n      'aiven',\n      'aivencloud',\n      '.aiven.io',\n      '.aivencloud.com',\n      // Crunchy Data\n      'crunchydata',\n      '.crunchydata.com',\n      // ElephantSQL\n      'elephantsql',\n      '.elephantsql.com',\n      // YugabyteDB\n      'yugabyte',\n      '.yugabyte.cloud',\n      // Scaleway\n      'scaleway',\n      '.rdb.fr-par.scw.cloud',\n      // Vercel Postgres\n      'vercel-storage',\n      '.postgres.vercel-storage.com',\n      // PlanetScale (supports PostgreSQL wire protocol)\n      'psdb.cloud',\n      '.psdb.cloud',\n      // Xata\n      'xata.sh',\n      '.xata.sh',\n      // Fly.io\n      'fly.dev',\n      '.fly.dev',\n      'fly.io',\n    ];\n\n    for (const pattern of cloudProviderPatterns) {\n      if (url.includes(pattern)) {\n        return true;\n      }\n    }\n\n    // Check for IP address with port (common for self-hosted or cloud databases)\n    // Match IPv4: xxx.xxx.xxx.xxx:port\n    const ipv4PortPattern = /\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}:\\d{1,5}\\b/;\n    if (ipv4PortPattern.test(originalUrl)) {\n      return true;\n    }\n\n    // Check for IPv6 addresses (common in cloud environments)\n    // Match [xxxx:xxxx:...:xxxx]:port or similar formats\n    const ipv6Pattern = /\\[[0-9a-f:]+\\](:\\d{1,5})?/i;\n    if (ipv6Pattern.test(originalUrl)) {\n      return true;\n    }\n\n    // Check for host:port/database format (without explicit scheme)\n    // This pattern matches: \"hostname:5432/mydb\" or \"subdomain.example.com:5432/testdb\"\n    const hostPortDbPattern = /^[a-z0-9.-]+:\\d{1,5}\\/[a-z0-9_-]+/i;\n    if (hostPortDbPattern.test(originalUrl)) {\n      return true;\n    }\n\n    // Check for connection strings with query parameters that indicate PostgreSQL\n    if (url.includes('?') || url.includes('&')) {\n      const postgresQueryParams = [\n        'sslmode=',\n        'sslcert=',\n        'sslkey=',\n        'sslrootcert=',\n        'connect_timeout=',\n        'application_name=',\n        'options=',\n        'fallback_application_name=',\n        'keepalives=',\n        'target_session_attrs=',\n      ];\n\n      for (const param of postgresQueryParams) {\n        if (url.includes(param)) {\n          return true;\n        }\n      }\n    }\n\n    // If none of the patterns matched, assume it's not a real PostgreSQL database\n    // This is a conservative approach to avoid using advisory locks on unknown databases\n    logger.debug(\n      `[RuntimeMigrator] Connection string did not match any PostgreSQL patterns: ${url.substring(0, 50)}...`\n    );\n    return false;\n  }\n\n  /**\n   * Initialize migration system - create necessary tables\n   * @throws Error if table creation fails\n   */\n  async initialize(): Promise<void> {\n    logger.info('[RuntimeMigrator] Initializing migration system...');\n    await this.migrationTracker.ensureTables();\n    logger.info('[RuntimeMigrator] Migration system initialized');\n  }\n\n  /**\n   * Run migrations for a plugin/schema\n   * @param pluginName - Plugin identifier\n   * @param schema - Drizzle schema object\n   * @param options - Migration options (verbose, force, dryRun, allowDataLoss)\n   * @throws Error if destructive migrations blocked or migration fails\n   */\n  async migrate(\n    pluginName: string,\n    schema: any,\n    options: RuntimeMigrationOptions = {}\n  ): Promise<void> {\n    const lockId = this.getAdvisoryLockId(pluginName);\n\n    // Validate lockId is within PostgreSQL bigint range\n    if (!this.validateBigInt(lockId)) {\n      throw new Error(`Invalid advisory lock ID generated for plugin ${pluginName}`);\n    }\n\n    let lockAcquired = false;\n\n    try {\n      logger.info(`[RuntimeMigrator] Starting migration for plugin: ${pluginName}`);\n\n      // Ensure migration tables exist\n      await this.initialize();\n\n      // Only use advisory locks for real PostgreSQL databases\n      // Skip for PGLite or development databases\n      const postgresUrl = process.env.POSTGRES_URL || process.env.DATABASE_URL || '';\n      const isRealPostgres = this.isRealPostgresDatabase(postgresUrl);\n\n      if (isRealPostgres) {\n        try {\n          logger.debug(`[RuntimeMigrator] Using PostgreSQL advisory locks for ${pluginName}`);\n\n          // Convert bigint to string for SQL query\n          // The sql tagged template will properly parameterize this value\n          const lockIdStr = lockId.toString();\n\n          const lockResult = await this.db.execute(\n            sql`SELECT pg_try_advisory_lock(CAST(${lockIdStr} AS bigint)) as acquired`\n          );\n\n          lockAcquired = (lockResult.rows[0] as any)?.acquired === true;\n\n          if (!lockAcquired) {\n            logger.info(\n              `[RuntimeMigrator] Migration already in progress for ${pluginName}, waiting for lock...`\n            );\n\n            // Wait for the lock (blocking call)\n            await this.db.execute(sql`SELECT pg_advisory_lock(CAST(${lockIdStr} AS bigint))`);\n            lockAcquired = true;\n\n            logger.info(`[RuntimeMigrator] Lock acquired for ${pluginName}`);\n          } else {\n            logger.debug(\n              `[RuntimeMigrator] Advisory lock acquired for ${pluginName} (lock ID: ${lockIdStr})`\n            );\n          }\n        } catch (lockError) {\n          // If advisory locks fail, log but continue\n          // This might happen if the PostgreSQL version doesn't support advisory locks\n          logger.warn(\n            `[RuntimeMigrator] Failed to acquire advisory lock, continuing without lock: ${lockError}`\n          );\n          lockAcquired = false;\n        }\n      } else {\n        // For PGLite or other development databases, skip advisory locks\n        logger.debug(\n          `[RuntimeMigrator] Development database detected (PGLite or non-PostgreSQL), skipping advisory locks`\n        );\n      }\n\n      // Install required extensions (same as old migrator)\n      await this.extensionManager.installRequiredExtensions(['vector', 'fuzzystrmatch']);\n\n      // Generate current snapshot from schema\n      const currentSnapshot = await generateSnapshot(schema);\n\n      // Ensure all schemas referenced in the snapshot exist\n      await this.ensureSchemasExist(currentSnapshot);\n\n      // Validate schema usage and warn about potential issues\n      this.validateSchemaUsage(pluginName, currentSnapshot);\n\n      const currentHash = hashSnapshot(currentSnapshot);\n\n      // Check if we've already run this exact migration\n      // This check happens AFTER acquiring the lock to handle concurrent scenarios\n      // This is critical: if we had to wait for the lock (lockAcquired was initially false),\n      // another process may have completed the migration while we were waiting\n      // We MUST check regardless of whether lastMigration existed before\n      const lastMigration = await this.migrationTracker.getLastMigration(pluginName);\n      if (lastMigration && lastMigration.hash === currentHash) {\n        logger.info(\n          `[RuntimeMigrator] No changes detected for ${pluginName}, skipping migration (hash: ${currentHash})`\n        );\n        return;\n      }\n\n      // Load previous snapshot\n      let previousSnapshot = await this.snapshotStorage.getLatestSnapshot(pluginName);\n\n      // If no snapshot exists but tables exist in database, introspect them\n      if (!previousSnapshot && Object.keys(currentSnapshot.tables).length > 0) {\n        const hasExistingTables = await this.introspector.hasExistingTables(pluginName);\n\n        if (hasExistingTables) {\n          logger.info(\n            `[RuntimeMigrator] No snapshot found for ${pluginName} but tables exist in database. Introspecting...`\n          );\n\n          // Determine the schema name for introspection\n          const schemaName = this.getExpectedSchemaName(pluginName);\n\n          // Introspect the current database state\n          const introspectedSnapshot = await this.introspector.introspectSchema(schemaName);\n\n          // Only use the introspected snapshot if it has tables\n          if (Object.keys(introspectedSnapshot.tables).length > 0) {\n            // Save this as the initial snapshot (idx: 0)\n            await this.snapshotStorage.saveSnapshot(pluginName, 0, introspectedSnapshot);\n\n            // Update journal to record this initial state\n            await this.journalStorage.updateJournal(\n              pluginName,\n              0,\n              `introspected_${Date.now()}`,\n              true\n            );\n\n            // Record this as a migration\n            const introspectedHash = hashSnapshot(introspectedSnapshot);\n            await this.migrationTracker.recordMigration(pluginName, introspectedHash, Date.now());\n\n            logger.info(\n              `[RuntimeMigrator] Created initial snapshot from existing database for ${pluginName}`\n            );\n\n            // Set this as the previous snapshot for comparison\n            previousSnapshot = introspectedSnapshot;\n          }\n        }\n      }\n\n      // Check if there are actual changes\n      if (!hasChanges(previousSnapshot, currentSnapshot)) {\n        logger.info(`[RuntimeMigrator] No schema changes for ${pluginName}`);\n\n        // For empty schemas, we still want to record the migration\n        // to ensure idempotency and consistency\n        if (!previousSnapshot && Object.keys(currentSnapshot.tables).length === 0) {\n          logger.info(`[RuntimeMigrator] Recording empty schema for ${pluginName}`);\n          await this.migrationTracker.recordMigration(pluginName, currentHash, Date.now());\n          const idx = await this.journalStorage.getNextIdx(pluginName);\n          const tag = this.generateMigrationTag(idx, pluginName);\n          await this.journalStorage.updateJournal(pluginName, idx, tag, true);\n          await this.snapshotStorage.saveSnapshot(pluginName, idx, currentSnapshot);\n        }\n\n        return;\n      }\n\n      // Calculate diff\n      const diff = await calculateDiff(previousSnapshot, currentSnapshot);\n\n      // Check if diff has changes\n      if (!hasDiffChanges(diff)) {\n        logger.info(`[RuntimeMigrator] No actionable changes for ${pluginName}`);\n        return;\n      }\n\n      // Check for potential data loss\n      const dataLossCheck = checkForDataLoss(diff);\n\n      if (dataLossCheck.hasDataLoss) {\n        const isProduction = process.env.NODE_ENV === 'production';\n\n        // Determine if destructive migrations are allowed\n        // Priority: explicit options > environment variable\n        const allowDestructive =\n          options.force ||\n          options.allowDataLoss ||\n          process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS === 'true';\n\n        if (!allowDestructive) {\n          // Block the migration and provide clear instructions\n          logger.error('[RuntimeMigrator] Destructive migration blocked');\n          logger.error(`[RuntimeMigrator] Plugin: ${pluginName}`);\n          logger.error(\n            `[RuntimeMigrator] Environment: ${isProduction ? 'PRODUCTION' : 'DEVELOPMENT'}`\n          );\n          logger.error('[RuntimeMigrator] Destructive operations detected:');\n\n          for (const warning of dataLossCheck.warnings) {\n            logger.error(`[RuntimeMigrator]   - ${warning}`);\n          }\n\n          logger.error('[RuntimeMigrator] To proceed with destructive migrations:');\n          logger.error(\n            '[RuntimeMigrator]   1. Set environment variable: export ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true'\n          );\n          logger.error(\n            '[RuntimeMigrator]   2. Or use option: migrate(plugin, schema, { force: true })'\n          );\n\n          if (isProduction) {\n            logger.error(\n              '[RuntimeMigrator]   3. For production, consider using drizzle-kit for manual migration'\n            );\n          }\n\n          const errorMessage = isProduction\n            ? `Destructive migration blocked in production for ${pluginName}. Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true or use drizzle-kit.`\n            : `Destructive migration blocked for ${pluginName}. Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true to proceed.`;\n\n          throw new Error(errorMessage);\n        }\n\n        // Log that we're proceeding with destructive operations\n        if (dataLossCheck.requiresConfirmation) {\n          logger.warn('[RuntimeMigrator] Proceeding with destructive migration');\n          logger.warn(`[RuntimeMigrator] Plugin: ${pluginName}`);\n          logger.warn('[RuntimeMigrator] The following operations will be performed:');\n\n          for (const warning of dataLossCheck.warnings) {\n            logger.warn(`[RuntimeMigrator]    ${warning}`);\n          }\n        }\n      }\n\n      // Generate SQL statements\n      const sqlStatements = await generateMigrationSQL(previousSnapshot, currentSnapshot, diff);\n\n      if (sqlStatements.length === 0) {\n        logger.info(`[RuntimeMigrator] No SQL statements to execute for ${pluginName}`);\n        return;\n      }\n\n      // Log what we're about to do\n      logger.info(\n        `[RuntimeMigrator] Executing ${sqlStatements.length} SQL statements for ${pluginName}`\n      );\n      if (options.verbose) {\n        sqlStatements.forEach((stmt, i) => {\n          logger.debug(`[RuntimeMigrator] Statement ${i + 1}: ${stmt}`);\n        });\n      }\n\n      // Dry run mode - just log what would happen\n      if (options.dryRun) {\n        logger.info('[RuntimeMigrator] DRY RUN mode - not executing statements');\n        logger.info('[RuntimeMigrator] Would execute:');\n        sqlStatements.forEach((stmt, i) => {\n          logger.info(`  ${i + 1}. ${stmt}`);\n        });\n        return;\n      }\n\n      // Execute migration in transaction\n      await this.executeMigration(pluginName, currentSnapshot, currentHash, sqlStatements);\n\n      logger.info(`[RuntimeMigrator] Migration completed successfully for ${pluginName}`);\n\n      // Return a success result\n      return;\n    } catch (error) {\n      logger.error(`[RuntimeMigrator] Migration failed for ${pluginName}:`, JSON.stringify(error));\n      throw error;\n    } finally {\n      // Always release the advisory lock if we acquired it (only for real PostgreSQL)\n      const postgresUrl = process.env.POSTGRES_URL || process.env.DATABASE_URL || '';\n      const isRealPostgres = this.isRealPostgresDatabase(postgresUrl);\n\n      if (lockAcquired && isRealPostgres) {\n        try {\n          // Convert bigint to string for SQL query (same as when acquiring)\n          const lockIdStr = lockId.toString();\n          await this.db.execute(sql`SELECT pg_advisory_unlock(CAST(${lockIdStr} AS bigint))`);\n          logger.debug(`[RuntimeMigrator] Advisory lock released for ${pluginName}`);\n        } catch (unlockError) {\n          logger.warn(\n            `[RuntimeMigrator] Failed to release advisory lock for ${pluginName}:`,\n            JSON.stringify(unlockError)\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute migration in a transaction\n   */\n  private async executeMigration(\n    pluginName: string,\n    snapshot: SchemaSnapshot,\n    hash: string,\n    sqlStatements: string[]\n  ): Promise<void> {\n    let transactionStarted = false;\n\n    try {\n      // Start manual transaction\n      await this.db.execute(sql`BEGIN`);\n      transactionStarted = true;\n\n      // Execute all SQL statements\n      for (const stmt of sqlStatements) {\n        logger.debug(`[RuntimeMigrator] Executing: ${stmt}`);\n        await this.db.execute(sql.raw(stmt));\n      }\n\n      // Get next index for journal\n      const idx = await this.journalStorage.getNextIdx(pluginName);\n\n      // Record migration\n      await this.migrationTracker.recordMigration(pluginName, hash, Date.now());\n\n      // Update journal\n      const tag = this.generateMigrationTag(idx, pluginName);\n      await this.journalStorage.updateJournal(\n        pluginName,\n        idx,\n        tag,\n        true // breakpoints\n      );\n\n      // Store snapshot\n      await this.snapshotStorage.saveSnapshot(pluginName, idx, snapshot);\n\n      // Commit the transaction\n      await this.db.execute(sql`COMMIT`);\n\n      logger.info(`[RuntimeMigrator] Recorded migration ${tag} for ${pluginName}`);\n    } catch (error) {\n      // Rollback on error if transaction was started\n      if (transactionStarted) {\n        try {\n          await this.db.execute(sql`ROLLBACK`);\n          logger.error(\n            '[RuntimeMigrator] Migration failed, rolled back:',\n            JSON.stringify(error as any)\n          );\n        } catch (rollbackError) {\n          logger.error(\n            '[RuntimeMigrator] Failed to rollback transaction:',\n            JSON.stringify(rollbackError as any)\n          );\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Generate migration tag (like 0000_jazzy_shard)\n   */\n  private generateMigrationTag(idx: number, pluginName: string): string {\n    // Generate a simple tag - in production, use Drizzle's word generation\n    const prefix = idx.toString().padStart(4, '0');\n    const timestamp = Date.now().toString(36);\n    return `${prefix}_${pluginName}_${timestamp}`;\n  }\n\n  /**\n   * Get migration status for a plugin\n   * @param pluginName - Plugin identifier\n   * @returns Migration history and current state\n   */\n  async getStatus(pluginName: string): Promise<{\n    hasRun: boolean;\n    lastMigration: any;\n    journal: any;\n    snapshots: number;\n  }> {\n    const lastMigration = await this.migrationTracker.getLastMigration(pluginName);\n    const journal = await this.journalStorage.loadJournal(pluginName);\n    const snapshots = await this.snapshotStorage.getAllSnapshots(pluginName);\n\n    return {\n      hasRun: !!lastMigration,\n      lastMigration,\n      journal,\n      snapshots: snapshots.length,\n    };\n  }\n\n  /**\n   * Reset migrations for a plugin (dangerous - for development only)\n   * @param pluginName - Plugin identifier\n   * @warning Deletes all migration history - use only in development\n   */\n  async reset(pluginName: string): Promise<void> {\n    logger.warn(`[RuntimeMigrator] Resetting migrations for ${pluginName}`);\n\n    await this.db.execute(\n      sql`DELETE FROM migrations._migrations WHERE plugin_name = ${pluginName}`\n    );\n    await this.db.execute(sql`DELETE FROM migrations._journal WHERE plugin_name = ${pluginName}`);\n    await this.db.execute(sql`DELETE FROM migrations._snapshots WHERE plugin_name = ${pluginName}`);\n\n    logger.warn(`[RuntimeMigrator] Reset complete for ${pluginName}`);\n  }\n\n  /**\n   * Check if a migration would cause data loss without executing it\n   * @param pluginName - Plugin identifier\n   * @param schema - Drizzle schema to check\n   * @returns Data loss analysis or null if no changes\n   */\n  async checkMigration(pluginName: string, schema: any): Promise<DataLossCheck | null> {\n    try {\n      logger.info(`[RuntimeMigrator] Checking migration for ${pluginName}...`);\n\n      // Generate current snapshot from schema\n      const currentSnapshot = await generateSnapshot(schema);\n\n      // Load previous snapshot\n      const previousSnapshot = await this.snapshotStorage.getLatestSnapshot(pluginName);\n\n      // Check if there are changes\n      if (!hasChanges(previousSnapshot, currentSnapshot)) {\n        logger.info(`[RuntimeMigrator] No changes detected for ${pluginName}`);\n        return null;\n      }\n\n      // Calculate diff\n      const diff = await calculateDiff(previousSnapshot, currentSnapshot);\n\n      // Check for data loss\n      const dataLossCheck = checkForDataLoss(diff);\n\n      if (dataLossCheck.hasDataLoss) {\n        logger.warn(`[RuntimeMigrator] Migration for ${pluginName} would cause data loss`);\n      } else {\n        logger.info(`[RuntimeMigrator] Migration for ${pluginName} is safe (no data loss)`);\n      }\n\n      return dataLossCheck;\n    } catch (error) {\n      logger.error(\n        `[RuntimeMigrator] Failed to check migration for ${pluginName}:`,\n        JSON.stringify(error)\n      );\n      throw error;\n    }\n  }\n}\n",
    "export { RuntimeMigrator } from './runtime-migrator';\nexport * from './types';\n\n// Storage exports (if needed for advanced usage)\nexport { MigrationTracker } from './storage/migration-tracker';\nexport { JournalStorage } from './storage/journal-storage';\nexport { SnapshotStorage } from './storage/snapshot-storage';\n\n// Drizzle adapter exports (if needed for extensions)\nexport {\n  generateSnapshot,\n  hashSnapshot,\n  createEmptySnapshot,\n  hasChanges,\n} from './drizzle-adapters/snapshot-generator';\n\nexport { calculateDiff, hasDiffChanges, type SchemaDiff } from './drizzle-adapters/diff-calculator';\n\nexport {\n  generateMigrationSQL,\n  generateRenameTableSQL,\n  generateRenameColumnSQL,\n} from './drizzle-adapters/sql-generator';\n",
    "import { logger, type Plugin } from '@elizaos/core';\nimport { RuntimeMigrator } from './runtime-migrator';\nimport type { DrizzleDatabase } from './types';\n\nexport class DatabaseMigrationService {\n  private db: DrizzleDatabase | null = null;\n  private registeredSchemas = new Map<string, any>();\n  private migrator: RuntimeMigrator | null = null;\n\n  constructor() {\n    // No longer extending Service, so no need to call super\n  }\n\n  /**\n   * Initialize service with database connection\n   * @param db - Drizzle database instance\n   */\n  async initializeWithDatabase(db: DrizzleDatabase): Promise<void> {\n    this.db = db;\n    this.migrator = new RuntimeMigrator(db);\n    await this.migrator.initialize();\n    logger.info('DatabaseMigrationService initialized with database and runtime migrator');\n  }\n\n  /**\n   * Auto-discover and register schemas from plugins\n   * @param plugins - Array of plugins to scan for schemas\n   */\n  discoverAndRegisterPluginSchemas(plugins: Plugin[]): void {\n    for (const plugin of plugins) {\n      if ((plugin as any).schema) {\n        this.registeredSchemas.set(plugin.name, (plugin as any).schema);\n        logger.info(`Registered schema for plugin: ${plugin.name}`);\n      }\n    }\n    logger.info(\n      `Discovered ${this.registeredSchemas.size} plugin schemas out of ${plugins.length} plugins`\n    );\n  }\n\n  /**\n   * Register a schema for a specific plugin\n   * @param pluginName - Plugin identifier\n   * @param schema - Drizzle schema object\n   */\n  registerSchema(pluginName: string, schema: any): void {\n    this.registeredSchemas.set(pluginName, schema);\n    logger.info(`Registered schema for plugin: ${pluginName}`);\n  }\n\n  /**\n   * Run migrations for all registered plugins\n   * @param options - Migration options\n   * @param options.verbose - Log detailed output (default: true in dev, false in prod)\n   * @param options.force - Allow destructive migrations\n   * @param options.dryRun - Preview changes without applying\n   * @throws Error if any migration fails or destructive changes blocked\n   */\n  async runAllPluginMigrations(options?: {\n    verbose?: boolean;\n    force?: boolean;\n    dryRun?: boolean;\n  }): Promise<void> {\n    if (!this.db || !this.migrator) {\n      throw new Error('Database or migrator not initialized in DatabaseMigrationService');\n    }\n\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    // Build migration options with sensible defaults\n    const migrationOptions = {\n      verbose: options?.verbose ?? !isProduction,\n      force: options?.force ?? false,\n      dryRun: options?.dryRun ?? false,\n    };\n\n    // Log migration start\n    logger.info('[DatabaseMigrationService] Starting migrations');\n    logger.info(\n      `[DatabaseMigrationService] Environment: ${isProduction ? 'PRODUCTION' : 'DEVELOPMENT'}`\n    );\n    logger.info(`[DatabaseMigrationService] Plugins to migrate: ${this.registeredSchemas.size}`);\n\n    if (migrationOptions.dryRun) {\n      logger.info('[DatabaseMigrationService] DRY RUN mode - no changes will be applied');\n    }\n\n    let successCount = 0;\n    let failureCount = 0;\n    const errors: Array<{ pluginName: string; error: Error }> = [];\n\n    for (const [pluginName, schema] of this.registeredSchemas) {\n      try {\n        await this.migrator.migrate(pluginName, schema, migrationOptions);\n        successCount++;\n        logger.info(`[DatabaseMigrationService]  Completed: ${pluginName}`);\n      } catch (error) {\n        failureCount++;\n        const errorMessage = (error as Error).message;\n\n        // Store the error for later\n        errors.push({ pluginName, error: error as Error });\n\n        if (errorMessage.includes('Destructive migration blocked')) {\n          // Destructive migration was blocked - this is expected behavior\n          logger.error(\n            `[DatabaseMigrationService]  Blocked: ${pluginName} (destructive changes detected)`\n          );\n\n          // Check environment variable consistently with runtime-migrator.ts\n          if (\n            !migrationOptions.force &&\n            process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS !== 'true'\n          ) {\n            logger.error('[DatabaseMigrationService] To allow destructive migrations:');\n            logger.error(\n              '[DatabaseMigrationService]   - Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true'\n            );\n            logger.error('[DatabaseMigrationService]   - Or pass { force: true } to this method');\n          }\n        } else {\n          // Unexpected error\n          logger.error(\n            `[DatabaseMigrationService]  Failed: ${pluginName}`,\n            JSON.stringify(error)\n          );\n        }\n      }\n    }\n\n    // Final summary\n    if (failureCount === 0) {\n      logger.info(\n        `[DatabaseMigrationService] All ${successCount} migrations completed successfully`\n      );\n    } else {\n      logger.error(\n        `[DatabaseMigrationService] Migrations failed: ${failureCount} failed, ${successCount} succeeded`\n      );\n\n      // Throw a consolidated error with details about all failures\n      const errorSummary = errors.map((e) => `${e.pluginName}: ${e.error.message}`).join('\\n  ');\n      throw new Error(`${failureCount} migration(s) failed:\\n  ${errorSummary}`);\n    }\n  }\n\n  /**\n   * Get the runtime migrator instance for advanced operations\n   * @returns RuntimeMigrator instance or null if not initialized\n   */\n  getMigrator(): RuntimeMigrator | null {\n    return this.migrator;\n  }\n}\n",
    "import type { IDatabaseAdapter, UUID } from '@elizaos/core';\nimport { type IAgentRuntime, type Plugin, logger } from '@elizaos/core';\nimport { PgliteDatabaseAdapter } from './pglite/adapter';\nimport { PGliteClientManager } from './pglite/manager';\nimport { PgDatabaseAdapter } from './pg/adapter';\nimport { PostgresConnectionManager } from './pg/manager';\nimport { resolvePgliteDir } from './utils.node';\nimport * as schema from './schema';\n\nconst GLOBAL_SINGLETONS = Symbol.for('@elizaos/plugin-sql/global-singletons');\n\ninterface GlobalSingletons {\n  pgLiteClientManager?: PGliteClientManager;\n  postgresConnectionManager?: PostgresConnectionManager;\n}\n\nconst globalSymbols = globalThis as unknown as Record<symbol, GlobalSingletons>;\nif (!globalSymbols[GLOBAL_SINGLETONS]) {\n  globalSymbols[GLOBAL_SINGLETONS] = {};\n}\nconst globalSingletons = globalSymbols[GLOBAL_SINGLETONS];\n\nexport function createDatabaseAdapter(\n  config: {\n    dataDir?: string;\n    postgresUrl?: string;\n  },\n  agentId: UUID\n): IDatabaseAdapter {\n  if (config.postgresUrl) {\n    if (!globalSingletons.postgresConnectionManager) {\n      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(\n        config.postgresUrl\n      );\n    }\n    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);\n  }\n\n  const dataDir = resolvePgliteDir(config.dataDir);\n  if (!globalSingletons.pgLiteClientManager) {\n    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });\n  }\n  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);\n}\n\nexport const plugin: Plugin = {\n  name: '@elizaos/plugin-sql',\n  description: 'A plugin for SQL database access with dynamic schema migrations',\n  priority: 0,\n  schema: schema,\n  init: async (_config, runtime: IAgentRuntime) => {\n    logger.info('plugin-sql (node) init starting...');\n\n    const adapterRegistered = await runtime\n      .isReady()\n      .then(() => true)\n      .catch((error: unknown) => {\n        const message = error instanceof Error ? error.message : String(error);\n        if (message.includes('Database adapter not registered')) {\n          // Expected on first load before the adapter is created; not a warning condition\n          logger.info('No pre-registered database adapter detected; registering adapter');\n        } else {\n          // Unexpected readiness error - keep as a warning with details\n          logger.warn(\n            { error },\n            'Database adapter readiness check error; proceeding to register adapter'\n          );\n        }\n        return false;\n      });\n    if (adapterRegistered) {\n      logger.info('Database adapter already registered, skipping creation');\n      return;\n    }\n\n    const postgresUrl = runtime.getSetting('POSTGRES_URL');\n    // Only support PGLITE_DATA_DIR going forward\n    const dataDir = runtime.getSetting('PGLITE_DATA_DIR') || undefined;\n\n    const dbAdapter = createDatabaseAdapter(\n      {\n        dataDir,\n        postgresUrl,\n      },\n      runtime.agentId\n    );\n\n    runtime.registerDatabaseAdapter(dbAdapter);\n    logger.info('Database adapter created and registered');\n  },\n};\n\nexport default plugin;\n\nexport { DatabaseMigrationService } from './migration-service';\n",
    "import { type UUID, logger, type Agent, type Entity, type Memory } from '@elizaos/core';\nimport { drizzle } from 'drizzle-orm/pglite';\nimport { BaseDrizzleAdapter } from '../base';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from '../schema/embedding';\nimport type { PGliteClientManager } from './manager';\n\n/**\n * PgliteDatabaseAdapter class represents an adapter for interacting with a PgliteDatabase.\n * Extends BaseDrizzleAdapter.\n *\n * @constructor\n * @param {UUID} agentId - The ID of the agent.\n * @param {PGliteClientManager} manager - The manager for the Pglite client.\n *\n * @method withDatabase\n * @param {() => Promise<T>} operation - The operation to perform on the database.\n * @return {Promise<T>} - The result of the operation.\n *\n * @method init\n * @return {Promise<void>} - A Promise that resolves when the initialization is complete.\n *\n * @method close\n * @return {void} - A Promise that resolves when the database is closed.\n */\nexport class PgliteDatabaseAdapter extends BaseDrizzleAdapter {\n  private manager: PGliteClientManager;\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n\n  /**\n   * Constructor for creating an instance of a class.\n   * @param {UUID} agentId - The unique identifier for the agent.\n   * @param {PGliteClientManager} manager - The manager for the Pglite client.\n   */\n  constructor(agentId: UUID, manager: PGliteClientManager) {\n    super(agentId);\n    this.manager = manager;\n    this.db = drizzle(this.manager.getConnection() as any);\n  }\n\n  // Methods required by TypeScript but not in base class\n  async getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null> {\n    // Delegate to the correct method name\n    return this.getEntitiesByIds(entityIds);\n  }\n\n  async getMemoriesByServerId(_params: { serverId: UUID; count?: number }): Promise<Memory[]> {\n    // This method doesn't seem to exist in the base implementation\n    // Provide a basic implementation that returns empty array\n    logger.warn('getMemoriesByServerId called but not implemented - returning empty array');\n    return [];\n  }\n\n  async ensureAgentExists(agent: Partial<Agent>): Promise<Agent> {\n    // Check if agent exists, create if not\n    const existingAgent = await this.getAgent(this.agentId);\n    if (existingAgent) {\n      return existingAgent;\n    }\n\n    // Create the agent with required fields\n    const newAgent: Agent = {\n      id: this.agentId,\n      name: agent.name || 'Unknown Agent',\n      username: agent.username,\n      bio: agent.bio || 'An AI agent',\n      createdAt: agent.createdAt || Date.now(),\n      updatedAt: agent.updatedAt || Date.now(),\n    };\n\n    await this.createAgent(newAgent);\n    const createdAgent = await this.getAgent(this.agentId);\n    if (!createdAgent) {\n      throw new Error('Failed to create agent');\n    }\n    return createdAgent;\n  }\n\n  /**\n   * Asynchronously runs the provided database operation while checking if the database is currently shutting down.\n   * If the database is shutting down, a warning is logged and null is returned.\n   *\n   * @param {Function} operation - The database operation to be performed.\n   * @returns {Promise<T>} A promise that resolves with the result of the database operation.\n   */\n  protected async withDatabase<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.manager.isShuttingDown()) {\n      logger.warn('Database is shutting down');\n      return null as unknown as T;\n    }\n    return operation();\n  }\n\n  /**\n   * Asynchronously initializes the database by running migrations.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the database initialization is complete.\n   */\n  async init(): Promise<void> {\n    logger.debug('PGliteDatabaseAdapter initialized, skipping automatic migrations.');\n  }\n\n  /**\n   * Checks if the database connection is ready and active.\n   * For PGLite, this checks if the client is not in a shutting down state.\n   * @returns {Promise<boolean>} A Promise that resolves to true if the connection is healthy.\n   */\n  async isReady(): Promise<boolean> {\n    return !this.manager.isShuttingDown();\n  }\n\n  /**\n   * Asynchronously closes the database.\n   */\n  async close() {\n    await this.manager.close();\n  }\n\n  /**\n   * Asynchronously retrieves the connection from the client.\n   *\n   * @returns {Promise<PGlite>} A Promise that resolves with the connection.\n   */\n  async getConnection() {\n    return this.manager.getConnection();\n  }\n}\n",
    "import { PGlite } from \"@electric-sql/pglite\";\nimport { entityKind } from \"../entity.js\";\nimport { DefaultLogger } from \"../logger.js\";\nimport { PgDatabase } from \"../pg-core/db.js\";\nimport { PgDialect } from \"../pg-core/dialect.js\";\nimport {\n  createTableRelationsHelpers,\n  extractTablesRelationalConfig\n} from \"../relations.js\";\nimport { isConfig } from \"../utils.js\";\nimport { PgliteSession } from \"./session.js\";\nclass PgliteDriver {\n  constructor(client, dialect, options = {}) {\n    this.client = client;\n    this.dialect = dialect;\n    this.options = options;\n  }\n  static [entityKind] = \"PgliteDriver\";\n  createSession(schema) {\n    return new PgliteSession(this.client, this.dialect, schema, {\n      logger: this.options.logger,\n      cache: this.options.cache\n    });\n  }\n}\nclass PgliteDatabase extends PgDatabase {\n  static [entityKind] = \"PgliteDatabase\";\n}\nfunction construct(client, config = {}) {\n  const dialect = new PgDialect({ casing: config.casing });\n  let logger;\n  if (config.logger === true) {\n    logger = new DefaultLogger();\n  } else if (config.logger !== false) {\n    logger = config.logger;\n  }\n  let schema;\n  if (config.schema) {\n    const tablesConfig = extractTablesRelationalConfig(\n      config.schema,\n      createTableRelationsHelpers\n    );\n    schema = {\n      fullSchema: config.schema,\n      schema: tablesConfig.tables,\n      tableNamesMap: tablesConfig.tableNamesMap\n    };\n  }\n  const driver = new PgliteDriver(client, dialect, { logger, cache: config.cache });\n  const session = driver.createSession(schema);\n  const db = new PgliteDatabase(dialect, session, schema);\n  db.$client = client;\n  db.$cache = config.cache;\n  if (db.$cache) {\n    db.$cache[\"invalidate\"] = config.cache?.onMutate;\n  }\n  return db;\n}\nfunction drizzle(...params) {\n  if (params[0] === void 0 || typeof params[0] === \"string\") {\n    const instance = new PGlite(params[0]);\n    return construct(instance, params[1]);\n  }\n  if (isConfig(params[0])) {\n    const { connection, client, ...drizzleConfig } = params[0];\n    if (client) return construct(client, drizzleConfig);\n    if (typeof connection === \"object\") {\n      const { dataDir, ...options } = connection;\n      const instance2 = new PGlite(dataDir, options);\n      return construct(instance2, drizzleConfig);\n    }\n    const instance = new PGlite(connection);\n    return construct(instance, drizzleConfig);\n  }\n  return construct(params[0], params[1]);\n}\n((drizzle2) => {\n  function mock(config) {\n    return construct({}, config);\n  }\n  drizzle2.mock = mock;\n})(drizzle || (drizzle = {}));\nexport {\n  PgliteDatabase,\n  PgliteDriver,\n  drizzle\n};\n//# sourceMappingURL=driver.js.map",
    "import { entityKind } from \"../entity.js\";\nimport { NoopLogger } from \"../logger.js\";\nimport { PgTransaction } from \"../pg-core/index.js\";\nimport { PgPreparedQuery, PgSession } from \"../pg-core/session.js\";\nimport { fillPlaceholders, sql } from \"../sql/sql.js\";\nimport { mapResultRow } from \"../utils.js\";\nimport { types } from \"@electric-sql/pglite\";\nimport { NoopCache } from \"../cache/core/cache.js\";\nclass PglitePreparedQuery extends PgPreparedQuery {\n  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {\n    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);\n    this.client = client;\n    this.queryString = queryString;\n    this.params = params;\n    this.logger = logger;\n    this.fields = fields;\n    this._isResponseInArrayMode = _isResponseInArrayMode;\n    this.customResultMapper = customResultMapper;\n    this.rawQueryConfig = {\n      rowMode: \"object\",\n      parsers: {\n        [types.TIMESTAMP]: (value) => value,\n        [types.TIMESTAMPTZ]: (value) => value,\n        [types.INTERVAL]: (value) => value,\n        [types.DATE]: (value) => value,\n        // numeric[]\n        [1231]: (value) => value,\n        // timestamp[]\n        [1115]: (value) => value,\n        // timestamp with timezone[]\n        [1185]: (value) => value,\n        // interval[]\n        [1187]: (value) => value,\n        // date[]\n        [1182]: (value) => value\n      }\n    };\n    this.queryConfig = {\n      rowMode: \"array\",\n      parsers: {\n        [types.TIMESTAMP]: (value) => value,\n        [types.TIMESTAMPTZ]: (value) => value,\n        [types.INTERVAL]: (value) => value,\n        [types.DATE]: (value) => value,\n        // numeric[]\n        [1231]: (value) => value,\n        // timestamp[]\n        [1115]: (value) => value,\n        // timestamp with timezone[]\n        [1185]: (value) => value,\n        // interval[]\n        [1187]: (value) => value,\n        // date[]\n        [1182]: (value) => value\n      }\n    };\n  }\n  static [entityKind] = \"PglitePreparedQuery\";\n  rawQueryConfig;\n  queryConfig;\n  async execute(placeholderValues = {}) {\n    const params = fillPlaceholders(this.params, placeholderValues);\n    this.logger.logQuery(this.queryString, params);\n    const { fields, client, queryConfig, joinsNotNullableMap, customResultMapper, queryString, rawQueryConfig } = this;\n    if (!fields && !customResultMapper) {\n      return this.queryWithCache(queryString, params, async () => {\n        return await client.query(queryString, params, rawQueryConfig);\n      });\n    }\n    const result = await this.queryWithCache(queryString, params, async () => {\n      return await client.query(queryString, params, queryConfig);\n    });\n    return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));\n  }\n  all(placeholderValues = {}) {\n    const params = fillPlaceholders(this.params, placeholderValues);\n    this.logger.logQuery(this.queryString, params);\n    return this.queryWithCache(this.queryString, params, async () => {\n      return await this.client.query(this.queryString, params, this.rawQueryConfig);\n    }).then((result) => result.rows);\n  }\n  /** @internal */\n  isResponseInArrayMode() {\n    return this._isResponseInArrayMode;\n  }\n}\nclass PgliteSession extends PgSession {\n  constructor(client, dialect, schema, options = {}) {\n    super(dialect);\n    this.client = client;\n    this.schema = schema;\n    this.options = options;\n    this.logger = options.logger ?? new NoopLogger();\n    this.cache = options.cache ?? new NoopCache();\n  }\n  static [entityKind] = \"PgliteSession\";\n  logger;\n  cache;\n  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {\n    return new PglitePreparedQuery(\n      this.client,\n      query.sql,\n      query.params,\n      this.logger,\n      this.cache,\n      queryMetadata,\n      cacheConfig,\n      fields,\n      name,\n      isResponseInArrayMode,\n      customResultMapper\n    );\n  }\n  async transaction(transaction, config) {\n    return this.client.transaction(async (client) => {\n      const session = new PgliteSession(\n        client,\n        this.dialect,\n        this.schema,\n        this.options\n      );\n      const tx = new PgliteTransaction(this.dialect, session, this.schema);\n      if (config) {\n        await tx.setTransaction(config);\n      }\n      return transaction(tx);\n    });\n  }\n  async count(sql2) {\n    const res = await this.execute(sql2);\n    return Number(\n      res[\"rows\"][0][\"count\"]\n    );\n  }\n}\nclass PgliteTransaction extends PgTransaction {\n  static [entityKind] = \"PgliteTransaction\";\n  async transaction(transaction) {\n    const savepointName = `sp${this.nestedIndex + 1}`;\n    const tx = new PgliteTransaction(\n      this.dialect,\n      this.session,\n      this.schema,\n      this.nestedIndex + 1\n    );\n    await tx.execute(sql.raw(`savepoint ${savepointName}`));\n    try {\n      const result = await transaction(tx);\n      await tx.execute(sql.raw(`release savepoint ${savepointName}`));\n      return result;\n    } catch (err) {\n      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));\n      throw err;\n    }\n  }\n}\nexport {\n  PglitePreparedQuery,\n  PgliteSession,\n  PgliteTransaction\n};\n//# sourceMappingURL=session.js.map",
    "import {\n  type Agent,\n  ChannelType,\n  type Component,\n  DatabaseAdapter,\n  type Entity,\n  type Log,\n  logger,\n  type Memory,\n  type MemoryMetadata,\n  type Participant,\n  type Relationship,\n  type Room,\n  RoomMetadata,\n  type Task,\n  TaskMetadata,\n  type UUID,\n  type World,\n  type AgentRunSummary,\n  type AgentRunSummaryResult,\n  type RunStatus,\n  type AgentRunCounts,\n} from '@elizaos/core';\nimport type { DatabaseMigrationService } from './migration-service';\nimport {\n  and,\n  cosineDistance,\n  count,\n  desc,\n  eq,\n  gte,\n  inArray,\n  lt,\n  lte,\n  or,\n  SQL,\n  sql,\n} from 'drizzle-orm';\nimport { v4 } from 'uuid';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from './schema/embedding';\nimport {\n  agentTable,\n  cacheTable,\n  channelParticipantsTable,\n  channelTable,\n  componentTable,\n  embeddingTable,\n  entityTable,\n  logTable,\n  memoryTable,\n  messageServerTable,\n  messageTable,\n  participantTable,\n  relationshipTable,\n  roomTable,\n  serverAgentsTable,\n  taskTable,\n  worldTable,\n} from './schema/index';\n\n// Define the metadata type inline since we can't import it\n/**\n * Represents metadata information about memory.\n * @typedef {Object} MemoryMetadata\n * @property {string} type - The type of memory.\n * @property {string} [source] - The source of the memory.\n * @property {UUID} [sourceId] - The ID of the source.\n * @property {string} [scope] - The scope of the memory.\n * @property {number} [timestamp] - The timestamp of the memory.\n * @property {string[]} [tags] - The tags associated with the memory.\n * @property {UUID} [documentId] - The ID of the document associated with the memory.\n * @property {number} [position] - The position of the memory.\n */\n\n/**\n * Abstract class representing a base Drizzle adapter for working with databases.\n * This adapter provides a comprehensive set of methods for interacting with a database\n * using Drizzle ORM. It implements the DatabaseAdapter interface and handles operations\n * for various entity types including agents, entities, components, memories, rooms,\n * participants, relationships, tasks, and more.\n *\n * The adapter includes built-in retry logic for database operations, embedding dimension\n * management, and transaction support. Concrete implementations must provide the\n * withDatabase method to execute operations against their specific database.\n */\nexport abstract class BaseDrizzleAdapter extends DatabaseAdapter<any> {\n  protected readonly maxRetries: number = 3;\n  protected readonly baseDelay: number = 1000;\n  protected readonly maxDelay: number = 10000;\n  protected readonly jitterMax: number = 1000;\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n  protected migrationService?: DatabaseMigrationService;\n\n  protected abstract withDatabase<T>(operation: () => Promise<T>): Promise<T>;\n  public abstract init(): Promise<void>;\n  public abstract close(): Promise<void>;\n\n  /**\n   * Initialize method that can be overridden by implementations\n   */\n  public async initialize(): Promise<void> {\n    await this.init();\n  }\n\n  /**\n   * Run plugin schema migrations for all registered plugins\n   * @param plugins Array of plugins with their schemas\n   * @param options Migration options (verbose, force, dryRun, etc.)\n   */\n  public async runPluginMigrations(\n    plugins: Array<{ name: string; schema?: any }>,\n    options?: {\n      verbose?: boolean;\n      force?: boolean;\n      dryRun?: boolean;\n    }\n  ): Promise<void> {\n    // Initialize migration service if not already done\n    if (!this.migrationService) {\n      const { DatabaseMigrationService } = await import('./migration-service');\n      this.migrationService = new DatabaseMigrationService();\n      await this.migrationService.initializeWithDatabase(this.db);\n    }\n\n    // Register plugin schemas\n    for (const plugin of plugins) {\n      if (plugin.schema) {\n        this.migrationService.registerSchema(plugin.name, plugin.schema);\n      }\n    }\n\n    // Run migrations with options\n    await this.migrationService.runAllPluginMigrations(options);\n  }\n\n  /**\n   * Get the underlying database instance for testing purposes\n   */\n  public getDatabase(): any {\n    return this.db;\n  }\n\n  protected agentId: UUID;\n\n  /**\n   * Constructor for creating a new instance of Agent with the specified agentId.\n   *\n   * @param {UUID} agentId - The unique identifier for the agent.\n   */\n  constructor(agentId: UUID) {\n    super();\n    this.agentId = agentId;\n  }\n\n  /**\n   * Executes the given operation with retry logic.\n   * @template T\n   * @param {() => Promise<T>} operation - The operation to be executed.\n   * @returns {Promise<T>} A promise that resolves with the result of the operation.\n   */\n  protected async withRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n\n        if (attempt < this.maxRetries) {\n          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);\n\n          const jitter = Math.random() * this.jitterMax;\n          const delay = backoffDelay + jitter;\n\n          logger.warn(\n            `Database operation failed (attempt ${attempt}/${this.maxRetries}): ${error instanceof Error ? error.message : String(error)}, nextRetryIn: ${(delay / 1000).toFixed(1)}s`\n          );\n\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } else {\n          logger.error(\n            `Max retry attempts reached: ${error instanceof Error ? error.message : String(error)}, totalAttempts: ${attempt}`\n          );\n          throw error instanceof Error ? error : new Error(String(error));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Asynchronously ensures that the given embedding dimension is valid for the agent.\n   *\n   * @param {number} dimension - The dimension to ensure for the embedding.\n   * @returns {Promise<void>} - Resolves once the embedding dimension is ensured.\n   */\n  async ensureEmbeddingDimension(dimension: number) {\n    return this.withDatabase(async () => {\n      const existingMemory = await this.db\n        .select()\n        .from(memoryTable)\n        .innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(eq(memoryTable.agentId, this.agentId))\n        .limit(1);\n\n      if (existingMemory.length > 0) {\n        Object.entries(DIMENSION_MAP).find(\n          ([_, colName]) => (existingMemory[0] as any).embeddings[colName] !== null\n        );\n        // We don't actually need to use usedDimension for now, but it's good to know it's there.\n      }\n\n      this.embeddingDimension = DIMENSION_MAP[dimension];\n    });\n  }\n\n  /**\n   * Asynchronously retrieves an agent by their ID from the database.\n   * @param {UUID} agentId - The ID of the agent to retrieve.\n   * @returns {Promise<Agent | null>} A promise that resolves to the retrieved agent or null if not found.\n   */\n  async getAgent(agentId: UUID): Promise<Agent | null> {\n    return this.withDatabase(async () => {\n      const rows = await this.db\n        .select()\n        .from(agentTable)\n        .where(eq(agentTable.id, agentId))\n        .limit(1);\n\n      if (rows.length === 0) return null;\n\n      const row = rows[0];\n      return {\n        ...row,\n        username: row.username || '',\n        id: row.id as UUID,\n        system: !row.system ? undefined : row.system,\n        bio: !row.bio ? '' : row.bio,\n        createdAt: row.createdAt.getTime(),\n        updatedAt: row.updatedAt.getTime(),\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a list of agents from the database.\n   *\n   * @returns {Promise<Partial<Agent>[]>} A Promise that resolves to an array of Agent objects.\n   */\n  async getAgents(): Promise<Partial<Agent>[]> {\n    const result = await this.withDatabase(async () => {\n      const rows = await this.db\n        .select({\n          id: agentTable.id,\n          name: agentTable.name,\n          bio: agentTable.bio,\n        })\n        .from(agentTable);\n      return rows.map((row) => ({\n        ...row,\n        id: row.id as UUID,\n        bio: row.bio === null ? '' : row.bio,\n      }));\n    });\n    // Guard against null return\n    return result || [];\n  }\n  /**\n   * Asynchronously creates a new agent record in the database.\n   *\n   * @param {Partial<Agent>} agent The agent object to be created.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createAgent(agent: Agent): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        // Check for existing agent with the same ID or name\n        // Check for existing agent with the same ID or name\n        const conditions: (SQL<unknown> | undefined)[] = [];\n        if (agent.id) {\n          conditions.push(eq(agentTable.id, agent.id));\n        }\n        if (agent.name) {\n          conditions.push(eq(agentTable.name, agent.name));\n        }\n\n        const existing =\n          conditions.length > 0\n            ? await this.db\n                .select({ id: agentTable.id })\n                .from(agentTable)\n                .where(or(...conditions))\n                .limit(1)\n            : [];\n\n        if (existing.length > 0) {\n          logger.warn(\n            `Attempted to create an agent with a duplicate ID or name. ID: ${agent.id}, name: ${agent.name}`\n          );\n          return false;\n        }\n\n        await this.db.transaction(async (tx) => {\n          await tx.insert(agentTable).values({\n            ...agent,\n            createdAt: new Date(agent.createdAt || Date.now()),\n            updatedAt: new Date(agent.updatedAt || Date.now()),\n          });\n        });\n\n        logger.debug(`Agent created successfully: ${agent.id}`);\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error creating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agent.id}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Updates an agent in the database with the provided agent ID and data.\n   * @param {UUID} agentId - The unique identifier of the agent to update.\n   * @param {Partial<Agent>} agent - The partial agent object containing the fields to update.\n   * @returns {Promise<boolean>} - A boolean indicating if the agent was successfully updated.\n   */\n  async updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        if (!agentId) {\n          throw new Error('Agent ID is required for update');\n        }\n\n        await this.db.transaction(async (tx) => {\n          // Handle settings update if present\n          if (agent?.settings) {\n            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);\n          }\n\n          // Convert numeric timestamps to Date objects for database storage\n          // The Agent interface uses numbers, but the database schema expects Date objects\n          const updateData: any = { ...agent };\n          if (updateData.createdAt) {\n            if (typeof updateData.createdAt === 'number') {\n              updateData.createdAt = new Date(updateData.createdAt);\n            } else {\n              delete updateData.createdAt; // Don't update createdAt if it's not a valid timestamp\n            }\n          }\n          if (updateData.updatedAt) {\n            if (typeof updateData.updatedAt === 'number') {\n              updateData.updatedAt = new Date(updateData.updatedAt);\n            } else {\n              updateData.updatedAt = new Date(); // Use current time if invalid\n            }\n          } else {\n            updateData.updatedAt = new Date(); // Always set updatedAt to current time\n          }\n\n          await tx.update(agentTable).set(updateData).where(eq(agentTable.id, agentId));\n        });\n\n        logger.debug(`Agent updated successfully: ${agentId}`);\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error updating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agentId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Merges updated agent settings with existing settings in the database,\n   * with special handling for nested objects like secrets.\n   * @param tx - The database transaction\n   * @param agentId - The ID of the agent\n   * @param updatedSettings - The settings object with updates\n   * @returns The merged settings object\n   * @private\n   */\n  private async mergeAgentSettings(tx: any, agentId: UUID, updatedSettings: any): Promise<any> {\n    // First get the current agent data\n    const currentAgent = await tx\n      .select({ settings: agentTable.settings })\n      .from(agentTable)\n      .where(eq(agentTable.id, agentId))\n      .limit(1);\n\n    const currentSettings =\n      currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};\n\n    const deepMerge = (target: any, source: any): any => {\n      // If source is explicitly null, it means the intention is to set this entire branch to null (or delete if top-level handled by caller).\n      // For recursive calls, if a sub-object in source is null, it effectively means \"remove this sub-object from target\".\n      // However, our primary deletion signal is a *property value* being null within an object.\n      if (source === null) {\n        // If the entire source for a given key is null, we treat it as \"delete this key from target\"\n        // by returning undefined, which the caller can use to delete the key.\n        return undefined;\n      }\n\n      // If source is an array or a primitive, it replaces the target value.\n      if (Array.isArray(source) || typeof source !== 'object') {\n        return source;\n      }\n\n      // Initialize output. If target is not an object, start with an empty one to merge source into.\n      const output =\n        typeof target === 'object' && target !== null && !Array.isArray(target)\n          ? { ...target }\n          : {};\n\n      for (const key of Object.keys(source)) {\n        // Iterate over source keys\n        const sourceValue = source[key];\n\n        if (sourceValue === null) {\n          // If a value in source is null, delete the corresponding key from output.\n          delete output[key];\n        } else if (typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {\n          // If value is an object, recurse.\n          const nestedMergeResult = deepMerge(output[key], sourceValue);\n          if (nestedMergeResult === undefined) {\n            // If recursive merge resulted in undefined (meaning the nested object should be deleted)\n            delete output[key];\n          } else {\n            output[key] = nestedMergeResult;\n          }\n        } else {\n          // Primitive or array value from source, assign it.\n          output[key] = sourceValue;\n        }\n      }\n\n      // After processing all keys from source, check if output became empty.\n      // An object is empty if all its keys were deleted or resulted in undefined.\n      // This is a more direct check than iterating 'output' after building it.\n      if (Object.keys(output).length === 0) {\n        // If the source itself was not an explicitly empty object,\n        // and the merge resulted in an empty object, signal deletion.\n        if (!(typeof source === 'object' && source !== null && Object.keys(source).length === 0)) {\n          return undefined; // Signal to delete this (parent) key if it became empty.\n        }\n      }\n\n      return output;\n    }; // End of deepMerge\n\n    const finalSettings = deepMerge(currentSettings, updatedSettings);\n    // If the entire settings object becomes undefined (e.g. all keys removed),\n    // return an empty object instead of undefined/null to keep the settings field present.\n    return finalSettings === undefined ? {} : finalSettings;\n  }\n\n  /**\n   * Asynchronously deletes an agent with the specified UUID and all related entries.\n   *\n   * @param {UUID} agentId - The UUID of the agent to be deleted.\n   * @returns {Promise<boolean>} - A boolean indicating if the deletion was successful.\n   */\n  async deleteAgent(agentId: UUID): Promise<boolean> {\n    logger.debug(`[DB] Deleting agent with ID: ${agentId}`);\n\n    return this.withDatabase(async () => {\n      try {\n        // Simply delete the agent - all related data will be cascade deleted\n        const result = await this.db\n          .delete(agentTable)\n          .where(eq(agentTable.id, agentId))\n          .returning();\n\n        if (result.length === 0) {\n          logger.warn(`[DB] Agent ${agentId} not found`);\n          return false;\n        }\n\n        logger.success(\n          `[DB] Agent ${agentId} and all related data successfully deleted via cascade`\n        );\n        return true;\n      } catch (error) {\n        logger.error(\n          `[DB] Failed to delete agent ${agentId}: ${error instanceof Error ? error.message : String(error)}`\n        );\n        if (error instanceof Error) {\n          logger.error(`[DB] Error details: ${error.name} - ${error.message}`);\n          logger.error(`[DB] Stack trace: ${error.stack}`);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Count all agents in the database\n   * Used primarily for maintenance and cleanup operations\n   */\n  /**\n   * Asynchronously counts the number of agents in the database.\n   * @returns {Promise<number>} A Promise that resolves to the number of agents in the database.\n   */\n  async countAgents(): Promise<number> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db.select({ count: count() }).from(agentTable);\n\n        return result[0]?.count || 0;\n      } catch (error) {\n        logger.error(\n          `Error counting agents: ${error instanceof Error ? error.message : String(error)}`\n        );\n        return 0;\n      }\n    });\n  }\n\n  /**\n   * Clean up the agents table by removing all agents\n   * This is used during server startup to ensure no orphaned agents exist\n   * from previous crashes or improper shutdowns\n   */\n  async cleanupAgents(): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.delete(agentTable);\n        logger.success('Successfully cleaned up agent table');\n      } catch (error) {\n        logger.error(\n          `Error cleaning up agent table: ${error instanceof Error ? error.message : String(error)}`\n        );\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves an entity and its components by entity IDs.\n   * @param {UUID[]} entityIds - The unique identifiers of the entities to retrieve.\n   * @returns {Promise<Entity[] | null>} A Promise that resolves to the entity with its components if found, null otherwise.\n   */\n  async getEntitiesByIds(entityIds: UUID[]): Promise<Entity[] | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          entity: entityTable,\n          components: componentTable,\n        })\n        .from(entityTable)\n        .leftJoin(componentTable, eq(componentTable.entityId, entityTable.id))\n        .where(inArray(entityTable.id, entityIds));\n\n      if (result.length === 0) return [];\n\n      // Group components by entity\n      const entities: Record<UUID, Entity> = {};\n      const entityComponents: Record<UUID, Entity['components']> = {};\n      for (const e of result) {\n        const key = e.entity.id;\n        entities[key] = e.entity;\n        if (entityComponents[key] === undefined) entityComponents[key] = [];\n        if (e.components) {\n          // Handle both single component and array of components\n          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];\n          entityComponents[key] = [...entityComponents[key], ...componentsArray];\n        }\n      }\n      for (const k of Object.keys(entityComponents)) {\n        entities[k].components = entityComponents[k];\n      }\n\n      return Object.values(entities);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all entities for a given room, optionally including their components.\n   * @param {UUID} roomId - The unique identifier of the room to get entities for\n   * @param {boolean} [includeComponents] - Whether to include component data for each entity\n   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities in the room\n   */\n  async getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]> {\n    return this.withDatabase(async () => {\n      const query = this.db\n        .select({\n          entity: entityTable,\n          ...(includeComponents && { components: componentTable }),\n        })\n        .from(participantTable)\n        .leftJoin(\n          entityTable,\n          and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId))\n        );\n\n      if (includeComponents) {\n        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));\n      }\n\n      const result = await query.where(eq(participantTable.roomId, roomId));\n\n      // Group components by entity if includeComponents is true\n      const entitiesByIdMap = new Map<UUID, Entity>();\n\n      for (const row of result) {\n        if (!row.entity) continue;\n\n        const entityId = row.entity.id as UUID;\n        if (!entitiesByIdMap.has(entityId)) {\n          const entity: Entity = {\n            ...row.entity,\n            id: entityId,\n            agentId: row.entity.agentId as UUID,\n            metadata: row.entity.metadata as { [key: string]: any },\n            components: includeComponents ? [] : undefined,\n          };\n          entitiesByIdMap.set(entityId, entity);\n        }\n\n        if (includeComponents && row.components) {\n          const entity = entitiesByIdMap.get(entityId);\n          if (entity) {\n            if (!entity.components) {\n              entity.components = [];\n            }\n            entity.components.push(row.components);\n          }\n        }\n      }\n\n      return Array.from(entitiesByIdMap.values());\n    });\n  }\n\n  /**\n   * Asynchronously creates new entities in the database.\n   * @param {Entity[]} entities - The entity objects to be created.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createEntities(entities: Entity[]): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        return await this.db.transaction(async (tx) => {\n          await tx.insert(entityTable).values(entities);\n\n          logger.debug(`${entities.length} Entities created successfully`);\n\n          return true;\n        });\n      } catch (error) {\n        logger.error(\n          `Error creating entities, entityId: ${entities[0].id}, (metadata?.)name: ${entities[0].metadata?.name}`,\n          error instanceof Error ? error.message : String(error)\n        );\n        // trace the full error with stack\n        if (error instanceof Error && error.stack) {\n          logger.trace('Stack trace:', error.stack);\n        }\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously ensures an entity exists, creating it if it doesn't\n   * @param entity The entity to ensure exists\n   * @returns Promise resolving to boolean indicating success\n   */\n  protected async ensureEntityExists(entity: Entity): Promise<boolean> {\n    if (!entity.id) {\n      logger.error('Entity ID is required for ensureEntityExists');\n      return false;\n    }\n\n    try {\n      const existingEntities = await this.getEntitiesByIds([entity.id]);\n\n      if (!existingEntities || !existingEntities.length) {\n        return await this.createEntities([entity]);\n      }\n\n      return true;\n    } catch (error) {\n      logger.error(\n        `Error ensuring entity exists: ${error instanceof Error ? error.message : String(error)}, entityId: ${entity.id}`\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Asynchronously updates an entity in the database.\n   * @param {Entity} entity - The entity object to be updated.\n   * @returns {Promise<void>} A Promise that resolves when the entity is updated.\n   */\n  async updateEntity(entity: Entity): Promise<void> {\n    if (!entity.id) {\n      throw new Error('Entity ID is required for update');\n    }\n    return this.withDatabase(async () => {\n      await this.db\n        .update(entityTable)\n        .set(entity)\n        .where(eq(entityTable.id, entity.id as string));\n    });\n  }\n\n  /**\n   * Asynchronously deletes an entity from the database based on the provided ID.\n   * @param {UUID} entityId - The ID of the entity to delete.\n   * @returns {Promise<void>} A Promise that resolves when the entity is deleted.\n   */\n  async deleteEntity(entityId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // Delete related components first\n        await tx\n          .delete(componentTable)\n          .where(\n            or(eq(componentTable.entityId, entityId), eq(componentTable.sourceEntityId, entityId))\n          );\n\n        // Delete the entity\n        await tx.delete(entityTable).where(eq(entityTable.id, entityId));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves entities by their names and agentId.\n   * @param {Object} params - The parameters for retrieving entities.\n   * @param {string[]} params.names - The names to search for.\n   * @param {UUID} params.agentId - The agent ID to filter by.\n   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities.\n   */\n  async getEntitiesByNames(params: { names: string[]; agentId: UUID }): Promise<Entity[]> {\n    return this.withDatabase(async () => {\n      const { names, agentId } = params;\n\n      // Build a condition to match any of the names\n      const nameConditions = names.map((name) => sql`${name} = ANY(${entityTable.names})`);\n\n      const query = sql`\n        SELECT * FROM ${entityTable}\n        WHERE ${entityTable.agentId} = ${agentId}\n        AND (${sql.join(nameConditions, sql` OR `)})\n      `;\n\n      const result = await this.db.execute(query);\n\n      return result.rows.map((row: any) => ({\n        id: row.id as UUID,\n        agentId: row.agentId as UUID,\n        names: row.names || [],\n        metadata: row.metadata || {},\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously searches for entities by name with fuzzy matching.\n   * @param {Object} params - The parameters for searching entities.\n   * @param {string} params.query - The search query.\n   * @param {UUID} params.agentId - The agent ID to filter by.\n   * @param {number} params.limit - The maximum number of results to return.\n   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities.\n   */\n  async searchEntitiesByName(params: {\n    query: string;\n    agentId: UUID;\n    limit?: number;\n  }): Promise<Entity[]> {\n    return this.withDatabase(async () => {\n      const { query, agentId, limit = 10 } = params;\n\n      // If query is empty, return all entities up to limit\n      if (!query || query.trim() === '') {\n        const result = await this.db\n          .select()\n          .from(entityTable)\n          .where(eq(entityTable.agentId, agentId))\n          .limit(limit);\n\n        return result.map((row: any) => ({\n          id: row.id as UUID,\n          agentId: row.agentId as UUID,\n          names: row.names || [],\n          metadata: row.metadata || {},\n        }));\n      }\n\n      // Otherwise, search for entities with names containing the query (case-insensitive)\n      const searchQuery = sql`\n        SELECT * FROM ${entityTable}\n        WHERE ${entityTable.agentId} = ${agentId}\n        AND EXISTS (\n          SELECT 1 FROM unnest(${entityTable.names}) AS name\n          WHERE LOWER(name) LIKE LOWER(${'%' + query + '%'})\n        )\n        LIMIT ${limit}\n      `;\n\n      const result = await this.db.execute(searchQuery);\n\n      return result.rows.map((row: any) => ({\n        id: row.id as UUID,\n        agentId: row.agentId as UUID,\n        names: row.names || [],\n        metadata: row.metadata || {},\n      }));\n    });\n  }\n\n  async getComponent(\n    entityId: UUID,\n    type: string,\n    worldId?: UUID,\n    sourceEntityId?: UUID\n  ): Promise<Component | null> {\n    return this.withDatabase(async () => {\n      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];\n\n      if (worldId) {\n        conditions.push(eq(componentTable.worldId, worldId));\n      }\n\n      if (sourceEntityId) {\n        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));\n      }\n\n      const result = await this.db\n        .select()\n        .from(componentTable)\n        .where(and(...conditions));\n\n      if (result.length === 0) return null;\n\n      const component = result[0];\n\n      return {\n        ...component,\n        id: component.id as UUID,\n        entityId: component.entityId as UUID,\n        agentId: component.agentId as UUID,\n        roomId: component.roomId as UUID,\n        worldId: (component.worldId ?? '') as UUID,\n        sourceEntityId: (component.sourceEntityId ?? '') as UUID,\n        data: component.data as { [key: string]: any },\n        createdAt: component.createdAt.getTime(),\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all components for a given entity, optionally filtered by world and source entity.\n   * @param {UUID} entityId - The unique identifier of the entity to retrieve components for\n   * @param {UUID} [worldId] - Optional world ID to filter components by\n   * @param {UUID} [sourceEntityId] - Optional source entity ID to filter components by\n   * @returns {Promise<Component[]>} A Promise that resolves to an array of components\n   */\n  async getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]> {\n    return this.withDatabase(async () => {\n      const conditions = [eq(componentTable.entityId, entityId)];\n\n      if (worldId) {\n        conditions.push(eq(componentTable.worldId, worldId));\n      }\n\n      if (sourceEntityId) {\n        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));\n      }\n\n      const result = await this.db\n        .select({\n          id: componentTable.id,\n          entityId: componentTable.entityId,\n          type: componentTable.type,\n          data: componentTable.data,\n          worldId: componentTable.worldId,\n          agentId: componentTable.agentId,\n          roomId: componentTable.roomId,\n          sourceEntityId: componentTable.sourceEntityId,\n          createdAt: componentTable.createdAt,\n        })\n        .from(componentTable)\n        .where(and(...conditions));\n\n      if (result.length === 0) return [];\n\n      const components = result.map((component) => ({\n        ...component,\n        id: component.id as UUID,\n        entityId: component.entityId as UUID,\n        agentId: component.agentId as UUID,\n        roomId: component.roomId as UUID,\n        worldId: (component.worldId ?? '') as UUID,\n        sourceEntityId: (component.sourceEntityId ?? '') as UUID,\n        data: component.data as { [key: string]: any },\n        createdAt: component.createdAt.getTime(),\n      }));\n\n      return components;\n    });\n  }\n\n  /**\n   * Asynchronously creates a new component in the database.\n   * @param {Component} component - The component object to be created.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.\n   */\n  async createComponent(component: Component): Promise<boolean> {\n    return this.withDatabase(async () => {\n      await this.db.insert(componentTable).values({\n        ...component,\n        createdAt: new Date(),\n      });\n      return true;\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing component in the database.\n   * @param {Component} component - The component object to be updated.\n   * @returns {Promise<void>} A Promise that resolves when the component is updated.\n   */\n  async updateComponent(component: Component): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .update(componentTable)\n          .set({\n            ...component,\n            updatedAt: new Date(),\n          })\n          .where(eq(componentTable.id, component.id));\n      } catch (e) {\n        console.error('updateComponent error', e);\n      }\n    });\n  }\n\n  /**\n   * Asynchronously deletes a component from the database.\n   * @param {UUID} componentId - The unique identifier of the component to delete.\n   * @returns {Promise<void>} A Promise that resolves when the component is deleted.\n   */\n  async deleteComponent(componentId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID} params.roomId - The ID of the room to retrieve memories for.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.tableName] - The name of the table to retrieve memories from.\n   * @param {number} [params.start] - The start date to retrieve memories from.\n   * @param {number} [params.end] - The end date to retrieve memories from.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemories(params: {\n    entityId?: UUID;\n    agentId?: UUID;\n    count?: number;\n    unique?: boolean;\n    tableName: string;\n    start?: number;\n    end?: number;\n    roomId?: UUID;\n    worldId?: UUID;\n  }): Promise<Memory[]> {\n    const { entityId, agentId, roomId, worldId, tableName, unique, start, end } = params;\n\n    if (!tableName) throw new Error('tableName is required');\n\n    return this.withDatabase(async () => {\n      const conditions = [eq(memoryTable.type, tableName)];\n\n      if (start) {\n        conditions.push(gte(memoryTable.createdAt, new Date(start)));\n      }\n\n      if (entityId) {\n        conditions.push(eq(memoryTable.entityId, entityId));\n      }\n\n      if (roomId) {\n        conditions.push(eq(memoryTable.roomId, roomId));\n      }\n\n      // Add worldId condition\n      if (worldId) {\n        conditions.push(eq(memoryTable.worldId, worldId));\n      }\n\n      if (end) {\n        conditions.push(lte(memoryTable.createdAt, new Date(end)));\n      }\n\n      if (unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      if (agentId) {\n        conditions.push(eq(memoryTable.agentId, agentId));\n      }\n\n      const query = this.db\n        .select({\n          memory: {\n            id: memoryTable.id,\n            type: memoryTable.type,\n            createdAt: memoryTable.createdAt,\n            content: memoryTable.content,\n            entityId: memoryTable.entityId,\n            agentId: memoryTable.agentId,\n            roomId: memoryTable.roomId,\n            unique: memoryTable.unique,\n            metadata: memoryTable.metadata,\n          },\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      const rows = params.count ? await query.limit(params.count) : await query;\n\n      return rows.map((row) => ({\n        id: row.memory.id as UUID,\n        type: row.memory.type,\n        createdAt: row.memory.createdAt.getTime(),\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ? Array.from(row.embedding) : undefined,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID[]} params.roomIds - The IDs of the rooms to retrieve memories for.\n   * @param {string} params.tableName - The name of the table to retrieve memories from.\n   * @param {number} [params.limit] - The maximum number of memories to retrieve.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemoriesByRoomIds(params: {\n    roomIds: UUID[];\n    tableName: string;\n    limit?: number;\n  }): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      if (params.roomIds.length === 0) return [];\n\n      const conditions = [\n        eq(memoryTable.type, params.tableName),\n        inArray(memoryTable.roomId, params.roomIds),\n      ];\n\n      conditions.push(eq(memoryTable.agentId, this.agentId));\n\n      const query = this.db\n        .select({\n          id: memoryTable.id,\n          type: memoryTable.type,\n          createdAt: memoryTable.createdAt,\n          content: memoryTable.content,\n          entityId: memoryTable.entityId,\n          agentId: memoryTable.agentId,\n          roomId: memoryTable.roomId,\n          unique: memoryTable.unique,\n          metadata: memoryTable.metadata,\n        })\n        .from(memoryTable)\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      const rows = params.limit ? await query.limit(params.limit) : await query;\n\n      return rows.map((row) => ({\n        id: row.id as UUID,\n        createdAt: row.createdAt.getTime(),\n        content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\n        entityId: row.entityId as UUID,\n        agentId: row.agentId as UUID,\n        roomId: row.roomId as UUID,\n        unique: row.unique,\n        metadata: row.metadata,\n      })) as Memory[];\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a memory by its unique identifier.\n   * @param {UUID} id - The unique identifier of the memory to retrieve.\n   * @returns {Promise<Memory | null>} A Promise that resolves to the memory if found, null otherwise.\n   */\n  async getMemoryById(id: UUID): Promise<Memory | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          memory: memoryTable,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId))\n        .where(eq(memoryTable.id, id))\n        .limit(1);\n\n      if (result.length === 0) return null;\n\n      const row = result[0];\n      return {\n        id: row.memory.id as UUID,\n        createdAt: row.memory.createdAt.getTime(),\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves memories from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving memories.\n   * @param {UUID[]} params.memoryIds - The IDs of the memories to retrieve.\n   * @param {string} [params.tableName] - The name of the table to retrieve memories from.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      if (memoryIds.length === 0) return [];\n\n      const conditions = [inArray(memoryTable.id, memoryIds)];\n\n      if (tableName) {\n        conditions.push(eq(memoryTable.type, tableName));\n      }\n\n      const rows = await this.db\n        .select({\n          memory: memoryTable,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(memoryTable)\n        .leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id))\n        .where(and(...conditions))\n        .orderBy(desc(memoryTable.createdAt));\n\n      return rows.map((row) => ({\n        id: row.memory.id as UUID,\n        createdAt: row.memory.createdAt.getTime(),\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves cached embeddings from the database based on the provided parameters.\n   * @param {Object} opts - The parameters for retrieving cached embeddings.\n   * @param {string} opts.query_table_name - The name of the table to retrieve embeddings from.\n   * @param {number} opts.query_threshold - The threshold for the levenshtein distance.\n   * @param {string} opts.query_input - The input string to search for.\n   * @param {string} opts.query_field_name - The name of the field to retrieve embeddings from.\n   * @param {string} opts.query_field_sub_name - The name of the sub-field to retrieve embeddings from.\n   * @param {number} opts.query_match_count - The maximum number of matches to retrieve.\n   * @returns {Promise<{ embedding: number[]; levenshtein_score: number }[]>} A Promise that resolves to an array of cached embeddings.\n   */\n  async getCachedEmbeddings(opts: {\n    query_table_name: string;\n    query_threshold: number;\n    query_input: string;\n    query_field_name: string;\n    query_field_sub_name: string;\n    query_match_count: number;\n  }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\n    return this.withDatabase(async () => {\n      try {\n        const results = await (this.db as any).execute(sql`\n                    WITH content_text AS (\n                        SELECT\n                            m.id,\n                            COALESCE(\n                                m.content->>${opts.query_field_sub_name},\n                                ''\n                            ) as content_text\n                        FROM memories m\n                        WHERE m.type = ${opts.query_table_name}\n                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL\n                    ),\n                    embedded_text AS (\n                        SELECT\n                            ct.content_text,\n                            COALESCE(\n                                e.dim_384,\n                                e.dim_512,\n                                e.dim_768,\n                                e.dim_1024,\n                                e.dim_1536,\n                                e.dim_3072\n                            ) as embedding\n                        FROM content_text ct\n                        LEFT JOIN embeddings e ON e.memory_id = ct.id\n                        WHERE e.memory_id IS NOT NULL\n                    )\n                    SELECT\n                        embedding,\n                        levenshtein(${opts.query_input}, content_text) as levenshtein_score\n                    FROM embedded_text\n                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}\n                    ORDER BY levenshtein_score\n                    LIMIT ${opts.query_match_count}\n                `);\n\n        return results.rows\n          .map((row) => ({\n            embedding: Array.isArray(row.embedding)\n              ? row.embedding\n              : typeof row.embedding === 'string'\n                ? JSON.parse(row.embedding)\n                : [],\n            levenshtein_score: Number(row.levenshtein_score),\n          }))\n          .filter((row) => Array.isArray(row.embedding));\n      } catch (error) {\n        logger.error(\n          `Error in getCachedEmbeddings: ${error instanceof Error ? error.message : String(error)}, tableName: ${opts.query_table_name}, fieldName: ${opts.query_field_name}`\n        );\n        if (\n          error instanceof Error &&\n          error.message === 'levenshtein argument exceeds maximum length of 255 characters'\n        ) {\n          return [];\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously logs an event in the database.\n   * @param {Object} params - The parameters for logging an event.\n   * @param {Object} params.body - The body of the event to log.\n   * @param {UUID} params.entityId - The ID of the entity associated with the event.\n   * @param {UUID} params.roomId - The ID of the room associated with the event.\n   * @param {string} params.type - The type of the event to log.\n   * @returns {Promise<void>} A Promise that resolves when the event is logged.\n   */\n  async log(params: {\n    body: { [key: string]: unknown };\n    entityId: UUID;\n    roomId: UUID;\n    type: string;\n  }): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        // Sanitize JSON body to prevent Unicode escape sequence errors\n        const sanitizedBody = this.sanitizeJsonObject(params.body);\n\n        // Serialize to JSON string first for an additional layer of protection\n        // This ensures any problematic characters are properly escaped during JSON serialization\n        const jsonString = JSON.stringify(sanitizedBody);\n\n        await this.db.transaction(async (tx) => {\n          await tx.insert(logTable).values({\n            body: sql`${jsonString}::jsonb`,\n            entityId: params.entityId,\n            roomId: params.roomId,\n            type: params.type,\n          });\n        });\n      } catch (error) {\n        logger.error(\n          `Failed to create log entry: ${error instanceof Error ? error.message : String(error)}, type: ${params.type}, roomId: ${params.roomId}, entityId: ${params.entityId}`\n        );\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Sanitizes a JSON object by replacing problematic Unicode escape sequences\n   * that could cause errors during JSON serialization/storage\n   *\n   * @param value - The value to sanitize\n   * @returns The sanitized value\n   */\n  private sanitizeJsonObject(value: unknown, seen: WeakSet<object> = new WeakSet()): unknown {\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      // Handle multiple cases that can cause PostgreSQL/PgLite JSON parsing errors:\n      // 1. Remove null bytes (U+0000) which are not allowed in PostgreSQL text fields\n      // 2. Escape single backslashes that might be interpreted as escape sequences\n      // 3. Fix broken Unicode escape sequences (\\u not followed by 4 hex digits)\n      return value\n        .replace(/\\u0000/g, '') // Remove null bytes\n        .replace(/\\\\(?![\"\\\\/bfnrtu])/g, '\\\\\\\\') // Escape single backslashes not part of valid escape sequences\n        .replace(/\\\\u(?![0-9a-fA-F]{4})/g, '\\\\\\\\u'); // Fix malformed Unicode escape sequences\n    }\n\n    if (typeof value === 'object') {\n      if (seen.has(value as object)) {\n        return null;\n      } else {\n        seen.add(value as object);\n      }\n\n      if (Array.isArray(value)) {\n        return value.map((item) => this.sanitizeJsonObject(item, seen));\n      } else {\n        const result: Record<string, unknown> = {};\n        for (const [key, val] of Object.entries(value)) {\n          // Also sanitize object keys\n          const sanitizedKey =\n            typeof key === 'string'\n              ? key.replace(/\\u0000/g, '').replace(/\\\\u(?![0-9a-fA-F]{4})/g, '\\\\\\\\u')\n              : key;\n          result[sanitizedKey] = this.sanitizeJsonObject(val, seen);\n        }\n        return result;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Asynchronously retrieves logs from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving logs.\n   * @param {UUID} params.entityId - The ID of the entity associated with the logs.\n   * @param {UUID} [params.roomId] - The ID of the room associated with the logs.\n   * @param {string} [params.type] - The type of the logs to retrieve.\n   * @param {number} [params.count] - The maximum number of logs to retrieve.\n   * @param {number} [params.offset] - The offset to retrieve logs from.\n   * @returns {Promise<Log[]>} A Promise that resolves to an array of logs.\n   */\n  async getLogs(params: {\n    entityId: UUID;\n    roomId?: UUID;\n    type?: string;\n    count?: number;\n    offset?: number;\n  }): Promise<Log[]> {\n    const { entityId, roomId, type, count, offset } = params;\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select()\n        .from(logTable)\n        .where(\n          and(\n            eq(logTable.entityId, entityId),\n            roomId ? eq(logTable.roomId, roomId) : undefined,\n            type ? eq(logTable.type, type) : undefined\n          )\n        )\n        .orderBy(desc(logTable.createdAt))\n        .limit(count ?? 10)\n        .offset(offset ?? 0);\n\n      const logs = result.map((log) => ({\n        ...log,\n        id: log.id as UUID,\n        entityId: log.entityId as UUID,\n        roomId: log.roomId as UUID,\n        body: log.body as { [key: string]: unknown },\n        createdAt: new Date(log.createdAt),\n      }));\n\n      if (logs.length === 0) return [];\n\n      return logs;\n    });\n  }\n\n  async getAgentRunSummaries(\n    params: {\n      limit?: number;\n      roomId?: UUID;\n      status?: RunStatus | 'all';\n      from?: number;\n      to?: number;\n    } = {}\n  ): Promise<AgentRunSummaryResult> {\n    const limit = Math.min(Math.max(params.limit ?? 20, 1), 100);\n    const fromDate = typeof params.from === 'number' ? new Date(params.from) : undefined;\n    const toDate = typeof params.to === 'number' ? new Date(params.to) : undefined;\n\n    return this.withDatabase(async () => {\n      const runMap = new Map<string, AgentRunSummary>();\n\n      const conditions: SQL<unknown>[] = [\n        eq(logTable.type, 'run_event'),\n        sql`${logTable.body} ? 'runId'`,\n        eq(roomTable.agentId, this.agentId),\n      ];\n\n      if (params.roomId) {\n        conditions.push(eq(logTable.roomId, params.roomId));\n      }\n      if (fromDate) {\n        conditions.push(gte(logTable.createdAt, fromDate));\n      }\n      if (toDate) {\n        conditions.push(lte(logTable.createdAt, toDate));\n      }\n\n      const whereClause = and(...conditions);\n\n      const eventLimit = Math.max(limit * 20, 200);\n\n      const runEventRows = await this.db\n        .select({\n          runId: sql<string>`(${logTable.body} ->> 'runId')`,\n          status: sql<string | null>`(${logTable.body} ->> 'status')`,\n          messageId: sql<string | null>`(${logTable.body} ->> 'messageId')`,\n          rawBody: logTable.body,\n          createdAt: logTable.createdAt,\n          roomId: logTable.roomId,\n          entityId: logTable.entityId,\n        })\n        .from(logTable)\n        .innerJoin(roomTable, eq(roomTable.id, logTable.roomId))\n        .where(whereClause)\n        .orderBy(desc(logTable.createdAt))\n        .limit(eventLimit);\n\n      for (const row of runEventRows) {\n        const runId = row.runId;\n        if (!runId) continue;\n\n        const summary: AgentRunSummary = runMap.get(runId) ?? {\n          runId,\n          status: 'started',\n          startedAt: null,\n          endedAt: null,\n          durationMs: null,\n          messageId: undefined,\n          roomId: undefined,\n          entityId: undefined,\n          metadata: {},\n        };\n\n        if (!summary.messageId && row.messageId) {\n          summary.messageId = row.messageId as UUID;\n        }\n        if (!summary.roomId && row.roomId) {\n          summary.roomId = row.roomId as UUID;\n        }\n        if (!summary.entityId && row.entityId) {\n          summary.entityId = row.entityId as UUID;\n        }\n\n        const body = row.rawBody as Record<string, unknown> | undefined;\n        if (body && typeof body === 'object') {\n          if (!summary.roomId && typeof body.roomId === 'string') {\n            summary.roomId = body.roomId as UUID;\n          }\n          if (!summary.entityId && typeof body.entityId === 'string') {\n            summary.entityId = body.entityId as UUID;\n          }\n          if (!summary.messageId && typeof body.messageId === 'string') {\n            summary.messageId = body.messageId as UUID;\n          }\n          if (!summary.metadata || Object.keys(summary.metadata).length === 0) {\n            const metadata = (body.metadata as Record<string, unknown> | undefined) ?? undefined;\n            summary.metadata = metadata ? { ...metadata } : {};\n          }\n        }\n\n        const createdAt = row.createdAt instanceof Date ? row.createdAt : new Date(row.createdAt);\n        const timestamp = createdAt.getTime();\n        const eventStatus =\n          (row.status as RunStatus | undefined) ?? (body?.status as RunStatus | undefined);\n\n        if (eventStatus === 'started') {\n          summary.startedAt =\n            summary.startedAt === null ? timestamp : Math.min(summary.startedAt, timestamp);\n        } else if (\n          eventStatus === 'completed' ||\n          eventStatus === 'timeout' ||\n          eventStatus === 'error'\n        ) {\n          summary.status = eventStatus;\n          summary.endedAt = timestamp;\n          if (summary.startedAt !== null) {\n            summary.durationMs = Math.max(timestamp - summary.startedAt, 0);\n          }\n        }\n\n        runMap.set(runId, summary);\n      }\n\n      let runs = Array.from(runMap.values());\n      if (params.status && params.status !== 'all') {\n        runs = runs.filter((run) => run.status === params.status);\n      }\n\n      runs.sort((a, b) => (b.startedAt ?? 0) - (a.startedAt ?? 0));\n\n      const total = runs.length;\n      const limitedRuns = runs.slice(0, limit);\n      const hasMore = total > limit;\n\n      const runCounts = new Map<string, AgentRunCounts>();\n      for (const run of limitedRuns) {\n        runCounts.set(run.runId, { actions: 0, modelCalls: 0, errors: 0, evaluators: 0 });\n      }\n\n      const runIds = limitedRuns.map((run) => run.runId).filter(Boolean);\n\n      if (runIds.length > 0) {\n        const runIdArray = sql`array[${sql.join(\n          runIds.map((id) => sql`${id}`),\n          sql`, `\n        )}]::text[]`;\n\n        const actionSummary = await this.db.execute(sql`\n          SELECT\n            body->>'runId' as \"runId\",\n            COUNT(*)::int as \"actions\",\n            SUM(CASE WHEN COALESCE(body->'result'->>'success', 'true') = 'false' THEN 1 ELSE 0 END)::int as \"errors\",\n            SUM(COALESCE((body->>'promptCount')::int, 0))::int as \"modelCalls\"\n          FROM ${logTable}\n          WHERE type = 'action'\n            AND body->>'runId' = ANY(${runIdArray})\n          GROUP BY body->>'runId'\n        `);\n\n        const actionRows = (actionSummary.rows ?? []) as Array<{\n          runId: string;\n          actions: number | string;\n          errors: number | string;\n          modelCalls: number | string;\n        }>;\n\n        for (const row of actionRows) {\n          const counts = runCounts.get(row.runId);\n          if (!counts) continue;\n          counts.actions += Number(row.actions ?? 0);\n          counts.errors += Number(row.errors ?? 0);\n          counts.modelCalls += Number(row.modelCalls ?? 0);\n        }\n\n        const evaluatorSummary = await this.db.execute(sql`\n          SELECT\n            body->>'runId' as \"runId\",\n            COUNT(*)::int as \"evaluators\"\n          FROM ${logTable}\n          WHERE type = 'evaluator'\n            AND body->>'runId' = ANY(${runIdArray})\n          GROUP BY body->>'runId'\n        `);\n\n        const evaluatorRows = (evaluatorSummary.rows ?? []) as Array<{\n          runId: string;\n          evaluators: number | string;\n        }>;\n\n        for (const row of evaluatorRows) {\n          const counts = runCounts.get(row.runId);\n          if (!counts) continue;\n          counts.evaluators += Number(row.evaluators ?? 0);\n        }\n\n        const genericSummary = await this.db.execute(sql`\n          SELECT\n            body->>'runId' as \"runId\",\n            COUNT(*) FILTER (WHERE type LIKE 'useModel:%')::int as \"modelLogs\",\n            COUNT(*) FILTER (WHERE type = 'embedding_event' AND body->>'status' = 'failed')::int as \"embeddingErrors\"\n          FROM ${logTable}\n          WHERE (type LIKE 'useModel:%' OR type = 'embedding_event')\n            AND body->>'runId' = ANY(${runIdArray})\n          GROUP BY body->>'runId'\n        `);\n\n        const genericRows = (genericSummary.rows ?? []) as Array<{\n          runId: string;\n          modelLogs: number | string;\n          embeddingErrors: number | string;\n        }>;\n\n        for (const row of genericRows) {\n          const counts = runCounts.get(row.runId);\n          if (!counts) continue;\n          counts.modelCalls += Number(row.modelLogs ?? 0);\n          counts.errors += Number(row.embeddingErrors ?? 0);\n        }\n      }\n\n      for (const run of limitedRuns) {\n        run.counts = runCounts.get(run.runId) ?? {\n          actions: 0,\n          modelCalls: 0,\n          errors: 0,\n          evaluators: 0,\n        };\n      }\n\n      return {\n        runs: limitedRuns,\n        total,\n        hasMore,\n      } satisfies AgentRunSummaryResult;\n    });\n  }\n\n  /**\n   * Asynchronously deletes a log from the database based on the provided parameters.\n   * @param {UUID} logId - The ID of the log to delete.\n   * @returns {Promise<void>} A Promise that resolves when the log is deleted.\n   */\n  async deleteLog(logId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(logTable).where(eq(logTable.id, logId));\n    });\n  }\n\n  /**\n   * Asynchronously searches for memories in the database based on the provided parameters.\n   * @param {Object} params - The parameters for searching for memories.\n   * @param {string} params.tableName - The name of the table to search for memories in.\n   * @param {number[]} params.embedding - The embedding to search for.\n   * @param {number} [params.match_threshold] - The threshold for the cosine distance.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.query] - Optional query string for potential reranking.\n   * @param {UUID} [params.roomId] - Optional room ID to filter by.\n   * @param {UUID} [params.worldId] - Optional world ID to filter by.\n   * @param {UUID} [params.entityId] - Optional entity ID to filter by.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async searchMemories(params: {\n    tableName: string;\n    embedding: number[];\n    match_threshold?: number;\n    count?: number;\n    unique?: boolean;\n    query?: string;\n    roomId?: UUID;\n    worldId?: UUID;\n    entityId?: UUID;\n  }): Promise<Memory[]> {\n    return await this.searchMemoriesByEmbedding(params.embedding, {\n      match_threshold: params.match_threshold,\n      count: params.count,\n      // Pass direct scope fields down\n      roomId: params.roomId,\n      worldId: params.worldId,\n      entityId: params.entityId,\n      unique: params.unique,\n      tableName: params.tableName,\n    });\n  }\n\n  /**\n   * Asynchronously searches for memories in the database based on the provided parameters.\n   * @param {number[]} embedding - The embedding to search for.\n   * @param {Object} params - The parameters for searching for memories.\n   * @param {number} [params.match_threshold] - The threshold for the cosine distance.\n   * @param {number} [params.count] - The maximum number of memories to retrieve.\n   * @param {UUID} [params.roomId] - Optional room ID to filter by.\n   * @param {UUID} [params.worldId] - Optional world ID to filter by.\n   * @param {UUID} [params.entityId] - Optional entity ID to filter by.\n   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.\n   * @param {string} [params.tableName] - The name of the table to search for memories in.\n   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.\n   */\n  async searchMemoriesByEmbedding(\n    embedding: number[],\n    params: {\n      match_threshold?: number;\n      count?: number;\n      roomId?: UUID;\n      worldId?: UUID;\n      entityId?: UUID;\n      unique?: boolean;\n      tableName: string;\n    }\n  ): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      const cleanVector = embedding.map((n) => (Number.isFinite(n) ? Number(n.toFixed(6)) : 0));\n\n      const similarity = sql<number>`1 - (${cosineDistance(\n        embeddingTable[this.embeddingDimension],\n        cleanVector\n      )})`;\n\n      const conditions = [eq(memoryTable.type, params.tableName)];\n\n      if (params.unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      conditions.push(eq(memoryTable.agentId, this.agentId));\n\n      // Add filters based on direct params\n      if (params.roomId) {\n        conditions.push(eq(memoryTable.roomId, params.roomId));\n      }\n      if (params.worldId) {\n        conditions.push(eq(memoryTable.worldId, params.worldId));\n      }\n      if (params.entityId) {\n        conditions.push(eq(memoryTable.entityId, params.entityId));\n      }\n\n      if (params.match_threshold) {\n        conditions.push(gte(similarity, params.match_threshold));\n      }\n\n      const results = await this.db\n        .select({\n          memory: memoryTable,\n          similarity,\n          embedding: embeddingTable[this.embeddingDimension],\n        })\n        .from(embeddingTable)\n        .innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId))\n        .where(and(...conditions))\n        .orderBy(desc(similarity))\n        .limit(params.count ?? 10);\n\n      return results.map((row) => ({\n        id: row.memory.id as UUID,\n        type: row.memory.type,\n        createdAt: row.memory.createdAt.getTime(),\n        content:\n          typeof row.memory.content === 'string'\n            ? JSON.parse(row.memory.content)\n            : row.memory.content,\n        entityId: row.memory.entityId as UUID,\n        agentId: row.memory.agentId as UUID,\n        roomId: row.memory.roomId as UUID,\n        worldId: row.memory.worldId as UUID | undefined, // Include worldId\n        unique: row.memory.unique,\n        metadata: row.memory.metadata as MemoryMetadata,\n        embedding: row.embedding ?? undefined,\n        similarity: row.similarity,\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new memory in the database.\n   * @param {Memory & { metadata?: MemoryMetadata }} memory - The memory object to create.\n   * @param {string} tableName - The name of the table to create the memory in.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created memory.\n   */\n  async createMemory(\n    memory: Memory & { metadata?: MemoryMetadata },\n    tableName: string\n  ): Promise<UUID> {\n    logger.debug(\n      `DrizzleAdapter createMemory: memoryId: ${memory.id}, embeddingLength: ${memory.embedding?.length}, contentLength: ${memory.content?.text?.length}`\n    );\n\n    const memoryId = memory.id ?? (v4() as UUID);\n\n    const existing = await this.getMemoryById(memoryId);\n    if (existing) {\n      logger.debug(`Memory already exists, skipping creation: ${memoryId}`);\n      return memoryId;\n    }\n\n    // only do costly check if we need to\n    if (memory.unique === undefined) {\n      memory.unique = true; // set default\n      if (memory.embedding && Array.isArray(memory.embedding)) {\n        const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {\n          tableName,\n          // Use the scope fields from the memory object for similarity check\n          roomId: memory.roomId,\n          worldId: memory.worldId,\n          entityId: memory.entityId,\n          match_threshold: 0.95,\n          count: 1,\n        });\n        memory.unique = similarMemories.length === 0;\n      }\n    }\n\n    // Ensure we always pass a JSON string to the SQL placeholder  if we pass an\n    // object directly PG sees `[object Object]` and fails the `::jsonb` cast.\n    const contentToInsert =\n      typeof memory.content === 'string' ? memory.content : JSON.stringify(memory.content ?? {});\n\n    const metadataToInsert =\n      typeof memory.metadata === 'string' ? memory.metadata : JSON.stringify(memory.metadata ?? {});\n\n    await this.db.transaction(async (tx) => {\n      await tx.insert(memoryTable).values([\n        {\n          id: memoryId,\n          type: tableName,\n          content: sql`${contentToInsert}::jsonb`,\n          metadata: sql`${metadataToInsert}::jsonb`,\n          entityId: memory.entityId,\n          roomId: memory.roomId,\n          worldId: memory.worldId, // Include worldId\n          agentId: memory.agentId || this.agentId,\n          unique: memory.unique,\n          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date(),\n        },\n      ]);\n\n      if (memory.embedding && Array.isArray(memory.embedding)) {\n        const embeddingValues: Record<string, unknown> = {\n          id: v4(),\n          memoryId: memoryId,\n          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date(),\n        };\n\n        const cleanVector = memory.embedding.map((n) =>\n          Number.isFinite(n) ? Number(n.toFixed(6)) : 0\n        );\n\n        embeddingValues[this.embeddingDimension] = cleanVector;\n\n        await tx.insert(embeddingTable).values([embeddingValues]);\n      }\n    });\n\n    return memoryId;\n  }\n\n  /**\n   * Updates an existing memory in the database.\n   * @param memory The memory object with updated content and optional embedding\n   * @returns Promise resolving to boolean indicating success\n   */\n  async updateMemory(\n    memory: Partial<Memory> & { id: UUID; metadata?: MemoryMetadata }\n  ): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        logger.debug(\n          `Updating memory: memoryId: ${memory.id}, hasEmbedding: ${!!memory.embedding}`\n        );\n\n        await this.db.transaction(async (tx) => {\n          // Update memory content if provided\n          if (memory.content) {\n            const contentToUpdate =\n              typeof memory.content === 'string'\n                ? memory.content\n                : JSON.stringify(memory.content ?? {});\n\n            const metadataToUpdate =\n              typeof memory.metadata === 'string'\n                ? memory.metadata\n                : JSON.stringify(memory.metadata ?? {});\n\n            await tx\n              .update(memoryTable)\n              .set({\n                content: sql`${contentToUpdate}::jsonb`,\n                ...(memory.metadata && { metadata: sql`${metadataToUpdate}::jsonb` }),\n              })\n              .where(eq(memoryTable.id, memory.id));\n          } else if (memory.metadata) {\n            // Update only metadata if content is not provided\n            const metadataToUpdate =\n              typeof memory.metadata === 'string'\n                ? memory.metadata\n                : JSON.stringify(memory.metadata ?? {});\n\n            await tx\n              .update(memoryTable)\n              .set({\n                metadata: sql`${metadataToUpdate}::jsonb`,\n              })\n              .where(eq(memoryTable.id, memory.id));\n          }\n\n          // Update embedding if provided\n          if (memory.embedding && Array.isArray(memory.embedding)) {\n            const cleanVector = memory.embedding.map((n) =>\n              Number.isFinite(n) ? Number(n.toFixed(6)) : 0\n            );\n\n            // Check if embedding exists\n            const existingEmbedding = await tx\n              .select({ id: embeddingTable.id })\n              .from(embeddingTable)\n              .where(eq(embeddingTable.memoryId, memory.id))\n              .limit(1);\n\n            if (existingEmbedding.length > 0) {\n              // Update existing embedding\n              const updateValues: Record<string, unknown> = {};\n              updateValues[this.embeddingDimension] = cleanVector;\n\n              await tx\n                .update(embeddingTable)\n                .set(updateValues)\n                .where(eq(embeddingTable.memoryId, memory.id));\n            } else {\n              // Create new embedding\n              const embeddingValues: Record<string, unknown> = {\n                id: v4(),\n                memoryId: memory.id,\n              };\n              embeddingValues[this.embeddingDimension] = cleanVector;\n\n              await tx.insert(embeddingTable).values([embeddingValues]);\n            }\n          }\n        });\n\n        logger.debug(`Memory updated successfully: ${memory.id}`);\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error updating memory: ${error instanceof Error ? error.message : String(error)}, memoryId: ${memory.id}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously deletes a memory from the database based on the provided parameters.\n   * @param {UUID} memoryId - The ID of the memory to delete.\n   * @returns {Promise<void>} A Promise that resolves when the memory is deleted.\n   */\n  async deleteMemory(memoryId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // See if there are any fragments that we need to delete\n        await this.deleteMemoryFragments(tx, memoryId);\n\n        // Then delete the embedding for the main memory\n        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));\n\n        // Finally delete the memory itself\n        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));\n      });\n\n      logger.debug(`Memory and related fragments removed successfully: ${memoryId}`);\n    });\n  }\n\n  /**\n   * Asynchronously deletes multiple memories from the database in a single batch operation.\n   * @param {UUID[]} memoryIds - An array of UUIDs of the memories to delete.\n   * @returns {Promise<void>} A Promise that resolves when all memories are deleted.\n   */\n  async deleteManyMemories(memoryIds: UUID[]): Promise<void> {\n    if (memoryIds.length === 0) {\n      return;\n    }\n\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // Process in smaller batches to avoid query size limits\n        const BATCH_SIZE = 100;\n        for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {\n          const batch = memoryIds.slice(i, i + BATCH_SIZE);\n\n          // Delete any fragments for document memories in this batch\n          await Promise.all(\n            batch.map(async (memoryId) => {\n              await this.deleteMemoryFragments(tx, memoryId);\n            })\n          );\n\n          // Delete embeddings for the batch\n          await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));\n\n          // Delete the memories themselves\n          await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));\n        }\n      });\n\n      logger.debug(`Batch memory deletion completed successfully: ${memoryIds.length}`);\n    });\n  }\n\n  /**\n   * Deletes all memory fragments that reference a specific document memory\n   * @param tx The database transaction\n   * @param documentId The UUID of the document memory whose fragments should be deleted\n   * @private\n   */\n  private async deleteMemoryFragments(tx: any, documentId: UUID): Promise<void> {\n    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);\n\n    if (fragmentsToDelete.length > 0) {\n      const fragmentIds = fragmentsToDelete.map((f) => f.id) as UUID[];\n\n      // Delete embeddings for fragments\n      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));\n\n      // Delete the fragments\n      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));\n\n      logger.debug(\n        `Deleted related fragments: documentId: ${documentId}, fragmentCount: ${fragmentsToDelete.length}`\n      );\n    }\n  }\n\n  /**\n   * Retrieves all memory fragments that reference a specific document memory\n   * @param tx The database transaction\n   * @param documentId The UUID of the document memory whose fragments should be retrieved\n   * @returns An array of memory fragments\n   * @private\n   */\n  private async getMemoryFragments(tx: any, documentId: UUID): Promise<{ id: UUID }[]> {\n    const fragments = await tx\n      .select({ id: memoryTable.id })\n      .from(memoryTable)\n      .where(\n        and(\n          eq(memoryTable.agentId, this.agentId),\n          sql`${memoryTable.metadata}->>'documentId' = ${documentId}`\n        )\n      );\n\n    return fragments.map((f) => ({ id: f.id as UUID }));\n  }\n\n  /**\n   * Asynchronously deletes all memories from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to delete memories from.\n   * @param {string} tableName - The name of the table to delete memories from.\n   * @returns {Promise<void>} A Promise that resolves when the memories are deleted.\n   */\n  async deleteAllMemories(roomId: UUID, tableName: string): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // 1) fetch all memory IDs for this room + table\n        const rows = await tx\n          .select({ id: memoryTable.id })\n          .from(memoryTable)\n          .where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));\n\n        const ids = rows.map((r) => r.id);\n        logger.debug(\n          `[deleteAllMemories] memory IDs to delete: roomId: ${roomId}, tableName: ${tableName}, ids: ${JSON.stringify(ids)}`\n        );\n\n        if (ids.length === 0) {\n          return;\n        }\n\n        // 2) delete any fragments for \"document\" memories & their embeddings\n        await Promise.all(\n          ids.map(async (memoryId) => {\n            await this.deleteMemoryFragments(tx, memoryId);\n            await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));\n          })\n        );\n\n        // 3) delete the memories themselves\n        await tx\n          .delete(memoryTable)\n          .where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));\n      });\n\n      logger.debug(`All memories removed successfully: roomId: ${roomId}, tableName: ${tableName}`);\n    });\n  }\n\n  /**\n   * Asynchronously counts the number of memories in the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to count memories in.\n   * @param {boolean} [unique] - Whether to count unique memories only.\n   * @param {string} [tableName] - The name of the table to count memories in.\n   * @returns {Promise<number>} A Promise that resolves to the number of memories.\n   */\n  async countMemories(roomId: UUID, unique = true, tableName = ''): Promise<number> {\n    if (!tableName) throw new Error('tableName is required');\n\n    return this.withDatabase(async () => {\n      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];\n\n      if (unique) {\n        conditions.push(eq(memoryTable.unique, true));\n      }\n\n      const result = await this.db\n        .select({ count: sql<number>`count(*)` })\n        .from(memoryTable)\n        .where(and(...conditions));\n\n      return Number(result[0]?.count ?? 0);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves rooms from the database based on the provided parameters.\n   * @param {UUID[]} roomIds - The IDs of the rooms to retrieve.\n   * @returns {Promise<Room[] | null>} A Promise that resolves to the rooms if found, null otherwise.\n   */\n  async getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          id: roomTable.id,\n          name: roomTable.name, // Added name\n          channelId: roomTable.channelId,\n          agentId: roomTable.agentId,\n          serverId: roomTable.serverId,\n          worldId: roomTable.worldId,\n          type: roomTable.type,\n          source: roomTable.source,\n          metadata: roomTable.metadata, // Added metadata\n        })\n        .from(roomTable)\n        .where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));\n\n      // Map the result to properly typed Room objects\n      const rooms = result.map((room) => ({\n        ...room,\n        id: room.id as UUID,\n        name: room.name ?? undefined,\n        agentId: room.agentId as UUID,\n        serverId: room.serverId as UUID,\n        worldId: room.worldId as UUID,\n        channelId: room.channelId as UUID,\n        type: room.type as ChannelType,\n        metadata: room.metadata as RoomMetadata,\n      }));\n\n      return rooms;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms from the database based on the provided parameters.\n   * @param {UUID} worldId - The ID of the world to retrieve rooms from.\n   * @returns {Promise<Room[]>} A Promise that resolves to an array of rooms.\n   */\n  async getRoomsByWorld(worldId: UUID): Promise<Room[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));\n      const rooms = result.map((room) => ({\n        ...room,\n        id: room.id as UUID,\n        name: room.name ?? undefined,\n        agentId: room.agentId as UUID,\n        serverId: room.serverId as UUID,\n        worldId: room.worldId as UUID,\n        channelId: room.channelId as UUID,\n        type: room.type as ChannelType,\n        metadata: room.metadata as RoomMetadata,\n      }));\n      return rooms;\n    });\n  }\n\n  /**\n   * Asynchronously updates a room in the database based on the provided parameters.\n   * @param {Room} room - The room object to update.\n   * @returns {Promise<void>} A Promise that resolves when the room is updated.\n   */\n  async updateRoom(room: Room): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .update(roomTable)\n        .set({ ...room, agentId: this.agentId })\n        .where(eq(roomTable.id, room.id));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new room in the database based on the provided parameters.\n   * @param {Room} room - The room object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created room.\n   */\n  async createRooms(rooms: Room[]): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const roomsWithIds = rooms.map((room) => ({\n        ...room,\n        agentId: this.agentId,\n        id: room.id || v4(), // ensure each room has a unique ID\n      }));\n\n      const insertedRooms = await this.db\n        .insert(roomTable)\n        .values(roomsWithIds)\n        .onConflictDoNothing()\n        .returning();\n      const insertedIds = insertedRooms.map((r) => r.id as UUID);\n      return insertedIds;\n    });\n  }\n\n  /**\n   * Asynchronously deletes a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to delete.\n   * @returns {Promise<void>} A Promise that resolves when the room is deleted.\n   */\n  async deleteRoom(roomId: UUID): Promise<void> {\n    if (!roomId) throw new Error('Room ID is required');\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        await tx.delete(roomTable).where(eq(roomTable.id, roomId));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms for a participant from the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to retrieve rooms for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.\n   */\n  async getRoomsForParticipant(entityId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ roomId: participantTable.roomId })\n        .from(participantTable)\n        .innerJoin(roomTable, eq(participantTable.roomId, roomTable.id))\n        .where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));\n\n      return result.map((row) => row.roomId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all rooms for a list of participants from the database based on the provided parameters.\n   * @param {UUID[]} entityIds - The IDs of the entities to retrieve rooms for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.\n   */\n  async getRoomsForParticipants(entityIds: UUID[]): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .selectDistinct({ roomId: participantTable.roomId })\n        .from(participantTable)\n        .innerJoin(roomTable, eq(participantTable.roomId, roomTable.id))\n        .where(\n          and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId))\n        );\n\n      return result.map((row) => row.roomId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously adds a participant to a room in the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to add to the room.\n   * @param {UUID} roomId - The ID of the room to add the entity to.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was added successfully.\n   */\n  async addParticipant(entityId: UUID, roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .insert(participantTable)\n          .values({\n            entityId,\n            roomId,\n            agentId: this.agentId,\n          })\n          .onConflictDoNothing();\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error adding participant to room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}, agentId: ${this.agentId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  async addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        const values = entityIds.map((id) => ({\n          entityId: id,\n          roomId,\n          agentId: this.agentId,\n        }));\n        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();\n        logger.debug(`${entityIds.length} Entities linked successfully`);\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error adding participants to room: ${error instanceof Error ? error.message : String(error)}, entityIdSample: ${entityIds[0]}, roomId: ${roomId}, agentId: ${this.agentId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously removes a participant from a room in the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to remove from the room.\n   * @param {UUID} roomId - The ID of the room to remove the entity from.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was removed successfully.\n   */\n  async removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db.transaction(async (tx) => {\n          return await tx\n            .delete(participantTable)\n            .where(\n              and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))\n            )\n            .returning();\n        });\n\n        const removed = result.length > 0;\n        logger.debug(\n          `Participant ${removed ? 'removed' : 'not found'}: entityId: ${entityId}, roomId: ${roomId}, removed: ${removed}`\n        );\n\n        return removed;\n      } catch (error) {\n        logger.error(\n          `Error removing participant from room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all participants for an entity from the database based on the provided parameters.\n   * @param {UUID} entityId - The ID of the entity to retrieve participants for.\n   * @returns {Promise<Participant[]>} A Promise that resolves to an array of participants.\n   */\n  async getParticipantsForEntity(entityId: UUID): Promise<Participant[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({\n          id: participantTable.id,\n          entityId: participantTable.entityId,\n          roomId: participantTable.roomId,\n        })\n        .from(participantTable)\n        .where(eq(participantTable.entityId, entityId));\n\n      const entities = await this.getEntitiesByIds([entityId]);\n\n      if (!entities || !entities.length) {\n        return [];\n      }\n\n      return result.map((row) => ({\n        id: row.id as UUID,\n        entity: entities[0],\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all participants for a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to retrieve participants for.\n   * @returns {Promise<UUID[]>} A Promise that resolves to an array of entity IDs.\n   */\n  async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ entityId: participantTable.entityId })\n        .from(participantTable)\n        .where(eq(participantTable.roomId, roomId));\n\n      return result.map((row) => row.entityId as UUID);\n    });\n  }\n\n  /**\n   * Asynchronously retrieves the user state for a participant in a room from the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to retrieve the participant's user state for.\n   * @param {UUID} entityId - The ID of the entity to retrieve the user state for.\n   * @returns {Promise<\"FOLLOWED\" | \"MUTED\" | null>} A Promise that resolves to the participant's user state.\n   */\n  async getParticipantUserState(\n    roomId: UUID,\n    entityId: UUID\n  ): Promise<'FOLLOWED' | 'MUTED' | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select({ roomState: participantTable.roomState })\n        .from(participantTable)\n        .where(\n          and(\n            eq(participantTable.roomId, roomId),\n            eq(participantTable.entityId, entityId),\n            eq(participantTable.agentId, this.agentId)\n          )\n        )\n        .limit(1);\n\n      return (result[0]?.roomState as 'FOLLOWED' | 'MUTED' | null) ?? null;\n    });\n  }\n\n  /**\n   * Asynchronously sets the user state for a participant in a room in the database based on the provided parameters.\n   * @param {UUID} roomId - The ID of the room to set the participant's user state for.\n   * @param {UUID} entityId - The ID of the entity to set the user state for.\n   * @param {string} state - The state to set the participant's user state to.\n   * @returns {Promise<void>} A Promise that resolves when the participant's user state is set.\n   */\n  async setParticipantUserState(\n    roomId: UUID,\n    entityId: UUID,\n    state: 'FOLLOWED' | 'MUTED' | null\n  ): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx\n            .update(participantTable)\n            .set({ roomState: state })\n            .where(\n              and(\n                eq(participantTable.roomId, roomId),\n                eq(participantTable.entityId, entityId),\n                eq(participantTable.agentId, this.agentId)\n              )\n            );\n        });\n      } catch (error) {\n        logger.error(\n          `Error setting participant follow state: roomId: ${roomId}, entityId: ${entityId}, state: ${state}, error: ${error instanceof Error ? error.message : String(error)}`\n        );\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously creates a new relationship in the database based on the provided parameters.\n   * @param {Object} params - The parameters for creating a new relationship.\n   * @param {UUID} params.sourceEntityId - The ID of the source entity.\n   * @param {UUID} params.targetEntityId - The ID of the target entity.\n   * @param {string[]} [params.tags] - The tags for the relationship.\n   * @param {Object} [params.metadata] - The metadata for the relationship.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the relationship was created successfully.\n   */\n  async createRelationship(params: {\n    sourceEntityId: UUID;\n    targetEntityId: UUID;\n    tags?: string[];\n    metadata?: { [key: string]: unknown };\n  }): Promise<boolean> {\n    return this.withDatabase(async () => {\n      const id = v4();\n      const saveParams = {\n        id,\n        sourceEntityId: params.sourceEntityId,\n        targetEntityId: params.targetEntityId,\n        agentId: this.agentId,\n        tags: params.tags || [],\n        metadata: params.metadata || {},\n      };\n      try {\n        await this.db.insert(relationshipTable).values(saveParams);\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error creating relationship: ${error instanceof Error ? error.message : String(error)}, saveParams: ${JSON.stringify(saveParams)}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing relationship in the database based on the provided parameters.\n   * @param {Relationship} relationship - The relationship object to update.\n   * @returns {Promise<void>} A Promise that resolves when the relationship is updated.\n   */\n  async updateRelationship(relationship: Relationship): Promise<void> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .update(relationshipTable)\n          .set({\n            tags: relationship.tags || [],\n            metadata: relationship.metadata || {},\n          })\n          .where(eq(relationshipTable.id, relationship.id));\n      } catch (error) {\n        logger.error(\n          `Error updating relationship: ${error instanceof Error ? error.message : String(error)}, relationship: ${JSON.stringify(relationship)}`\n        );\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a relationship from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving a relationship.\n   * @param {UUID} params.sourceEntityId - The ID of the source entity.\n   * @param {UUID} params.targetEntityId - The ID of the target entity.\n   * @returns {Promise<Relationship | null>} A Promise that resolves to the relationship if found, null otherwise.\n   */\n  async getRelationship(params: {\n    sourceEntityId: UUID;\n    targetEntityId: UUID;\n  }): Promise<Relationship | null> {\n    return this.withDatabase(async () => {\n      const { sourceEntityId, targetEntityId } = params;\n      const result = await this.db\n        .select()\n        .from(relationshipTable)\n        .where(\n          and(\n            eq(relationshipTable.sourceEntityId, sourceEntityId),\n            eq(relationshipTable.targetEntityId, targetEntityId)\n          )\n        );\n      if (result.length === 0) return null;\n      const relationship = result[0];\n      return {\n        ...relationship,\n        id: relationship.id as UUID,\n        sourceEntityId: relationship.sourceEntityId as UUID,\n        targetEntityId: relationship.targetEntityId as UUID,\n        agentId: relationship.agentId as UUID,\n        tags: relationship.tags ?? [],\n        metadata: (relationship.metadata as { [key: string]: unknown }) ?? {},\n        createdAt: relationship.createdAt.toISOString(),\n      };\n    });\n  }\n\n  /**\n   * Asynchronously retrieves relationships from the database based on the provided parameters.\n   * @param {Object} params - The parameters for retrieving relationships.\n   * @param {UUID} params.entityId - The ID of the entity to retrieve relationships for.\n   * @param {string[]} [params.tags] - The tags to filter relationships by.\n   * @returns {Promise<Relationship[]>} A Promise that resolves to an array of relationships.\n   */\n  async getRelationships(params: { entityId: UUID; tags?: string[] }): Promise<Relationship[]> {\n    return this.withDatabase(async () => {\n      const { entityId, tags } = params;\n\n      let query: SQL;\n\n      if (tags && tags.length > 0) {\n        query = sql`\n          SELECT * FROM ${relationshipTable}\n          WHERE (${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId})\n          AND ${relationshipTable.tags} && CAST(ARRAY[${sql.join(tags, sql`, `)}] AS text[])\n        `;\n      } else {\n        query = sql`\n          SELECT * FROM ${relationshipTable}\n          WHERE ${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId}\n        `;\n      }\n\n      const result = await this.db.execute(query);\n\n      return result.rows.map((relationship: any) => ({\n        ...relationship,\n        id: relationship.id as UUID,\n        sourceEntityId: relationship.sourceEntityId as UUID,\n        targetEntityId: relationship.targetEntityId as UUID,\n        agentId: relationship.agentId as UUID,\n        tags: relationship.tags ?? [],\n        metadata: (relationship.metadata as { [key: string]: unknown }) ?? {},\n        createdAt: relationship.createdAt\n          ? relationship.createdAt instanceof Date\n            ? relationship.createdAt.toISOString()\n            : new Date(relationship.createdAt).toISOString()\n          : new Date().toISOString(),\n      }));\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a cache value from the database based on the provided key.\n   * @param {string} key - The key to retrieve the cache value for.\n   * @returns {Promise<T | undefined>} A Promise that resolves to the cache value if found, undefined otherwise.\n   */\n  async getCache<T>(key: string): Promise<T | undefined> {\n    return this.withDatabase(async () => {\n      try {\n        const result = await this.db\n          .select({ value: cacheTable.value })\n          .from(cacheTable)\n          .where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)))\n          .limit(1);\n\n        if (result && result.length > 0 && result[0]) {\n          return result[0].value as T | undefined;\n        }\n\n        return undefined;\n      } catch (error) {\n        logger.error(\n          `Error fetching cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`\n        );\n        return undefined;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously sets a cache value in the database based on the provided key and value.\n   * @param {string} key - The key to set the cache value for.\n   * @param {T} value - The value to set in the cache.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was set successfully.\n   */\n  async setCache<T>(key: string, value: T): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db\n          .insert(cacheTable)\n          .values({\n            key: key,\n            agentId: this.agentId,\n            value: value,\n          })\n          .onConflictDoUpdate({\n            target: [cacheTable.key, cacheTable.agentId],\n            set: {\n              value: value,\n            },\n          });\n\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error setting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously deletes a cache value from the database based on the provided key.\n   * @param {string} key - The key to delete the cache value for.\n   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was deleted successfully.\n   */\n  async deleteCache(key: string): Promise<boolean> {\n    return this.withDatabase(async () => {\n      try {\n        await this.db.transaction(async (tx) => {\n          await tx\n            .delete(cacheTable)\n            .where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));\n        });\n        return true;\n      } catch (error) {\n        logger.error(\n          `Error deleting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`\n        );\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Asynchronously creates a new world in the database based on the provided parameters.\n   * @param {World} world - The world object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created world.\n   */\n  async createWorld(world: World): Promise<UUID> {\n    return this.withDatabase(async () => {\n      const newWorldId = world.id || v4();\n      await this.db.insert(worldTable).values({\n        ...world,\n        id: newWorldId,\n        name: world.name || '',\n      });\n      return newWorldId;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a world from the database based on the provided parameters.\n   * @param {UUID} id - The ID of the world to retrieve.\n   * @returns {Promise<World | null>} A Promise that resolves to the world if found, null otherwise.\n   */\n  async getWorld(id: UUID): Promise<World | null> {\n    return this.withDatabase(async () => {\n      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));\n      return result.length > 0 ? (result[0] as World) : null;\n    });\n  }\n\n  /**\n   * Asynchronously retrieves all worlds from the database based on the provided parameters.\n   * @returns {Promise<World[]>} A Promise that resolves to an array of worlds.\n   */\n  async getAllWorlds(): Promise<World[]> {\n    return this.withDatabase(async () => {\n      const result = await this.db\n        .select()\n        .from(worldTable)\n        .where(eq(worldTable.agentId, this.agentId));\n      return result as World[];\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing world in the database based on the provided parameters.\n   * @param {World} world - The world object to update.\n   * @returns {Promise<void>} A Promise that resolves when the world is updated.\n   */\n  async updateWorld(world: World): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));\n    });\n  }\n\n  /**\n   * Asynchronously removes a world from the database based on the provided parameters.\n   * @param {UUID} id - The ID of the world to remove.\n   * @returns {Promise<void>} A Promise that resolves when the world is removed.\n   */\n  async removeWorld(id: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(worldTable).where(eq(worldTable.id, id));\n    });\n  }\n\n  /**\n   * Asynchronously creates a new task in the database based on the provided parameters.\n   * @param {Task} task - The task object to create.\n   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created task.\n   */\n  async createTask(task: Task): Promise<UUID> {\n    if (!task.worldId) {\n      throw new Error('worldId is required');\n    }\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const now = new Date();\n        const metadata = task.metadata || {};\n\n        const values = {\n          id: task.id as UUID,\n          name: task.name,\n          description: task.description,\n          roomId: task.roomId as UUID,\n          worldId: task.worldId as UUID,\n          tags: task.tags,\n          metadata: metadata,\n          createdAt: now,\n          updatedAt: now,\n          agentId: this.agentId as UUID,\n        };\n\n        const result = await this.db.insert(taskTable).values(values).returning();\n\n        return result[0].id as UUID;\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves tasks based on specified parameters.\n   * @param params Object containing optional roomId, tags, and entityId to filter tasks\n   * @returns Promise resolving to an array of Task objects\n   */\n  async getTasks(params: {\n    roomId?: UUID;\n    tags?: string[];\n    entityId?: UUID; // Added entityId parameter\n  }): Promise<Task[]> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(\n            and(\n              eq(taskTable.agentId, this.agentId),\n              ...(params.roomId ? [eq(taskTable.roomId, params.roomId)] : []),\n              ...(params.tags && params.tags.length > 0\n                ? [\n                    sql`${taskTable.tags} @> ARRAY[${sql.raw(\n                      params.tags.map((t) => `'${t.replace(/'/g, \"''\")}'`).join(', ')\n                    )}]::text[]`,\n                  ]\n                : [])\n            )\n          );\n\n        return result.map((row) => ({\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: row.metadata as TaskMetadata,\n        }));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a specific task by its name.\n   * @param name The name of the task to retrieve\n   * @returns Promise resolving to the Task object if found, null otherwise\n   */\n  async getTasksByName(name: string): Promise<Task[]> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));\n\n        return result.map((row) => ({\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: (row.metadata || {}) as TaskMetadata,\n        }));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously retrieves a specific task by its ID.\n   * @param id The UUID of the task to retrieve\n   * @returns Promise resolving to the Task object if found, null otherwise\n   */\n  async getTask(id: UUID): Promise<Task | null> {\n    return this.withRetry(async () => {\n      return this.withDatabase(async () => {\n        const result = await this.db\n          .select()\n          .from(taskTable)\n          .where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)))\n          .limit(1);\n\n        if (result.length === 0) {\n          return null;\n        }\n\n        const row = result[0];\n        return {\n          id: row.id as UUID,\n          name: row.name,\n          description: row.description ?? '',\n          roomId: row.roomId as UUID,\n          worldId: row.worldId as UUID,\n          tags: row.tags || [],\n          metadata: (row.metadata || {}) as TaskMetadata,\n        };\n      });\n    });\n  }\n\n  /**\n   * Asynchronously updates an existing task in the database.\n   * @param id The UUID of the task to update\n   * @param task Partial Task object containing the fields to update\n   * @returns Promise resolving when the update is complete\n   */\n  async updateTask(id: UUID, task: Partial<Task>): Promise<void> {\n    await this.withRetry(async () => {\n      await this.withDatabase(async () => {\n        const updateValues: Partial<Task> = {};\n\n        // Add fields to update if they exist in the partial task object\n        if (task.name !== undefined) updateValues.name = task.name;\n        if (task.description !== undefined) updateValues.description = task.description;\n        if (task.roomId !== undefined) updateValues.roomId = task.roomId;\n        if (task.worldId !== undefined) updateValues.worldId = task.worldId;\n        if (task.tags !== undefined) updateValues.tags = task.tags;\n\n        // Always update the updatedAt timestamp as a Date\n        (updateValues as any).updatedAt = new Date();\n\n        // Handle metadata updates - just set it directly without merging\n        if (task.metadata !== undefined) {\n          updateValues.metadata = task.metadata;\n        }\n\n        await this.db\n          .update(taskTable)\n          // createdAt is hella borked, number / Date\n          .set(updateValues as any)\n          .where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));\n      });\n    });\n  }\n\n  /**\n   * Asynchronously deletes a task from the database.\n   * @param id The UUID of the task to delete\n   * @returns Promise resolving when the deletion is complete\n   */\n  async deleteTask(id: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(taskTable).where(eq(taskTable.id, id));\n    });\n  }\n\n  async getMemoriesByWorldId(params: {\n    worldId: UUID;\n    count?: number;\n    tableName?: string;\n  }): Promise<Memory[]> {\n    return this.withDatabase(async () => {\n      // First, get all rooms for the given worldId\n      const rooms = await this.db\n        .select({ id: roomTable.id })\n        .from(roomTable)\n        .where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));\n\n      if (rooms.length === 0) {\n        return [];\n      }\n\n      const roomIds = rooms.map((room) => room.id as UUID);\n\n      const memories = await this.getMemoriesByRoomIds({\n        roomIds,\n        tableName: params.tableName || 'messages',\n        limit: params.count,\n      });\n\n      return memories;\n    });\n  }\n\n  async deleteRoomsByWorldId(worldId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      const rooms = await this.db\n        .select({ id: roomTable.id })\n        .from(roomTable)\n        .where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));\n\n      if (rooms.length === 0) {\n        logger.debug(\n          `No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`\n        );\n        return;\n      }\n\n      const roomIds = rooms.map((room) => room.id as UUID);\n\n      if (roomIds.length > 0) {\n        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));\n        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);\n\n        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));\n        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);\n\n        const memoriesInRooms = await this.db\n          .select({ id: memoryTable.id })\n          .from(memoryTable)\n          .where(inArray(memoryTable.roomId, roomIds));\n        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id as UUID);\n\n        if (memoryIdsInRooms.length > 0) {\n          await this.db\n            .delete(embeddingTable)\n            .where(inArray(embeddingTable.memoryId, memoryIdsInRooms));\n          logger.debug(\n            `Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`\n          );\n          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));\n          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);\n        }\n\n        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));\n        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);\n      }\n    });\n  }\n\n  // Message Server Database Operations\n\n  /**\n   * Creates a new message server in the central database\n   */\n  async createMessageServer(data: {\n    id?: UUID; // Allow passing a specific ID\n    name: string;\n    sourceType: string;\n    sourceId?: string;\n    metadata?: any;\n  }): Promise<{\n    id: UUID;\n    name: string;\n    sourceType: string;\n    sourceId?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const newId = data.id || (v4() as UUID);\n      const now = new Date();\n      const serverToInsert = {\n        id: newId,\n        name: data.name,\n        sourceType: data.sourceType,\n        sourceId: data.sourceId,\n        metadata: data.metadata,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await this.db.insert(messageServerTable).values(serverToInsert).onConflictDoNothing(); // In case the ID already exists\n\n      // If server already existed, fetch it\n      if (data.id) {\n        const existing = await this.db\n          .select()\n          .from(messageServerTable)\n          .where(eq(messageServerTable.id, data.id))\n          .limit(1);\n        if (existing.length > 0) {\n          return {\n            id: existing[0].id as UUID,\n            name: existing[0].name,\n            sourceType: existing[0].sourceType,\n            sourceId: existing[0].sourceId || undefined,\n            metadata: existing[0].metadata || undefined,\n            createdAt: existing[0].createdAt,\n            updatedAt: existing[0].updatedAt,\n          };\n        }\n      }\n\n      return serverToInsert;\n    });\n  }\n\n  /**\n   * Gets all message servers\n   */\n  async getMessageServers(): Promise<\n    Array<{\n      id: UUID;\n      name: string;\n      sourceType: string;\n      sourceId?: string;\n      metadata?: any;\n      createdAt: Date;\n      updatedAt: Date;\n    }>\n  > {\n    const result = await this.withDatabase(async () => {\n      const results = await this.db.select().from(messageServerTable);\n      return results.map((r) => ({\n        id: r.id as UUID,\n        name: r.name,\n        sourceType: r.sourceType,\n        sourceId: r.sourceId || undefined,\n        metadata: r.metadata || undefined,\n        createdAt: r.createdAt,\n        updatedAt: r.updatedAt,\n      }));\n    });\n    // Guard against null return\n    return result || [];\n  }\n\n  /**\n   * Gets a message server by ID\n   */\n  async getMessageServerById(serverId: UUID): Promise<{\n    id: UUID;\n    name: string;\n    sourceType: string;\n    sourceId?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  } | null> {\n    return this.withDatabase(async () => {\n      const results = await this.db\n        .select()\n        .from(messageServerTable)\n        .where(eq(messageServerTable.id, serverId))\n        .limit(1);\n      return results.length > 0\n        ? {\n            id: results[0].id as UUID,\n            name: results[0].name,\n            sourceType: results[0].sourceType,\n            sourceId: results[0].sourceId || undefined,\n            metadata: results[0].metadata || undefined,\n            createdAt: results[0].createdAt,\n            updatedAt: results[0].updatedAt,\n          }\n        : null;\n    });\n  }\n\n  /**\n   * Creates a new channel\n   */\n  async createChannel(\n    data: {\n      id?: UUID; // Allow passing a specific ID\n      messageServerId: UUID;\n      name: string;\n      type: string;\n      sourceType?: string;\n      sourceId?: string;\n      topic?: string;\n      metadata?: any;\n    },\n    participantIds?: UUID[]\n  ): Promise<{\n    id: UUID;\n    messageServerId: UUID;\n    name: string;\n    type: string;\n    sourceType?: string;\n    sourceId?: string;\n    topic?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const newId = data.id || (v4() as UUID);\n      const now = new Date();\n      const channelToInsert = {\n        id: newId,\n        messageServerId: data.messageServerId,\n        name: data.name,\n        type: data.type,\n        sourceType: data.sourceType,\n        sourceId: data.sourceId,\n        topic: data.topic,\n        metadata: data.metadata,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await this.db.transaction(async (tx) => {\n        await tx.insert(channelTable).values(channelToInsert);\n\n        if (participantIds && participantIds.length > 0) {\n          const participantValues = participantIds.map((userId) => ({\n            channelId: newId,\n            userId: userId,\n          }));\n          await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();\n        }\n      });\n\n      return channelToInsert;\n    });\n  }\n\n  /**\n   * Gets channels for a server\n   */\n  async getChannelsForServer(serverId: UUID): Promise<\n    Array<{\n      id: UUID;\n      messageServerId: UUID;\n      name: string;\n      type: string;\n      sourceType?: string;\n      sourceId?: string;\n      topic?: string;\n      metadata?: any;\n      createdAt: Date;\n      updatedAt: Date;\n    }>\n  > {\n    return this.withDatabase(async () => {\n      const results = await this.db\n        .select()\n        .from(channelTable)\n        .where(eq(channelTable.messageServerId, serverId));\n      return results.map((r) => ({\n        id: r.id as UUID,\n        messageServerId: r.messageServerId as UUID,\n        name: r.name,\n        type: r.type,\n        sourceType: r.sourceType || undefined,\n        sourceId: r.sourceId || undefined,\n        topic: r.topic || undefined,\n        metadata: r.metadata || undefined,\n        createdAt: r.createdAt,\n        updatedAt: r.updatedAt,\n      }));\n    });\n  }\n\n  /**\n   * Gets channel details\n   */\n  async getChannelDetails(channelId: UUID): Promise<{\n    id: UUID;\n    messageServerId: UUID;\n    name: string;\n    type: string;\n    sourceType?: string;\n    sourceId?: string;\n    topic?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  } | null> {\n    return this.withDatabase(async () => {\n      const results = await this.db\n        .select()\n        .from(channelTable)\n        .where(eq(channelTable.id, channelId))\n        .limit(1);\n      return results.length > 0\n        ? {\n            id: results[0].id as UUID,\n            messageServerId: results[0].messageServerId as UUID,\n            name: results[0].name,\n            type: results[0].type,\n            sourceType: results[0].sourceType || undefined,\n            sourceId: results[0].sourceId || undefined,\n            topic: results[0].topic || undefined,\n            metadata: results[0].metadata || undefined,\n            createdAt: results[0].createdAt,\n            updatedAt: results[0].updatedAt,\n          }\n        : null;\n    });\n  }\n\n  /**\n   * Creates a message\n   */\n  async createMessage(data: {\n    channelId: UUID;\n    authorId: UUID;\n    content: string;\n    rawMessage?: any;\n    sourceType?: string;\n    sourceId?: string;\n    metadata?: any;\n    inReplyToRootMessageId?: UUID;\n    messageId?: UUID;\n  }): Promise<{\n    id: UUID;\n    channelId: UUID;\n    authorId: UUID;\n    content: string;\n    rawMessage?: any;\n    sourceType?: string;\n    sourceId?: string;\n    metadata?: any;\n    inReplyToRootMessageId?: UUID;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const newId = data.messageId || (v4() as UUID);\n      const now = new Date();\n      const messageToInsert = {\n        id: newId,\n        channelId: data.channelId,\n        authorId: data.authorId,\n        content: data.content,\n        rawMessage: data.rawMessage,\n        sourceType: data.sourceType,\n        sourceId: data.sourceId,\n        metadata: data.metadata,\n        inReplyToRootMessageId: data.inReplyToRootMessageId,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await this.db.insert(messageTable).values(messageToInsert);\n      return messageToInsert;\n    });\n  }\n\n  async getMessageById(id: UUID): Promise<{\n    id: UUID;\n    channelId: UUID;\n    authorId: UUID;\n    content: string;\n    rawMessage?: any;\n    sourceType?: string;\n    sourceId?: string;\n    metadata?: any;\n    inReplyToRootMessageId?: UUID;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const rows = await this.db\n        .select()\n        .from(messageTable)\n        .where(eq(messageTable.id, id))\n        .limit(1);\n      return rows?.[0] ?? null;\n    });\n  }\n\n  async updateMessage(\n    id: UUID,\n    patch: {\n      content?: string;\n      rawMessage?: any;\n      sourceType?: string;\n      sourceId?: string;\n      metadata?: any;\n      inReplyToRootMessageId?: UUID;\n    }\n  ): Promise<{\n    id: UUID;\n    channelId: UUID;\n    authorId: UUID;\n    content: string;\n    rawMessage?: any;\n    sourceType?: string;\n    sourceId?: string;\n    metadata?: any;\n    inReplyToRootMessageId?: UUID;\n    createdAt: Date;\n    updatedAt: Date;\n  } | null> {\n    return this.withDatabase(async () => {\n      const existing = await this.getMessageById(id);\n      if (!existing) return null;\n\n      const updatedAt = new Date();\n      const next = {\n        content: patch.content ?? existing.content,\n        rawMessage: patch.rawMessage ?? existing.rawMessage,\n        sourceType: patch.sourceType ?? existing.sourceType,\n        sourceId: patch.sourceId ?? existing.sourceId,\n        metadata: patch.metadata ?? existing.metadata,\n        inReplyToRootMessageId: patch.inReplyToRootMessageId ?? existing.inReplyToRootMessageId,\n        updatedAt,\n      };\n\n      await this.db.update(messageTable).set(next).where(eq(messageTable.id, id));\n\n      // Return merged object\n      return {\n        ...existing,\n        ...next,\n      };\n    });\n  }\n\n  /**\n   * Gets messages for a channel\n   */\n  async getMessagesForChannel(\n    channelId: UUID,\n    limit: number = 50,\n    beforeTimestamp?: Date\n  ): Promise<\n    Array<{\n      id: UUID;\n      channelId: UUID;\n      authorId: UUID;\n      content: string;\n      rawMessage?: any;\n      sourceType?: string;\n      sourceId?: string;\n      metadata?: any;\n      inReplyToRootMessageId?: UUID;\n      createdAt: Date;\n      updatedAt: Date;\n    }>\n  > {\n    return this.withDatabase(async () => {\n      const conditions = [eq(messageTable.channelId, channelId)];\n      if (beforeTimestamp) {\n        conditions.push(lt(messageTable.createdAt, beforeTimestamp));\n      }\n\n      const query = this.db\n        .select()\n        .from(messageTable)\n        .where(and(...conditions))\n        .orderBy(desc(messageTable.createdAt))\n        .limit(limit);\n\n      const results = await query;\n      return results.map((r) => ({\n        id: r.id as UUID,\n        channelId: r.channelId as UUID,\n        authorId: r.authorId as UUID,\n        content: r.content,\n        rawMessage: r.rawMessage || undefined,\n        sourceType: r.sourceType || undefined,\n        sourceId: r.sourceId || undefined,\n        metadata: r.metadata || undefined,\n        inReplyToRootMessageId: r.inReplyToRootMessageId as UUID | undefined,\n        createdAt: r.createdAt,\n        updatedAt: r.updatedAt,\n      }));\n    });\n  }\n\n  /**\n   * Deletes a message\n   */\n  async deleteMessage(messageId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.delete(messageTable).where(eq(messageTable.id, messageId));\n    });\n  }\n\n  /**\n   * Updates a channel\n   */\n  async updateChannel(\n    channelId: UUID,\n    updates: { name?: string; participantCentralUserIds?: UUID[]; metadata?: any }\n  ): Promise<{\n    id: UUID;\n    messageServerId: UUID;\n    name: string;\n    type: string;\n    sourceType?: string;\n    sourceId?: string;\n    topic?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const now = new Date();\n\n      await this.db.transaction(async (tx) => {\n        // Update channel details\n        const updateData: any = { updatedAt: now };\n        if (updates.name !== undefined) updateData.name = updates.name;\n        if (updates.metadata !== undefined) updateData.metadata = updates.metadata;\n\n        await tx.update(channelTable).set(updateData).where(eq(channelTable.id, channelId));\n\n        // Update participants if provided\n        if (updates.participantCentralUserIds !== undefined) {\n          // Remove existing participants\n          await tx\n            .delete(channelParticipantsTable)\n            .where(eq(channelParticipantsTable.channelId, channelId));\n\n          // Add new participants\n          if (updates.participantCentralUserIds.length > 0) {\n            const participantValues = updates.participantCentralUserIds.map((userId) => ({\n              channelId: channelId,\n              userId: userId,\n            }));\n            await tx\n              .insert(channelParticipantsTable)\n              .values(participantValues)\n              .onConflictDoNothing();\n          }\n        }\n      });\n\n      // Return updated channel details\n      const updatedChannel = await this.getChannelDetails(channelId);\n      if (!updatedChannel) {\n        throw new Error(`Channel ${channelId} not found after update`);\n      }\n      return updatedChannel;\n    });\n  }\n\n  /**\n   * Deletes a channel and all its associated data\n   */\n  async deleteChannel(channelId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db.transaction(async (tx) => {\n        // Delete all messages in the channel (cascade delete will handle this, but explicit is better)\n        await tx.delete(messageTable).where(eq(messageTable.channelId, channelId));\n\n        // Delete all participants (cascade delete will handle this, but explicit is better)\n        await tx\n          .delete(channelParticipantsTable)\n          .where(eq(channelParticipantsTable.channelId, channelId));\n\n        // Delete the channel itself\n        await tx.delete(channelTable).where(eq(channelTable.id, channelId));\n      });\n    });\n  }\n\n  /**\n   * Adds participants to a channel\n   */\n  async addChannelParticipants(channelId: UUID, userIds: UUID[]): Promise<void> {\n    return this.withDatabase(async () => {\n      if (!userIds || userIds.length === 0) return;\n\n      const participantValues = userIds.map((userId) => ({\n        channelId: channelId,\n        userId: userId,\n      }));\n\n      await this.db\n        .insert(channelParticipantsTable)\n        .values(participantValues)\n        .onConflictDoNothing();\n    });\n  }\n\n  /**\n   * Gets participants for a channel\n   */\n  async getChannelParticipants(channelId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const results = await this.db\n        .select({ userId: channelParticipantsTable.userId })\n        .from(channelParticipantsTable)\n        .where(eq(channelParticipantsTable.channelId, channelId));\n\n      return results.map((r) => r.userId as UUID);\n    });\n  }\n\n  /**\n   * Adds an agent to a server\n   */\n  async addAgentToServer(serverId: UUID, agentId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .insert(serverAgentsTable)\n        .values({\n          serverId,\n          agentId,\n        })\n        .onConflictDoNothing();\n    });\n  }\n\n  /**\n   * Gets agents for a server\n   */\n  async getAgentsForServer(serverId: UUID): Promise<UUID[]> {\n    return this.withDatabase(async () => {\n      const results = await this.db\n        .select({ agentId: serverAgentsTable.agentId })\n        .from(serverAgentsTable)\n        .where(eq(serverAgentsTable.serverId, serverId));\n\n      return results.map((r) => r.agentId as UUID);\n    });\n  }\n\n  /**\n   * Removes an agent from a server\n   */\n  async removeAgentFromServer(serverId: UUID, agentId: UUID): Promise<void> {\n    return this.withDatabase(async () => {\n      await this.db\n        .delete(serverAgentsTable)\n        .where(\n          and(eq(serverAgentsTable.serverId, serverId), eq(serverAgentsTable.agentId, agentId))\n        );\n    });\n  }\n\n  /**\n   * Finds or creates a DM channel between two users\n   */\n  async findOrCreateDmChannel(\n    user1Id: UUID,\n    user2Id: UUID,\n    messageServerId: UUID\n  ): Promise<{\n    id: UUID;\n    messageServerId: UUID;\n    name: string;\n    type: string;\n    sourceType?: string;\n    sourceId?: string;\n    topic?: string;\n    metadata?: any;\n    createdAt: Date;\n    updatedAt: Date;\n  }> {\n    return this.withDatabase(async () => {\n      const ids = [user1Id, user2Id].sort();\n      const dmChannelName = `DM-${ids[0]}-${ids[1]}`;\n\n      const existingChannels = await this.db\n        .select()\n        .from(channelTable)\n        .where(\n          and(\n            eq(channelTable.type, ChannelType.DM),\n            eq(channelTable.name, dmChannelName),\n            eq(channelTable.messageServerId, messageServerId)\n          )\n        )\n        .limit(1);\n\n      if (existingChannels.length > 0) {\n        return {\n          id: existingChannels[0].id as UUID,\n          messageServerId: existingChannels[0].messageServerId as UUID,\n          name: existingChannels[0].name,\n          type: existingChannels[0].type,\n          sourceType: existingChannels[0].sourceType || undefined,\n          sourceId: existingChannels[0].sourceId || undefined,\n          topic: existingChannels[0].topic || undefined,\n          metadata: existingChannels[0].metadata || undefined,\n          createdAt: existingChannels[0].createdAt,\n          updatedAt: existingChannels[0].updatedAt,\n        };\n      }\n\n      // Create new DM channel\n      return this.createChannel(\n        {\n          messageServerId,\n          name: dmChannelName,\n          type: ChannelType.DM,\n          metadata: { user1: ids[0], user2: ids[1] },\n        },\n        ids\n      );\n    });\n  }\n}\n\n// Import tables at the end to avoid circular dependencies\n",
    "import { sql } from 'drizzle-orm';\nimport { check, foreignKey, index, pgTable, timestamp, uuid, vector } from 'drizzle-orm/pg-core';\nimport { VECTOR_DIMS } from '@elizaos/core';\nimport { memoryTable } from './memory';\n\nexport const DIMENSION_MAP = {\n  [VECTOR_DIMS.SMALL]: 'dim384',\n  [VECTOR_DIMS.MEDIUM]: 'dim512',\n  [VECTOR_DIMS.LARGE]: 'dim768',\n  [VECTOR_DIMS.XL]: 'dim1024',\n  [VECTOR_DIMS.XXL]: 'dim1536',\n  [VECTOR_DIMS.XXXL]: 'dim3072',\n} as const;\n\n/**\n * Definition of the embeddings table in the database.\n * Contains columns for ID, Memory ID, Creation Timestamp, and multiple vector dimensions.\n */\nexport const embeddingTable = pgTable(\n  'embeddings',\n  {\n    id: uuid('id').primaryKey().defaultRandom().notNull(),\n    memoryId: uuid('memory_id').references(() => memoryTable.id, { onDelete: 'cascade' }),\n    createdAt: timestamp('created_at')\n      .default(sql`now()`)\n      .notNull(),\n    dim384: vector('dim_384', { dimensions: VECTOR_DIMS.SMALL }),\n    dim512: vector('dim_512', { dimensions: VECTOR_DIMS.MEDIUM }),\n    dim768: vector('dim_768', { dimensions: VECTOR_DIMS.LARGE }),\n    dim1024: vector('dim_1024', { dimensions: VECTOR_DIMS.XL }),\n    dim1536: vector('dim_1536', { dimensions: VECTOR_DIMS.XXL }),\n    dim3072: vector('dim_3072', { dimensions: VECTOR_DIMS.XXXL }),\n  },\n  (table) => [\n    check('embedding_source_check', sql`\"memory_id\" IS NOT NULL`),\n    index('idx_embedding_memory').on(table.memoryId),\n    foreignKey({\n      name: 'fk_embedding_memory',\n      columns: [table.memoryId],\n      foreignColumns: [memoryTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n\n/**\n * Defines the possible values for the Embedding Dimension Column.\n * It can be \"dim384\", \"dim512\", \"dim768\", \"dim1024\", \"dim1536\", or \"dim3072\".\n */\nexport type EmbeddingDimensionColumn =\n  | 'dim384'\n  | 'dim512'\n  | 'dim768'\n  | 'dim1024'\n  | 'dim1536'\n  | 'dim3072';\n\n/**\n * Retrieve the type of a specific column in the EmbeddingTable based on the EmbeddingDimensionColumn key.\n */\nexport type EmbeddingTableColumn = (typeof embeddingTable._.columns)[EmbeddingDimensionColumn];\n",
    "import { relations, sql } from 'drizzle-orm';\nimport {\n  boolean,\n  check,\n  foreignKey,\n  index,\n  jsonb,\n  pgTable,\n  text,\n  timestamp,\n  uuid,\n} from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { embeddingTable } from './embedding';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\n\n/**\n * Definition of the memory table in the database.\n *\n * @param {string} tableName - The name of the table.\n * @param {object} columns - An object containing the column definitions.\n * @param {function} indexes - A function that defines the indexes for the table.\n * @returns {object} - The memory table object.\n */\nexport const memoryTable = pgTable(\n  'memories',\n  {\n    id: uuid('id').primaryKey().notNull(),\n    type: text('type').notNull(),\n    createdAt: timestamp('createdAt')\n      .default(sql`now()`)\n      .notNull(),\n    content: jsonb('content').notNull(),\n    entityId: uuid('entityId').references(() => entityTable.id, {\n      onDelete: 'cascade',\n    }),\n    agentId: uuid('agentId')\n      .references(() => agentTable.id, {\n        onDelete: 'cascade',\n      })\n      .notNull(),\n    roomId: uuid('roomId').references(() => roomTable.id, {\n      onDelete: 'cascade',\n    }),\n    worldId: uuid('worldId'),\n    // .references(() => worldTable.id, {\n    //   onDelete: 'set null',\n    // }),\n    unique: boolean('unique').default(true).notNull(),\n    metadata: jsonb('metadata').default({}).notNull(),\n  },\n  (table) => [\n    index('idx_memories_type_room').on(table.type, table.roomId),\n    index('idx_memories_world_id').on(table.worldId),\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_agent',\n      columns: [table.agentId],\n      foreignColumns: [agentTable.id],\n    }).onDelete('cascade'),\n    // foreignKey({\n    //   name: 'fk_world',\n    //   columns: [table.worldId],\n    //   foreignColumns: [worldTable.id],\n    // }).onDelete('set null'),\n    index('idx_memories_metadata_type').on(sql`((metadata->>'type'))`),\n    index('idx_memories_document_id').on(sql`((metadata->>'documentId'))`),\n    index('idx_fragments_order').on(\n      sql`((metadata->>'documentId'))`,\n      sql`((metadata->>'position'))`\n    ),\n    check(\n      'fragment_metadata_check',\n      sql`\n            CASE \n                WHEN metadata->>'type' = 'fragment' THEN\n                    metadata ? 'documentId' AND \n                    metadata ? 'position'\n                ELSE true\n            END\n        `\n    ),\n    check(\n      'document_metadata_check',\n      sql`\n            CASE \n                WHEN metadata->>'type' = 'document' THEN\n                    metadata ? 'timestamp'\n                ELSE true\n            END\n        `\n    ),\n  ]\n);\n\nexport const memoryRelations = relations(memoryTable, ({ one }) => ({\n  embedding: one(embeddingTable),\n}));\n",
    "import type { MessageExample } from '@elizaos/core';\nimport { sql } from 'drizzle-orm';\nimport { boolean, jsonb, pgTable, text, timestamp, unique, uuid } from 'drizzle-orm/pg-core';\n\n/**\n * Represents a table for storing agent data.\n *\n * @type {Table}\n */\nexport const agentTable = pgTable(\n  'agents',\n  {\n    id: uuid('id').primaryKey().defaultRandom(),\n    enabled: boolean('enabled').default(true).notNull(),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n\n    updatedAt: timestamp('updated_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n\n    // Character\n    name: text('name').notNull(),\n    username: text('username'),\n    system: text('system').default(''),\n    bio: jsonb('bio')\n      .$type<string | string[]>()\n      .default(sql`'[]'::jsonb`),\n    messageExamples: jsonb('message_examples')\n      .$type<MessageExample[][]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    postExamples: jsonb('post_examples')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    topics: jsonb('topics')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    adjectives: jsonb('adjectives')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    knowledge: jsonb('knowledge')\n      .$type<(string | { path: string; shared?: boolean })[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    plugins: jsonb('plugins')\n      .$type<string[]>()\n      .default(sql`'[]'::jsonb`)\n      .notNull(),\n    settings: jsonb('settings')\n      .$type<{\n        secrets?: { [key: string]: string | boolean | number };\n        [key: string]: unknown;\n      }>()\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n    style: jsonb('style')\n      .$type<{\n        all?: string[];\n        chat?: string[];\n        post?: string[];\n      }>()\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n  },\n  (table) => {\n    return {\n      nameUnique: unique('name_unique').on(table.name),\n    };\n  }\n);\n",
    "import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, timestamp, unique, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\n\n/**\n * Represents an entity table in the database.\n * Includes columns for id, agentId, createdAt, names, and metadata.\n */\nexport const entityTable = pgTable(\n  'entities',\n  {\n    id: uuid('id').notNull().primaryKey(),\n    agentId: uuid('agent_id')\n      .notNull()\n      .references(() => agentTable.id, {\n        onDelete: 'cascade',\n      }),\n    createdAt: timestamp('created_at')\n      .default(sql`now()`)\n      .notNull(),\n    names: text('names')\n      .array()\n      .default(sql`'{}'::text[]`)\n      .notNull(),\n    metadata: jsonb('metadata')\n      .default(sql`'{}'::jsonb`)\n      .notNull(),\n  },\n  (table) => {\n    return {\n      idAgentIdUnique: unique('id_agent_id_unique').on(table.id, table.agentId),\n    };\n  }\n);\n",
    "import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\n\n/**\n * Defines a table schema for 'rooms' in the database.\n *\n * @typedef {object} RoomTable\n * @property {string} id - The unique identifier for the room.\n * @property {string} agentId - The UUID of the agent associated with the room.\n * @property {string} source - The source of the room.\n * @property {string} type - The type of the room.\n * @property {string} serverId - The server ID of the room.\n * @property {string} worldId - The UUID of the world associated with the room.\n * @property {string} name - The name of the room.\n * @property {object} metadata - Additional metadata for the room in JSON format.\n * @property {string} channelId - The channel ID of the room.\n * @property {number} createdAt - The timestamp of when the room was created.\n */\nexport const roomTable = pgTable('rooms', {\n  id: uuid('id')\n    .notNull()\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  agentId: uuid('agentId').references(() => agentTable.id, {\n    onDelete: 'cascade',\n  }),\n  source: text('source').notNull(),\n  type: text('type').notNull(),\n  serverId: text('serverId'),\n  worldId: uuid('worldId'), // no guarantee that world exists, it is optional for now\n  // .references(() => worldTable.id, {\n  //   onDelete: 'cascade',\n  // }),\n  name: text('name'),\n  metadata: jsonb('metadata'),\n  channelId: text('channelId'),\n  createdAt: timestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n",
    "import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, primaryKey, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\n\n/**\n * Represents a PostgreSQL table for caching data.\n *\n * @type {pgTable}\n */\nexport const cacheTable = pgTable(\n  'cache',\n  {\n    key: text('key').notNull(),\n    agentId: uuid('agent_id')\n      .notNull()\n      .references(() => agentTable.id, { onDelete: 'cascade' }),\n    value: jsonb('value').notNull(),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n    expiresAt: timestamp('expires_at', { withTimezone: true }),\n  },\n  (table) => ({\n    pk: primaryKey({ columns: [table.key, table.agentId] }),\n  })\n);\n",
    "import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\nimport { worldTable } from './world';\n\n/**\n * Represents a component table in the database.\n */\nexport const componentTable = pgTable('components', {\n  id: uuid('id')\n    .primaryKey()\n    .default(sql`gen_random_uuid()`)\n    .notNull(),\n\n  // Foreign keys\n  entityId: uuid('entityId')\n    .references(() => entityTable.id, { onDelete: 'cascade' })\n    .notNull(),\n  agentId: uuid('agentId')\n    .references(() => agentTable.id, { onDelete: 'cascade' })\n    .notNull(),\n  roomId: uuid('roomId')\n    .references(() => roomTable.id, { onDelete: 'cascade' })\n    .notNull(),\n  worldId: uuid('worldId').references(() => worldTable.id, { onDelete: 'cascade' }),\n  sourceEntityId: uuid('sourceEntityId').references(() => entityTable.id, { onDelete: 'cascade' }),\n\n  // Data\n  type: text('type').notNull(),\n  data: jsonb('data').default(sql`'{}'::jsonb`),\n\n  // Timestamps\n  createdAt: timestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n",
    "import { sql } from 'drizzle-orm';\nimport { jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\n\n/**\n * Represents a table schema for worlds in the database.\n *\n * @type {PgTable}\n */\n\nexport const worldTable = pgTable('worlds', {\n  id: uuid('id')\n    .notNull()\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  agentId: uuid('agentId')\n    .notNull()\n    .references(() => agentTable.id, { onDelete: 'cascade' }),\n  name: text('name').notNull(),\n  metadata: jsonb('metadata'),\n  serverId: text('serverId').notNull().default('local'),\n  createdAt: timestamp('createdAt')\n    .default(sql`now()`)\n    .notNull(),\n});\n",
    "import { sql } from 'drizzle-orm';\nimport { foreignKey, jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\n\n/**\n * Represents a PostgreSQL table for storing logs.\n *\n * @type {Table}\n */\n\nexport const logTable = pgTable(\n  'logs',\n  {\n    id: uuid('id').defaultRandom().notNull(),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n    entityId: uuid('entityId')\n      .notNull()\n      .references(() => entityTable.id, { onDelete: 'cascade' }),\n    body: jsonb('body').notNull(),\n    type: text('type').notNull(),\n    roomId: uuid('roomId')\n      .notNull()\n      .references(() => roomTable.id, { onDelete: 'cascade' }),\n  },\n  (table) => [\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n",
    "import { sql } from 'drizzle-orm';\nimport { foreignKey, index, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\nimport { roomTable } from './room';\n\n/**\n * Defines the schema for the \"participants\" table in the database.\n *\n * @type {import('knex').TableBuilder}\n */\nexport const participantTable = pgTable(\n  'participants',\n  {\n    id: uuid('id')\n      .notNull()\n      .primaryKey()\n      .default(sql`gen_random_uuid()`),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n    entityId: uuid('entityId').references(() => entityTable.id, {\n      onDelete: 'cascade',\n    }),\n    roomId: uuid('roomId').references(() => roomTable.id, {\n      onDelete: 'cascade',\n    }),\n    agentId: uuid('agentId').references(() => agentTable.id, {\n      onDelete: 'cascade',\n    }),\n    roomState: text('roomState'),\n  },\n  (table) => [\n    // unique(\"participants_user_room_agent_unique\").on(table.entityId, table.roomId, table.agentId),\n    index('idx_participants_user').on(table.entityId),\n    index('idx_participants_room').on(table.roomId),\n    foreignKey({\n      name: 'fk_room',\n      columns: [table.roomId],\n      foreignColumns: [roomTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user',\n      columns: [table.entityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n",
    "import { sql } from 'drizzle-orm';\nimport {\n  foreignKey,\n  index,\n  jsonb,\n  pgTable,\n  text,\n  timestamp,\n  unique,\n  uuid,\n} from 'drizzle-orm/pg-core';\nimport { agentTable } from './agent';\nimport { entityTable } from './entity';\n\n/**\n * Defines the relationshipTable containing information about relationships between entities and agents.\n * @type {import('knex').TableBuilder}\n */\nexport const relationshipTable = pgTable(\n  'relationships',\n  {\n    id: uuid('id')\n      .notNull()\n      .primaryKey()\n      .default(sql`gen_random_uuid()`),\n    createdAt: timestamp('created_at', { withTimezone: true })\n      .default(sql`now()`)\n      .notNull(),\n    sourceEntityId: uuid('sourceEntityId')\n      .notNull()\n      .references(() => entityTable.id, { onDelete: 'cascade' }),\n    targetEntityId: uuid('targetEntityId')\n      .notNull()\n      .references(() => entityTable.id, { onDelete: 'cascade' }),\n    agentId: uuid('agentId')\n      .notNull()\n      .references(() => agentTable.id, { onDelete: 'cascade' }),\n    tags: text('tags').array(),\n    metadata: jsonb('metadata'),\n  },\n  (table) => [\n    index('idx_relationships_users').on(table.sourceEntityId, table.targetEntityId),\n    unique('unique_relationship').on(table.sourceEntityId, table.targetEntityId, table.agentId),\n    foreignKey({\n      name: 'fk_user_a',\n      columns: [table.sourceEntityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n    foreignKey({\n      name: 'fk_user_b',\n      columns: [table.targetEntityId],\n      foreignColumns: [entityTable.id],\n    }).onDelete('cascade'),\n  ]\n);\n",
    "import { jsonb, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\nimport { agentTable } from './agent';\n\n/**\n * Represents a table schema for tasks in the database.\n *\n * @type {PgTable}\n */\nexport const taskTable = pgTable('tasks', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  name: text('name').notNull(),\n  description: text('description'),\n  roomId: uuid('roomId'),\n  worldId: uuid('worldId'),\n  entityId: uuid('entityId'),\n  agentId: uuid('agent_id')\n    .notNull()\n    .references(() => agentTable.id, { onDelete: 'cascade' }),\n  tags: text('tags')\n    .array()\n    .default(sql`'{}'::text[]`),\n  metadata: jsonb('metadata').default(sql`'{}'::jsonb`),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),\n});\n",
    "import { pgTable, text, jsonb, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\n\nexport const messageServerTable = pgTable('message_servers', {\n  id: uuid('id').primaryKey(),\n  name: text('name').notNull(),\n  sourceType: text('source_type').notNull(),\n  sourceId: text('source_id'),\n  metadata: jsonb('metadata'),\n  createdAt: timestamp('created_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n  updatedAt: timestamp('updated_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n});\n",
    "import { pgTable, text, jsonb, timestamp, uuid } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\nimport { messageServerTable } from './messageServer';\n\nexport const channelTable = pgTable('channels', {\n  id: text('id').primaryKey(), // UUID stored as text\n  messageServerId: uuid('server_id')\n    .notNull()\n    .references(() => messageServerTable.id, { onDelete: 'cascade' }),\n  name: text('name').notNull(),\n  type: text('type').notNull(), // Store ChannelType enum values as text\n  sourceType: text('source_type'),\n  sourceId: text('source_id'),\n  topic: text('topic'),\n  metadata: jsonb('metadata'),\n  createdAt: timestamp('created_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n  updatedAt: timestamp('updated_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n});\n",
    "import { pgTable, text, jsonb, timestamp } from 'drizzle-orm/pg-core';\nimport { sql } from 'drizzle-orm';\nimport { channelTable } from './channel';\n\nexport const messageTable = pgTable('central_messages', {\n  id: text('id').primaryKey(), // UUID stored as text\n  channelId: text('channel_id')\n    .notNull()\n    .references(() => channelTable.id, { onDelete: 'cascade' }),\n  authorId: text('author_id').notNull(),\n  content: text('content').notNull(),\n  rawMessage: jsonb('raw_message'),\n  inReplyToRootMessageId: text('in_reply_to_root_message_id').references(() => messageTable.id, {\n    onDelete: 'set null',\n  }),\n  sourceType: text('source_type'),\n  sourceId: text('source_id'),\n  metadata: jsonb('metadata'),\n  createdAt: timestamp('created_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n  updatedAt: timestamp('updated_at', { mode: 'date' })\n    .default(sql`CURRENT_TIMESTAMP`)\n    .notNull(),\n});\n",
    "import { pgTable, text, primaryKey } from 'drizzle-orm/pg-core';\nimport { channelTable } from './channel';\n\nexport const channelParticipantsTable = pgTable(\n  'channel_participants',\n  {\n    channelId: text('channel_id')\n      .notNull()\n      .references(() => channelTable.id, { onDelete: 'cascade' }),\n    userId: text('user_id').notNull(), // This is a central UUID (can be an agentId or a dedicated central user ID)\n  },\n  (table) => ({\n    pk: primaryKey({ columns: [table.channelId, table.userId] }),\n  })\n);\n",
    "import { pgTable, uuid, primaryKey } from 'drizzle-orm/pg-core';\nimport { messageServerTable } from './messageServer';\nimport { agentTable } from './agent';\n\nexport const serverAgentsTable = pgTable(\n  'server_agents',\n  {\n    serverId: uuid('server_id')\n      .notNull()\n      .references(() => messageServerTable.id, { onDelete: 'cascade' }),\n    agentId: uuid('agent_id')\n      .notNull()\n      .references(() => agentTable.id, { onDelete: 'cascade' }),\n  },\n  (table) => ({\n    pk: primaryKey({ columns: [table.serverId, table.agentId] }),\n  })\n);\n",
    "import { PGlite, type PGliteOptions } from '@electric-sql/pglite';\nimport { fuzzystrmatch } from '@electric-sql/pglite/contrib/fuzzystrmatch';\nimport { vector } from '@electric-sql/pglite/vector';\nimport type { IDatabaseClientManager } from '../types';\n\n/**\n * Class representing a database client manager for PGlite.\n * @implements { IDatabaseClientManager }\n */\nexport class PGliteClientManager implements IDatabaseClientManager<PGlite> {\n  private client: PGlite;\n  private shuttingDown = false;\n\n  /**\n   * Constructor for creating a new instance of PGlite with the provided options.\n   * Initializes the PGlite client with additional extensions.\n   * @param {PGliteOptions} options - The options to configure the PGlite client.\n   */\n  constructor(options: PGliteOptions) {\n    this.client = new PGlite({\n      ...options,\n      extensions: {\n        vector,\n        fuzzystrmatch,\n      },\n    });\n    this.setupShutdownHandlers();\n  }\n\n  public getConnection(): PGlite {\n    return this.client;\n  }\n\n  public isShuttingDown(): boolean {\n    return this.shuttingDown;\n  }\n\n  public async initialize(): Promise<void> {\n    // Kept for backward compatibility\n  }\n\n  public async close(): Promise<void> {\n    this.shuttingDown = true;\n  }\n\n  private setupShutdownHandlers() {\n    // Implementation of setupShutdownHandlers method\n  }\n}\n",
    "import { type UUID, logger, Agent, Entity, Memory, Component } from '@elizaos/core';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { BaseDrizzleAdapter } from '../base';\nimport { DIMENSION_MAP, type EmbeddingDimensionColumn } from '../schema/embedding';\nimport type { PostgresConnectionManager } from './manager';\n\n/**\n * Adapter class for interacting with a PostgreSQL database.\n * Extends BaseDrizzleAdapter.\n */\nexport class PgDatabaseAdapter extends BaseDrizzleAdapter {\n  protected embeddingDimension: EmbeddingDimensionColumn = DIMENSION_MAP[384];\n  private manager: PostgresConnectionManager;\n\n  constructor(agentId: UUID, manager: PostgresConnectionManager, _schema?: any) {\n    super(agentId);\n    this.manager = manager;\n    this.db = manager.getDatabase();\n  }\n\n  // Methods required by TypeScript but not in base class\n  async getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null> {\n    // Delegate to the correct method name\n    return this.getEntitiesByIds(entityIds);\n  }\n\n  async getMemoriesByServerId(_params: { serverId: UUID; count?: number }): Promise<Memory[]> {\n    // This method doesn't seem to exist in the base implementation\n    // Provide a basic implementation that returns empty array\n    logger.warn('getMemoriesByServerId called but not implemented - returning empty array');\n    return [];\n  }\n\n  async ensureAgentExists(agent: Partial<Agent>): Promise<Agent> {\n    // Check if agent exists, create if not\n    const existingAgent = await this.getAgent(this.agentId);\n    if (existingAgent) {\n      return existingAgent;\n    }\n\n    // Create the agent with required fields\n    const newAgent: Agent = {\n      id: this.agentId,\n      name: agent.name || 'Unknown Agent',\n      username: agent.username,\n      bio: agent.bio || 'An AI agent',\n      createdAt: agent.createdAt || Date.now(),\n      updatedAt: agent.updatedAt || Date.now(),\n    };\n\n    await this.createAgent(newAgent);\n    const createdAgent = await this.getAgent(this.agentId);\n    if (!createdAgent) {\n      throw new Error('Failed to create agent');\n    }\n    return createdAgent;\n  }\n\n  /**\n   * Executes the provided operation with a database connection.\n   *\n   * @template T\n   * @param {() => Promise<T>} operation - The operation to be executed with the database connection.\n   * @returns {Promise<T>} A promise that resolves with the result of the operation.\n   */\n  protected async withDatabase<T>(operation: () => Promise<T>): Promise<T> {\n    return await this.withRetry(async () => {\n      const client = await this.manager.getClient();\n      try {\n        // Cast to any to avoid type conflicts between different pg versions\n        const db = drizzle(client as any);\n        this.db = db;\n\n        return await operation();\n      } finally {\n        client.release();\n      }\n    });\n  }\n\n  /**\n   * Asynchronously initializes the PgDatabaseAdapter by running migrations using the manager.\n   * Logs a success message if initialization is successful, otherwise logs an error message.\n   *\n   * @returns {Promise<void>} A promise that resolves when initialization is complete.\n   */\n  async init(): Promise<void> {\n    logger.debug('PgDatabaseAdapter initialized, skipping automatic migrations.');\n  }\n\n  /**\n   * Checks if the database connection is ready and active.\n   * @returns {Promise<boolean>} A Promise that resolves to true if the connection is healthy.\n   */\n  async isReady(): Promise<boolean> {\n    return this.manager.testConnection();\n  }\n\n  /**\n   * Asynchronously closes the manager associated with this instance.\n   *\n   * @returns A Promise that resolves once the manager is closed.\n   */\n  async close(): Promise<void> {\n    await this.manager.close();\n  }\n\n  /**\n   * Asynchronously retrieves the connection from the manager.\n   *\n   * @returns {Promise<Pool>} A Promise that resolves with the connection.\n   */\n  async getConnection() {\n    return this.manager.getConnection();\n  }\n\n  async createAgent(agent: Agent): Promise<boolean> {\n    return super.createAgent(agent);\n  }\n\n  getAgent(agentId: UUID): Promise<Agent | null> {\n    return super.getAgent(agentId);\n  }\n\n  updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean> {\n    return super.updateAgent(agentId, agent);\n  }\n\n  deleteAgent(agentId: UUID): Promise<boolean> {\n    return super.deleteAgent(agentId);\n  }\n\n  createEntities(entities: Entity[]): Promise<boolean> {\n    return super.createEntities(entities);\n  }\n\n  getEntitiesByIds(entityIds: UUID[]): Promise<Entity[]> {\n    return super.getEntitiesByIds(entityIds).then((result) => result || []);\n  }\n\n  updateEntity(entity: Entity): Promise<void> {\n    return super.updateEntity(entity);\n  }\n\n  createMemory(memory: Memory, tableName: string): Promise<UUID> {\n    return super.createMemory(memory, tableName);\n  }\n\n  getMemoryById(memoryId: UUID): Promise<Memory | null> {\n    return super.getMemoryById(memoryId);\n  }\n\n  searchMemories(params: any): Promise<any[]> {\n    return super.searchMemories(params);\n  }\n\n  updateMemory(memory: Partial<Memory> & { id: UUID }): Promise<boolean> {\n    return super.updateMemory(memory);\n  }\n\n  deleteMemory(memoryId: UUID): Promise<void> {\n    return super.deleteMemory(memoryId);\n  }\n\n  createComponent(component: Component): Promise<boolean> {\n    return super.createComponent(component);\n  }\n\n  getComponent(\n    entityId: UUID,\n    type: string,\n    worldId?: UUID,\n    sourceEntityId?: UUID\n  ): Promise<Component | null> {\n    return super.getComponent(entityId, type, worldId, sourceEntityId);\n  }\n\n  updateComponent(component: Component): Promise<void> {\n    return super.updateComponent(component);\n  }\n\n  deleteComponent(componentId: UUID): Promise<void> {\n    return super.deleteComponent(componentId);\n  }\n}\n",
    "import pg from \"pg\";\nimport { entityKind } from \"../entity.js\";\nimport { DefaultLogger } from \"../logger.js\";\nimport { PgDatabase } from \"../pg-core/db.js\";\nimport { PgDialect } from \"../pg-core/dialect.js\";\nimport {\n  createTableRelationsHelpers,\n  extractTablesRelationalConfig\n} from \"../relations.js\";\nimport { isConfig } from \"../utils.js\";\nimport { NodePgSession } from \"./session.js\";\nclass NodePgDriver {\n  constructor(client, dialect, options = {}) {\n    this.client = client;\n    this.dialect = dialect;\n    this.options = options;\n  }\n  static [entityKind] = \"NodePgDriver\";\n  createSession(schema) {\n    return new NodePgSession(this.client, this.dialect, schema, {\n      logger: this.options.logger,\n      cache: this.options.cache\n    });\n  }\n}\nclass NodePgDatabase extends PgDatabase {\n  static [entityKind] = \"NodePgDatabase\";\n}\nfunction construct(client, config = {}) {\n  const dialect = new PgDialect({ casing: config.casing });\n  let logger;\n  if (config.logger === true) {\n    logger = new DefaultLogger();\n  } else if (config.logger !== false) {\n    logger = config.logger;\n  }\n  let schema;\n  if (config.schema) {\n    const tablesConfig = extractTablesRelationalConfig(\n      config.schema,\n      createTableRelationsHelpers\n    );\n    schema = {\n      fullSchema: config.schema,\n      schema: tablesConfig.tables,\n      tableNamesMap: tablesConfig.tableNamesMap\n    };\n  }\n  const driver = new NodePgDriver(client, dialect, { logger, cache: config.cache });\n  const session = driver.createSession(schema);\n  const db = new NodePgDatabase(dialect, session, schema);\n  db.$client = client;\n  db.$cache = config.cache;\n  if (db.$cache) {\n    db.$cache[\"invalidate\"] = config.cache?.onMutate;\n  }\n  return db;\n}\nfunction drizzle(...params) {\n  if (typeof params[0] === \"string\") {\n    const instance = new pg.Pool({\n      connectionString: params[0]\n    });\n    return construct(instance, params[1]);\n  }\n  if (isConfig(params[0])) {\n    const { connection, client, ...drizzleConfig } = params[0];\n    if (client) return construct(client, drizzleConfig);\n    const instance = typeof connection === \"string\" ? new pg.Pool({\n      connectionString: connection\n    }) : new pg.Pool(connection);\n    return construct(instance, drizzleConfig);\n  }\n  return construct(params[0], params[1]);\n}\n((drizzle2) => {\n  function mock(config) {\n    return construct({}, config);\n  }\n  drizzle2.mock = mock;\n})(drizzle || (drizzle = {}));\nexport {\n  NodePgDatabase,\n  NodePgDriver,\n  drizzle\n};\n//# sourceMappingURL=driver.js.map",
    "import pg from \"pg\";\nimport { NoopCache } from \"../cache/core/index.js\";\nimport { entityKind } from \"../entity.js\";\nimport { NoopLogger } from \"../logger.js\";\nimport { PgTransaction } from \"../pg-core/index.js\";\nimport { PgPreparedQuery, PgSession } from \"../pg-core/session.js\";\nimport { fillPlaceholders, sql } from \"../sql/sql.js\";\nimport { tracer } from \"../tracing.js\";\nimport { mapResultRow } from \"../utils.js\";\nconst { Pool, types } = pg;\nclass NodePgPreparedQuery extends PgPreparedQuery {\n  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {\n    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);\n    this.client = client;\n    this.queryString = queryString;\n    this.params = params;\n    this.logger = logger;\n    this.fields = fields;\n    this._isResponseInArrayMode = _isResponseInArrayMode;\n    this.customResultMapper = customResultMapper;\n    this.rawQueryConfig = {\n      name,\n      text: queryString,\n      types: {\n        // @ts-ignore\n        getTypeParser: (typeId, format) => {\n          if (typeId === types.builtins.TIMESTAMPTZ) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.TIMESTAMP) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.DATE) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.INTERVAL) {\n            return (val) => val;\n          }\n          if (typeId === 1231) {\n            return (val) => val;\n          }\n          if (typeId === 1115) {\n            return (val) => val;\n          }\n          if (typeId === 1185) {\n            return (val) => val;\n          }\n          if (typeId === 1187) {\n            return (val) => val;\n          }\n          if (typeId === 1182) {\n            return (val) => val;\n          }\n          return types.getTypeParser(typeId, format);\n        }\n      }\n    };\n    this.queryConfig = {\n      name,\n      text: queryString,\n      rowMode: \"array\",\n      types: {\n        // @ts-ignore\n        getTypeParser: (typeId, format) => {\n          if (typeId === types.builtins.TIMESTAMPTZ) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.TIMESTAMP) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.DATE) {\n            return (val) => val;\n          }\n          if (typeId === types.builtins.INTERVAL) {\n            return (val) => val;\n          }\n          if (typeId === 1231) {\n            return (val) => val;\n          }\n          if (typeId === 1115) {\n            return (val) => val;\n          }\n          if (typeId === 1185) {\n            return (val) => val;\n          }\n          if (typeId === 1187) {\n            return (val) => val;\n          }\n          if (typeId === 1182) {\n            return (val) => val;\n          }\n          return types.getTypeParser(typeId, format);\n        }\n      }\n    };\n  }\n  static [entityKind] = \"NodePgPreparedQuery\";\n  rawQueryConfig;\n  queryConfig;\n  async execute(placeholderValues = {}) {\n    return tracer.startActiveSpan(\"drizzle.execute\", async () => {\n      const params = fillPlaceholders(this.params, placeholderValues);\n      this.logger.logQuery(this.rawQueryConfig.text, params);\n      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;\n      if (!fields && !customResultMapper) {\n        return tracer.startActiveSpan(\"drizzle.driver.execute\", async (span) => {\n          span?.setAttributes({\n            \"drizzle.query.name\": rawQuery.name,\n            \"drizzle.query.text\": rawQuery.text,\n            \"drizzle.query.params\": JSON.stringify(params)\n          });\n          return this.queryWithCache(rawQuery.text, params, async () => {\n            return await client.query(rawQuery, params);\n          });\n        });\n      }\n      const result = await tracer.startActiveSpan(\"drizzle.driver.execute\", (span) => {\n        span?.setAttributes({\n          \"drizzle.query.name\": query.name,\n          \"drizzle.query.text\": query.text,\n          \"drizzle.query.params\": JSON.stringify(params)\n        });\n        return this.queryWithCache(query.text, params, async () => {\n          return await client.query(query, params);\n        });\n      });\n      return tracer.startActiveSpan(\"drizzle.mapResponse\", () => {\n        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));\n      });\n    });\n  }\n  all(placeholderValues = {}) {\n    return tracer.startActiveSpan(\"drizzle.execute\", () => {\n      const params = fillPlaceholders(this.params, placeholderValues);\n      this.logger.logQuery(this.rawQueryConfig.text, params);\n      return tracer.startActiveSpan(\"drizzle.driver.execute\", (span) => {\n        span?.setAttributes({\n          \"drizzle.query.name\": this.rawQueryConfig.name,\n          \"drizzle.query.text\": this.rawQueryConfig.text,\n          \"drizzle.query.params\": JSON.stringify(params)\n        });\n        return this.queryWithCache(this.rawQueryConfig.text, params, async () => {\n          return this.client.query(this.rawQueryConfig, params);\n        }).then((result) => result.rows);\n      });\n    });\n  }\n  /** @internal */\n  isResponseInArrayMode() {\n    return this._isResponseInArrayMode;\n  }\n}\nclass NodePgSession extends PgSession {\n  constructor(client, dialect, schema, options = {}) {\n    super(dialect);\n    this.client = client;\n    this.schema = schema;\n    this.options = options;\n    this.logger = options.logger ?? new NoopLogger();\n    this.cache = options.cache ?? new NoopCache();\n  }\n  static [entityKind] = \"NodePgSession\";\n  logger;\n  cache;\n  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {\n    return new NodePgPreparedQuery(\n      this.client,\n      query.sql,\n      query.params,\n      this.logger,\n      this.cache,\n      queryMetadata,\n      cacheConfig,\n      fields,\n      name,\n      isResponseInArrayMode,\n      customResultMapper\n    );\n  }\n  async transaction(transaction, config) {\n    const session = this.client instanceof Pool ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;\n    const tx = new NodePgTransaction(this.dialect, session, this.schema);\n    await tx.execute(sql`begin${config ? sql` ${tx.getTransactionConfigSQL(config)}` : void 0}`);\n    try {\n      const result = await transaction(tx);\n      await tx.execute(sql`commit`);\n      return result;\n    } catch (error) {\n      await tx.execute(sql`rollback`);\n      throw error;\n    } finally {\n      if (this.client instanceof Pool) {\n        session.client.release();\n      }\n    }\n  }\n  async count(sql2) {\n    const res = await this.execute(sql2);\n    return Number(\n      res[\"rows\"][0][\"count\"]\n    );\n  }\n}\nclass NodePgTransaction extends PgTransaction {\n  static [entityKind] = \"NodePgTransaction\";\n  async transaction(transaction) {\n    const savepointName = `sp${this.nestedIndex + 1}`;\n    const tx = new NodePgTransaction(\n      this.dialect,\n      this.session,\n      this.schema,\n      this.nestedIndex + 1\n    );\n    await tx.execute(sql.raw(`savepoint ${savepointName}`));\n    try {\n      const result = await transaction(tx);\n      await tx.execute(sql.raw(`release savepoint ${savepointName}`));\n      return result;\n    } catch (err) {\n      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));\n      throw err;\n    }\n  }\n}\nexport {\n  NodePgPreparedQuery,\n  NodePgSession,\n  NodePgTransaction\n};\n//# sourceMappingURL=session.js.map",
    "import { drizzle, type NodePgDatabase } from 'drizzle-orm/node-postgres';\nimport { Pool, type PoolClient } from 'pg';\nimport { logger } from '@elizaos/core';\n\nexport class PostgresConnectionManager {\n  private pool: Pool;\n  private db: NodePgDatabase;\n\n  constructor(connectionString: string) {\n    this.pool = new Pool({ connectionString });\n    this.db = drizzle(this.pool as any);\n  }\n\n  public getDatabase(): NodePgDatabase {\n    return this.db;\n  }\n\n  public getConnection(): Pool {\n    return this.pool;\n  }\n\n  public async getClient(): Promise<PoolClient> {\n    return this.pool.connect();\n  }\n\n  public async testConnection(): Promise<boolean> {\n    let client: PoolClient | null = null;\n    try {\n      client = await this.pool.connect();\n      await client.query('SELECT 1');\n      return true;\n    } catch (error) {\n      logger.error(\n        `Failed to connect to the database: ${error instanceof Error ? error.message : String(error)}`\n      );\n      return false;\n    } finally {\n      if (client) {\n        client.release();\n      }\n    }\n  }\n\n  /**\n   * Closes the connection pool.\n   * @returns {Promise<void>}\n   * @memberof PostgresConnectionManager\n   */\n  public async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n",
    "import dotenv from 'dotenv';\nimport { existsSync } from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Node-specific utils split out for server builds.\n */\n\nexport function expandTildePath(filepath: string): string {\n  if (filepath && filepath.startsWith('~')) {\n    return path.join(process.cwd(), filepath.slice(1));\n  }\n  return filepath;\n}\n\nexport function resolveEnvFile(startDir: string = process.cwd()): string {\n  let currentDir = startDir;\n\n  while (true) {\n    const candidate = path.join(currentDir, '.env');\n    if (existsSync(candidate)) {\n      return candidate;\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  return path.join(startDir, '.env');\n}\n\nexport function resolvePgliteDir(dir?: string, fallbackDir?: string): string {\n  const envPath = resolveEnvFile();\n  if (existsSync(envPath)) {\n    dotenv.config({ path: envPath });\n  }\n\n  let monoPath;\n  if (existsSync(path.join(process.cwd(), 'packages', 'core'))) {\n    monoPath = process.cwd();\n  } else {\n    const twoUp = path.resolve(process.cwd(), '../..');\n    if (existsSync(path.join(twoUp, 'packages', 'core'))) {\n      monoPath = twoUp;\n    }\n  }\n\n  const base =\n    dir ??\n    process.env.PGLITE_DATA_DIR ??\n    fallbackDir ??\n    (monoPath ? path.join(monoPath, '.eliza', '.elizadb') : undefined) ??\n    path.join(process.cwd(), '.eliza', '.elizadb');\n\n  const resolved = expandTildePath(base);\n  const legacyPath = path.join(process.cwd(), '.elizadb');\n  if (resolved === legacyPath) {\n    const newPath = path.join(process.cwd(), '.eliza', '.elizadb');\n    process.env.PGLITE_DATA_DIR = newPath;\n    return newPath;\n  }\n\n  return resolved;\n}\n"
  ],
  "mappings": "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",
  "debugId": "F87541CC826D31E064756E2164756E21",
  "names": []
}