var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// ../../node_modules/drizzle-orm/entity.js
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
var entityKind, hasOwnEntityKind;
var init_entity = __esm(() => {
  entityKind = Symbol.for("drizzle:entityKind");
  hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
});

// ../../node_modules/drizzle-orm/logger.js
var ConsoleLogWriter, DefaultLogger, NoopLogger;
var init_logger = __esm(() => {
  init_entity();
  ConsoleLogWriter = class ConsoleLogWriter {
    static [entityKind] = "ConsoleLogWriter";
    write(message) {
      console.log(message);
    }
  };
  DefaultLogger = class DefaultLogger {
    static [entityKind] = "DefaultLogger";
    writer;
    constructor(config) {
      this.writer = config?.writer ?? new ConsoleLogWriter;
    }
    logQuery(query, params) {
      const stringifiedParams = params.map((p) => {
        try {
          return JSON.stringify(p);
        } catch {
          return String(p);
        }
      });
      const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
      this.writer.write(`Query: ${query}${paramsStr}`);
    }
  };
  NoopLogger = class NoopLogger {
    static [entityKind] = "NoopLogger";
    logQuery() {}
  };
});

// ../../node_modules/drizzle-orm/query-promise.js
var QueryPromise;
var init_query_promise = __esm(() => {
  init_entity();
  QueryPromise = class QueryPromise {
    static [entityKind] = "QueryPromise";
    [Symbol.toStringTag] = "QueryPromise";
    catch(onRejected) {
      return this.then(undefined, onRejected);
    }
    finally(onFinally) {
      return this.then((value) => {
        onFinally?.();
        return value;
      }, (reason) => {
        onFinally?.();
        throw reason;
      });
    }
    then(onFulfilled, onRejected) {
      return this.execute().then(onFulfilled, onRejected);
    }
  };
});

// ../../node_modules/drizzle-orm/column.js
var Column;
var init_column = __esm(() => {
  init_entity();
  Column = class Column {
    constructor(table, config) {
      this.table = table;
      this.config = config;
      this.name = config.name;
      this.keyAsName = config.keyAsName;
      this.notNull = config.notNull;
      this.default = config.default;
      this.defaultFn = config.defaultFn;
      this.onUpdateFn = config.onUpdateFn;
      this.hasDefault = config.hasDefault;
      this.primary = config.primaryKey;
      this.isUnique = config.isUnique;
      this.uniqueName = config.uniqueName;
      this.uniqueType = config.uniqueType;
      this.dataType = config.dataType;
      this.columnType = config.columnType;
      this.generated = config.generated;
      this.generatedIdentity = config.generatedIdentity;
    }
    static [entityKind] = "Column";
    name;
    keyAsName;
    primary;
    notNull;
    default;
    defaultFn;
    onUpdateFn;
    hasDefault;
    isUnique;
    uniqueName;
    uniqueType;
    dataType;
    columnType;
    enumValues = undefined;
    generated = undefined;
    generatedIdentity = undefined;
    config;
    mapFromDriverValue(value) {
      return value;
    }
    mapToDriverValue(value) {
      return value;
    }
    shouldDisableInsert() {
      return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
    }
  };
});

// ../../node_modules/drizzle-orm/column-builder.js
var ColumnBuilder;
var init_column_builder = __esm(() => {
  init_entity();
  ColumnBuilder = class ColumnBuilder {
    static [entityKind] = "ColumnBuilder";
    config;
    constructor(name, dataType, columnType) {
      this.config = {
        name,
        keyAsName: name === "",
        notNull: false,
        default: undefined,
        hasDefault: false,
        primaryKey: false,
        isUnique: false,
        uniqueName: undefined,
        uniqueType: undefined,
        dataType,
        columnType,
        generated: undefined
      };
    }
    $type() {
      return this;
    }
    notNull() {
      this.config.notNull = true;
      return this;
    }
    default(value) {
      this.config.default = value;
      this.config.hasDefault = true;
      return this;
    }
    $defaultFn(fn) {
      this.config.defaultFn = fn;
      this.config.hasDefault = true;
      return this;
    }
    $default = this.$defaultFn;
    $onUpdateFn(fn) {
      this.config.onUpdateFn = fn;
      this.config.hasDefault = true;
      return this;
    }
    $onUpdate = this.$onUpdateFn;
    primaryKey() {
      this.config.primaryKey = true;
      this.config.notNull = true;
      return this;
    }
    setName(name) {
      if (this.config.name !== "")
        return;
      this.config.name = name;
    }
  };
});

// ../../node_modules/drizzle-orm/table.utils.js
var TableName;
var init_table_utils = __esm(() => {
  TableName = Symbol.for("drizzle:Name");
});

// ../../node_modules/drizzle-orm/pg-core/foreign-keys.js
function foreignKey(config) {
  function mappedConfig() {
    const { name, columns, foreignColumns } = config;
    return {
      name,
      columns,
      foreignColumns
    };
  }
  return new ForeignKeyBuilder(mappedConfig);
}
var ForeignKeyBuilder, ForeignKey;
var init_foreign_keys = __esm(() => {
  init_entity();
  init_table_utils();
  ForeignKeyBuilder = class ForeignKeyBuilder {
    static [entityKind] = "PgForeignKeyBuilder";
    reference;
    _onUpdate = "no action";
    _onDelete = "no action";
    constructor(config, actions) {
      this.reference = () => {
        const { name, columns, foreignColumns } = config();
        return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
      };
      if (actions) {
        this._onUpdate = actions.onUpdate;
        this._onDelete = actions.onDelete;
      }
    }
    onUpdate(action) {
      this._onUpdate = action === undefined ? "no action" : action;
      return this;
    }
    onDelete(action) {
      this._onDelete = action === undefined ? "no action" : action;
      return this;
    }
    build(table) {
      return new ForeignKey(table, this);
    }
  };
  ForeignKey = class ForeignKey {
    constructor(table, builder) {
      this.table = table;
      this.reference = builder.reference;
      this.onUpdate = builder._onUpdate;
      this.onDelete = builder._onDelete;
    }
    static [entityKind] = "PgForeignKey";
    reference;
    onUpdate;
    onDelete;
    getName() {
      const { name, columns, foreignColumns } = this.reference();
      const columnNames = columns.map((column) => column.name);
      const foreignColumnNames = foreignColumns.map((column) => column.name);
      const chunks = [
        this.table[TableName],
        ...columnNames,
        foreignColumns[0].table[TableName],
        ...foreignColumnNames
      ];
      return name ?? `${chunks.join("_")}_fk`;
    }
  };
});

// ../../node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}
var init_tracing_utils = () => {};

// ../../node_modules/drizzle-orm/pg-core/unique-constraint.js
function unique(name) {
  return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder, UniqueOnConstraintBuilder, UniqueConstraint;
var init_unique_constraint = __esm(() => {
  init_entity();
  init_table_utils();
  UniqueConstraintBuilder = class UniqueConstraintBuilder {
    constructor(columns, name) {
      this.name = name;
      this.columns = columns;
    }
    static [entityKind] = "PgUniqueConstraintBuilder";
    columns;
    nullsNotDistinctConfig = false;
    nullsNotDistinct() {
      this.nullsNotDistinctConfig = true;
      return this;
    }
    build(table) {
      return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
    }
  };
  UniqueOnConstraintBuilder = class UniqueOnConstraintBuilder {
    static [entityKind] = "PgUniqueOnConstraintBuilder";
    name;
    constructor(name) {
      this.name = name;
    }
    on(...columns) {
      return new UniqueConstraintBuilder(columns, this.name);
    }
  };
  UniqueConstraint = class UniqueConstraint {
    constructor(table, columns, nullsNotDistinct, name) {
      this.table = table;
      this.columns = columns;
      this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
      this.nullsNotDistinct = nullsNotDistinct;
    }
    static [entityKind] = "PgUniqueConstraint";
    columns;
    name;
    nullsNotDistinct = false;
    getName() {
      return this.name;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
var init_array = () => {};

// ../../node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder, PgColumn, ExtraConfigColumn, IndexedColumn, PgArrayBuilder, PgArray;
var init_common = __esm(() => {
  init_column_builder();
  init_column();
  init_entity();
  init_foreign_keys();
  init_tracing_utils();
  init_unique_constraint();
  init_array();
  PgColumnBuilder = class PgColumnBuilder extends ColumnBuilder {
    foreignKeyConfigs = [];
    static [entityKind] = "PgColumnBuilder";
    array(size) {
      return new PgArrayBuilder(this.config.name, this, size);
    }
    references(ref, actions = {}) {
      this.foreignKeyConfigs.push({ ref, actions });
      return this;
    }
    unique(name, config) {
      this.config.isUnique = true;
      this.config.uniqueName = name;
      this.config.uniqueType = config?.nulls;
      return this;
    }
    generatedAlwaysAs(as) {
      this.config.generated = {
        as,
        type: "always",
        mode: "stored"
      };
      return this;
    }
    buildForeignKeys(column, table) {
      return this.foreignKeyConfigs.map(({ ref, actions }) => {
        return iife((ref2, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref2();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table);
        }, ref, actions);
      });
    }
    buildExtraConfigColumn(table) {
      return new ExtraConfigColumn(table, this.config);
    }
  };
  PgColumn = class PgColumn extends Column {
    constructor(table, config) {
      if (!config.uniqueName) {
        config.uniqueName = uniqueKeyName(table, [config.name]);
      }
      super(table, config);
      this.table = table;
    }
    static [entityKind] = "PgColumn";
  };
  ExtraConfigColumn = class ExtraConfigColumn extends PgColumn {
    static [entityKind] = "ExtraConfigColumn";
    getSQLType() {
      return this.getSQLType();
    }
    indexConfig = {
      order: this.config.order ?? "asc",
      nulls: this.config.nulls ?? "last",
      opClass: this.config.opClass
    };
    defaultConfig = {
      order: "asc",
      nulls: "last",
      opClass: undefined
    };
    asc() {
      this.indexConfig.order = "asc";
      return this;
    }
    desc() {
      this.indexConfig.order = "desc";
      return this;
    }
    nullsFirst() {
      this.indexConfig.nulls = "first";
      return this;
    }
    nullsLast() {
      this.indexConfig.nulls = "last";
      return this;
    }
    op(opClass) {
      this.indexConfig.opClass = opClass;
      return this;
    }
  };
  IndexedColumn = class IndexedColumn {
    static [entityKind] = "IndexedColumn";
    constructor(name, keyAsName, type, indexConfig) {
      this.name = name;
      this.keyAsName = keyAsName;
      this.type = type;
      this.indexConfig = indexConfig;
    }
    name;
    keyAsName;
    type;
    indexConfig;
  };
  PgArrayBuilder = class PgArrayBuilder extends PgColumnBuilder {
    static [entityKind] = "PgArrayBuilder";
    constructor(name, baseBuilder, size) {
      super(name, "array", "PgArray");
      this.config.baseBuilder = baseBuilder;
      this.config.size = size;
    }
    build(table) {
      const baseColumn = this.config.baseBuilder.build(table);
      return new PgArray(table, this.config, baseColumn);
    }
  };
  PgArray = class PgArray extends PgColumn {
    constructor(table, config, baseColumn, range) {
      super(table, config);
      this.baseColumn = baseColumn;
      this.range = range;
      this.size = config.size;
    }
    size;
    static [entityKind] = "PgArray";
    getSQLType() {
      return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        value = parsePgArray(value);
      }
      return value.map((v) => this.baseColumn.mapFromDriverValue(v));
    }
    mapToDriverValue(value, isNestedArray = false) {
      const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
      if (isNestedArray)
        return a;
      return makePgArray(a);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/enum.js
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
var PgEnumObjectColumn, isPgEnumSym, PgEnumColumn;
var init_enum = __esm(() => {
  init_entity();
  init_common();
  PgEnumObjectColumn = class PgEnumObjectColumn extends PgColumn {
    static [entityKind] = "PgEnumObjectColumn";
    enum;
    enumValues = this.config.enum.enumValues;
    constructor(table, config) {
      super(table, config);
      this.enum = config.enum;
    }
    getSQLType() {
      return this.enum.enumName;
    }
  };
  isPgEnumSym = Symbol.for("drizzle:isPgEnum");
  PgEnumColumn = class PgEnumColumn extends PgColumn {
    static [entityKind] = "PgEnumColumn";
    enum = this.config.enum;
    enumValues = this.config.enum.enumValues;
    constructor(table, config) {
      super(table, config);
      this.enum = config.enum;
    }
    getSQLType() {
      return this.enum.enumName;
    }
  };
});

// ../../node_modules/drizzle-orm/subquery.js
var Subquery, WithSubquery;
var init_subquery = __esm(() => {
  init_entity();
  Subquery = class Subquery {
    static [entityKind] = "Subquery";
    constructor(sql, fields, alias, isWith = false, usedTables = []) {
      this._ = {
        brand: "Subquery",
        sql,
        selectedFields: fields,
        alias,
        isWith,
        usedTables
      };
    }
  };
  WithSubquery = class WithSubquery extends Subquery {
    static [entityKind] = "WithSubquery";
  };
});

// ../../node_modules/drizzle-orm/version.js
var version = "0.44.5";
var init_version = () => {};

// ../../node_modules/drizzle-orm/tracing.js
var otel, rawTracer, tracer;
var init_tracing = __esm(() => {
  init_tracing_utils();
  init_version();
  tracer = {
    startActiveSpan(name, fn) {
      if (!otel) {
        return fn();
      }
      if (!rawTracer) {
        rawTracer = otel.trace.getTracer("drizzle-orm", version);
      }
      return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
        try {
          return fn(span);
        } catch (e) {
          span.setStatus({
            code: otel2.SpanStatusCode.ERROR,
            message: e instanceof Error ? e.message : "Unknown error"
          });
          throw e;
        } finally {
          span.end();
        }
      }), otel, rawTracer);
    }
  };
});

// ../../node_modules/drizzle-orm/view-common.js
var ViewBaseConfig;
var init_view_common = __esm(() => {
  ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
});

// ../../node_modules/drizzle-orm/table.js
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}
var Schema, Columns, ExtraConfigColumns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, Table;
var init_table = __esm(() => {
  init_entity();
  init_table_utils();
  Schema = Symbol.for("drizzle:Schema");
  Columns = Symbol.for("drizzle:Columns");
  ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
  OriginalName = Symbol.for("drizzle:OriginalName");
  BaseName = Symbol.for("drizzle:BaseName");
  IsAlias = Symbol.for("drizzle:IsAlias");
  ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
  IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
  Table = class Table {
    static [entityKind] = "Table";
    static Symbol = {
      Name: TableName,
      Schema,
      OriginalName,
      Columns,
      ExtraConfigColumns,
      BaseName,
      IsAlias,
      ExtraConfigBuilder
    };
    [TableName];
    [OriginalName];
    [Schema];
    [Columns];
    [ExtraConfigColumns];
    [BaseName];
    [IsAlias] = false;
    [IsDrizzleTable] = true;
    [ExtraConfigBuilder] = undefined;
    constructor(name, schema, baseName) {
      this[TableName] = this[OriginalName] = name;
      this[Schema] = schema;
      this[BaseName] = baseName;
    }
  };
});

// ../../node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var StringChunk, SQL, Name, noopDecoder, noopEncoder, noopMapper, Param, Placeholder, IsDrizzleView, View;
var init_sql = __esm(() => {
  init_entity();
  init_enum();
  init_subquery();
  init_tracing();
  init_view_common();
  init_column();
  init_table();
  StringChunk = class StringChunk {
    static [entityKind] = "StringChunk";
    value;
    constructor(value) {
      this.value = Array.isArray(value) ? value : [value];
    }
    getSQL() {
      return new SQL([this]);
    }
  };
  SQL = class SQL {
    constructor(queryChunks) {
      this.queryChunks = queryChunks;
      for (const chunk of queryChunks) {
        if (is(chunk, Table)) {
          const schemaName = chunk[Table.Symbol.Schema];
          this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
        }
      }
    }
    static [entityKind] = "SQL";
    decoder = noopDecoder;
    shouldInlineParams = false;
    usedTables = [];
    append(query) {
      this.queryChunks.push(...query.queryChunks);
      return this;
    }
    toQuery(config) {
      return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
        const query = this.buildQueryFromSourceParams(this.queryChunks, config);
        span?.setAttributes({
          "drizzle.query.text": query.sql,
          "drizzle.query.params": JSON.stringify(query.params)
        });
        return query;
      });
    }
    buildQueryFromSourceParams(chunks, _config) {
      const config = Object.assign({}, _config, {
        inlineParams: _config.inlineParams || this.shouldInlineParams,
        paramStartIndex: _config.paramStartIndex || { value: 0 }
      });
      const {
        casing,
        escapeName,
        escapeParam,
        prepareTyping,
        inlineParams,
        paramStartIndex
      } = config;
      return mergeQueries(chunks.map((chunk) => {
        if (is(chunk, StringChunk)) {
          return { sql: chunk.value.join(""), params: [] };
        }
        if (is(chunk, Name)) {
          return { sql: escapeName(chunk.value), params: [] };
        }
        if (chunk === undefined) {
          return { sql: "", params: [] };
        }
        if (Array.isArray(chunk)) {
          const result = [new StringChunk("(")];
          for (const [i, p] of chunk.entries()) {
            result.push(p);
            if (i < chunk.length - 1) {
              result.push(new StringChunk(", "));
            }
          }
          result.push(new StringChunk(")"));
          return this.buildQueryFromSourceParams(result, config);
        }
        if (is(chunk, SQL)) {
          return this.buildQueryFromSourceParams(chunk.queryChunks, {
            ...config,
            inlineParams: inlineParams || chunk.shouldInlineParams
          });
        }
        if (is(chunk, Table)) {
          const schemaName = chunk[Table.Symbol.Schema];
          const tableName = chunk[Table.Symbol.Name];
          return {
            sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
            params: []
          };
        }
        if (is(chunk, Column)) {
          const columnName = casing.getColumnCasing(chunk);
          if (_config.invokeSource === "indexes") {
            return { sql: escapeName(columnName), params: [] };
          }
          const schemaName = chunk.table[Table.Symbol.Schema];
          return {
            sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
            params: []
          };
        }
        if (is(chunk, View)) {
          const schemaName = chunk[ViewBaseConfig].schema;
          const viewName = chunk[ViewBaseConfig].name;
          return {
            sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
            params: []
          };
        }
        if (is(chunk, Param)) {
          if (is(chunk.value, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
          if (is(mappedValue, SQL)) {
            return this.buildQueryFromSourceParams([mappedValue], config);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(mappedValue, config), params: [] };
          }
          let typings = ["none"];
          if (prepareTyping) {
            typings = [prepareTyping(chunk.encoder)];
          }
          return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
        }
        if (is(chunk, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
          return { sql: escapeName(chunk.fieldAlias), params: [] };
        }
        if (is(chunk, Subquery)) {
          if (chunk._.isWith) {
            return { sql: escapeName(chunk._.alias), params: [] };
          }
          return this.buildQueryFromSourceParams([
            new StringChunk("("),
            chunk._.sql,
            new StringChunk(") "),
            new Name(chunk._.alias)
          ], config);
        }
        if (isPgEnum(chunk)) {
          if (chunk.schema) {
            return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
          }
          return { sql: escapeName(chunk.enumName), params: [] };
        }
        if (isSQLWrapper(chunk)) {
          if (chunk.shouldOmitSQLParens?.()) {
            return this.buildQueryFromSourceParams([chunk.getSQL()], config);
          }
          return this.buildQueryFromSourceParams([
            new StringChunk("("),
            chunk.getSQL(),
            new StringChunk(")")
          ], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(chunk, config), params: [] };
        }
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }));
    }
    mapInlineParam(chunk, { escapeString }) {
      if (chunk === null) {
        return "null";
      }
      if (typeof chunk === "number" || typeof chunk === "boolean") {
        return chunk.toString();
      }
      if (typeof chunk === "string") {
        return escapeString(chunk);
      }
      if (typeof chunk === "object") {
        const mappedValueAsString = chunk.toString();
        if (mappedValueAsString === "[object Object]") {
          return escapeString(JSON.stringify(chunk));
        }
        return escapeString(mappedValueAsString);
      }
      throw new Error("Unexpected param value: " + chunk);
    }
    getSQL() {
      return this;
    }
    as(alias) {
      if (alias === undefined) {
        return this;
      }
      return new SQL.Aliased(this, alias);
    }
    mapWith(decoder) {
      this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
      return this;
    }
    inlineParams() {
      this.shouldInlineParams = true;
      return this;
    }
    if(condition) {
      return condition ? this : undefined;
    }
  };
  Name = class Name {
    constructor(value) {
      this.value = value;
    }
    static [entityKind] = "Name";
    brand;
    getSQL() {
      return new SQL([this]);
    }
  };
  noopDecoder = {
    mapFromDriverValue: (value) => value
  };
  noopEncoder = {
    mapToDriverValue: (value) => value
  };
  noopMapper = {
    ...noopDecoder,
    ...noopEncoder
  };
  Param = class Param {
    constructor(value, encoder = noopEncoder) {
      this.value = value;
      this.encoder = encoder;
    }
    static [entityKind] = "Param";
    brand;
    getSQL() {
      return new SQL([this]);
    }
  };
  ((sql2) => {
    function empty() {
      return new SQL([]);
    }
    sql2.empty = empty;
    function fromList(list) {
      return new SQL(list);
    }
    sql2.fromList = fromList;
    function raw(str) {
      return new SQL([new StringChunk(str)]);
    }
    sql2.raw = raw;
    function join(chunks, separator) {
      const result = [];
      for (const [i, chunk] of chunks.entries()) {
        if (i > 0 && separator !== undefined) {
          result.push(separator);
        }
        result.push(chunk);
      }
      return new SQL(result);
    }
    sql2.join = join;
    function identifier(value) {
      return new Name(value);
    }
    sql2.identifier = identifier;
    function placeholder2(name2) {
      return new Placeholder(name2);
    }
    sql2.placeholder = placeholder2;
    function param2(value, encoder) {
      return new Param(value, encoder);
    }
    sql2.param = param2;
  })(sql || (sql = {}));
  ((SQL2) => {

    class Aliased {
      constructor(sql2, fieldAlias) {
        this.sql = sql2;
        this.fieldAlias = fieldAlias;
      }
      static [entityKind] = "SQL.Aliased";
      isSelectionField = false;
      getSQL() {
        return this.sql;
      }
      clone() {
        return new Aliased(this.sql, this.fieldAlias);
      }
    }
    SQL2.Aliased = Aliased;
  })(SQL || (SQL = {}));
  Placeholder = class Placeholder {
    constructor(name2) {
      this.name = name2;
    }
    static [entityKind] = "Placeholder";
    getSQL() {
      return new SQL([this]);
    }
  };
  IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");
  View = class View {
    static [entityKind] = "View";
    [ViewBaseConfig];
    [IsDrizzleView] = true;
    constructor({ name: name2, schema, selectedFields, query }) {
      this[ViewBaseConfig] = {
        name: name2,
        originalName: name2,
        schema,
        selectedFields,
        query,
        isExisting: !query,
        isAlias: false
      };
    }
    getSQL() {
      return new SQL([this]);
    }
  };
  Column.prototype.getSQL = function() {
    return new SQL([this]);
  };
  Table.prototype.getSQL = function() {
    return new SQL([this]);
  };
  Subquery.prototype.getSQL = function() {
    return new SQL([this]);
  };
});

// ../../node_modules/drizzle-orm/alias.js
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}
var ColumnAliasProxyHandler, TableAliasProxyHandler;
var init_alias = __esm(() => {
  init_column();
  init_entity();
  init_sql();
  init_table();
  init_view_common();
  ColumnAliasProxyHandler = class ColumnAliasProxyHandler {
    constructor(table) {
      this.table = table;
    }
    static [entityKind] = "ColumnAliasProxyHandler";
    get(columnObj, prop) {
      if (prop === "table") {
        return this.table;
      }
      return columnObj[prop];
    }
  };
  TableAliasProxyHandler = class TableAliasProxyHandler {
    constructor(alias, replaceOriginalName) {
      this.alias = alias;
      this.replaceOriginalName = replaceOriginalName;
    }
    static [entityKind] = "TableAliasProxyHandler";
    get(target, prop) {
      if (prop === Table.Symbol.IsAlias) {
        return true;
      }
      if (prop === Table.Symbol.Name) {
        return this.alias;
      }
      if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
        return this.alias;
      }
      if (prop === ViewBaseConfig) {
        return {
          ...target[ViewBaseConfig],
          name: this.alias,
          isAlias: true
        };
      }
      if (prop === Table.Symbol.Columns) {
        const columns = target[Table.Symbol.Columns];
        if (!columns) {
          return columns;
        }
        const proxiedColumns = {};
        Object.keys(columns).map((key) => {
          proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
        });
        return proxiedColumns;
      }
      const value = target[prop];
      if (is(value, Column)) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
      }
      return value;
    }
  };
});

// ../../node_modules/drizzle-orm/selection-proxy.js
var SelectionProxyHandler;
var init_selection_proxy = __esm(() => {
  init_alias();
  init_column();
  init_entity();
  init_sql();
  init_subquery();
  init_view_common();
  SelectionProxyHandler = class SelectionProxyHandler {
    static [entityKind] = "SelectionProxyHandler";
    config;
    constructor(config) {
      this.config = { ...config };
    }
    get(subquery, prop) {
      if (prop === "_") {
        return {
          ...subquery["_"],
          selectedFields: new Proxy(subquery._.selectedFields, this)
        };
      }
      if (prop === ViewBaseConfig) {
        return {
          ...subquery[ViewBaseConfig],
          selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
        };
      }
      if (typeof prop === "symbol") {
        return subquery[prop];
      }
      const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
      const value = columns[prop];
      if (is(value, SQL.Aliased)) {
        if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
          return value.sql;
        }
        const newValue = value.clone();
        newValue.isSelectionField = true;
        return newValue;
      }
      if (is(value, SQL)) {
        if (this.config.sqlBehavior === "sql") {
          return value;
        }
        throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
      }
      if (is(value, Column)) {
        if (this.config.alias) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
        }
        return value;
      }
      if (typeof value !== "object" || value === null) {
        return value;
      }
      return new Proxy(value, new SelectionProxyHandler(this.config));
    }
  };
});

// ../../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}
var textDecoder;
var init_utils = __esm(() => {
  init_column();
  init_entity();
  init_sql();
  init_subquery();
  init_table();
  init_view_common();
  textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder;
});

// ../../node_modules/drizzle-orm/pg-core/columns/int.common.js
var PgIntColumnBaseBuilder;
var init_int_common = __esm(() => {
  init_entity();
  init_common();
  PgIntColumnBaseBuilder = class PgIntColumnBaseBuilder extends PgColumnBuilder {
    static [entityKind] = "PgIntColumnBaseBuilder";
    generatedAlwaysAsIdentity(sequence) {
      if (sequence) {
        const { name, ...options } = sequence;
        this.config.generatedIdentity = {
          type: "always",
          sequenceName: name,
          sequenceOptions: options
        };
      } else {
        this.config.generatedIdentity = {
          type: "always"
        };
      }
      this.config.hasDefault = true;
      this.config.notNull = true;
      return this;
    }
    generatedByDefaultAsIdentity(sequence) {
      if (sequence) {
        const { name, ...options } = sequence;
        this.config.generatedIdentity = {
          type: "byDefault",
          sequenceName: name,
          sequenceOptions: options
        };
      } else {
        this.config.generatedIdentity = {
          type: "byDefault"
        };
      }
      this.config.hasDefault = true;
      this.config.notNull = true;
      return this;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/bigint.js
function bigint(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}
var PgBigInt53Builder, PgBigInt53, PgBigInt64Builder, PgBigInt64;
var init_bigint = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  init_int_common();
  PgBigInt53Builder = class PgBigInt53Builder extends PgIntColumnBaseBuilder {
    static [entityKind] = "PgBigInt53Builder";
    constructor(name) {
      super(name, "number", "PgBigInt53");
    }
    build(table) {
      return new PgBigInt53(table, this.config);
    }
  };
  PgBigInt53 = class PgBigInt53 extends PgColumn {
    static [entityKind] = "PgBigInt53";
    getSQLType() {
      return "bigint";
    }
    mapFromDriverValue(value) {
      if (typeof value === "number") {
        return value;
      }
      return Number(value);
    }
  };
  PgBigInt64Builder = class PgBigInt64Builder extends PgIntColumnBaseBuilder {
    static [entityKind] = "PgBigInt64Builder";
    constructor(name) {
      super(name, "bigint", "PgBigInt64");
    }
    build(table) {
      return new PgBigInt64(table, this.config);
    }
  };
  PgBigInt64 = class PgBigInt64 extends PgColumn {
    static [entityKind] = "PgBigInt64";
    getSQLType() {
      return "bigint";
    }
    mapFromDriverValue(value) {
      return BigInt(value);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/bigserial.js
function bigserial(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}
var PgBigSerial53Builder, PgBigSerial53, PgBigSerial64Builder, PgBigSerial64;
var init_bigserial = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgBigSerial53Builder = class PgBigSerial53Builder extends PgColumnBuilder {
    static [entityKind] = "PgBigSerial53Builder";
    constructor(name) {
      super(name, "number", "PgBigSerial53");
      this.config.hasDefault = true;
      this.config.notNull = true;
    }
    build(table) {
      return new PgBigSerial53(table, this.config);
    }
  };
  PgBigSerial53 = class PgBigSerial53 extends PgColumn {
    static [entityKind] = "PgBigSerial53";
    getSQLType() {
      return "bigserial";
    }
    mapFromDriverValue(value) {
      if (typeof value === "number") {
        return value;
      }
      return Number(value);
    }
  };
  PgBigSerial64Builder = class PgBigSerial64Builder extends PgColumnBuilder {
    static [entityKind] = "PgBigSerial64Builder";
    constructor(name) {
      super(name, "bigint", "PgBigSerial64");
      this.config.hasDefault = true;
    }
    build(table) {
      return new PgBigSerial64(table, this.config);
    }
  };
  PgBigSerial64 = class PgBigSerial64 extends PgColumn {
    static [entityKind] = "PgBigSerial64";
    getSQLType() {
      return "bigserial";
    }
    mapFromDriverValue(value) {
      return BigInt(value);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/boolean.js
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}
var PgBooleanBuilder, PgBoolean;
var init_boolean = __esm(() => {
  init_entity();
  init_common();
  PgBooleanBuilder = class PgBooleanBuilder extends PgColumnBuilder {
    static [entityKind] = "PgBooleanBuilder";
    constructor(name) {
      super(name, "boolean", "PgBoolean");
    }
    build(table) {
      return new PgBoolean(table, this.config);
    }
  };
  PgBoolean = class PgBoolean extends PgColumn {
    static [entityKind] = "PgBoolean";
    getSQLType() {
      return "boolean";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/char.js
function char(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name, config);
}
var PgCharBuilder, PgChar;
var init_char = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgCharBuilder = class PgCharBuilder extends PgColumnBuilder {
    static [entityKind] = "PgCharBuilder";
    constructor(name, config) {
      super(name, "string", "PgChar");
      this.config.length = config.length;
      this.config.enumValues = config.enum;
    }
    build(table) {
      return new PgChar(table, this.config);
    }
  };
  PgChar = class PgChar extends PgColumn {
    static [entityKind] = "PgChar";
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
      return this.length === undefined ? `char` : `char(${this.length})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/cidr.js
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}
var PgCidrBuilder, PgCidr;
var init_cidr = __esm(() => {
  init_entity();
  init_common();
  PgCidrBuilder = class PgCidrBuilder extends PgColumnBuilder {
    static [entityKind] = "PgCidrBuilder";
    constructor(name) {
      super(name, "string", "PgCidr");
    }
    build(table) {
      return new PgCidr(table, this.config);
    }
  };
  PgCidr = class PgCidr extends PgColumn {
    static [entityKind] = "PgCidr";
    getSQLType() {
      return "cidr";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/custom.js
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}
var PgCustomColumnBuilder, PgCustomColumn;
var init_custom = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgCustomColumnBuilder = class PgCustomColumnBuilder extends PgColumnBuilder {
    static [entityKind] = "PgCustomColumnBuilder";
    constructor(name, fieldConfig, customTypeParams) {
      super(name, "custom", "PgCustomColumn");
      this.config.fieldConfig = fieldConfig;
      this.config.customTypeParams = customTypeParams;
    }
    build(table) {
      return new PgCustomColumn(table, this.config);
    }
  };
  PgCustomColumn = class PgCustomColumn extends PgColumn {
    static [entityKind] = "PgCustomColumn";
    sqlName;
    mapTo;
    mapFrom;
    constructor(table, config) {
      super(table, config);
      this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
      this.mapTo = config.customTypeParams.toDriver;
      this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
      return this.sqlName;
    }
    mapFromDriverValue(value) {
      return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
      return typeof this.mapTo === "function" ? this.mapTo(value) : value;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/date.common.js
var PgDateColumnBaseBuilder;
var init_date_common = __esm(() => {
  init_entity();
  init_sql();
  init_common();
  PgDateColumnBaseBuilder = class PgDateColumnBaseBuilder extends PgColumnBuilder {
    static [entityKind] = "PgDateColumnBaseBuilder";
    defaultNow() {
      return this.default(sql`now()`);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/date.js
function date(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}
var PgDateBuilder, PgDate, PgDateStringBuilder, PgDateString;
var init_date = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  init_date_common();
  PgDateBuilder = class PgDateBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = "PgDateBuilder";
    constructor(name) {
      super(name, "date", "PgDate");
    }
    build(table) {
      return new PgDate(table, this.config);
    }
  };
  PgDate = class PgDate extends PgColumn {
    static [entityKind] = "PgDate";
    getSQLType() {
      return "date";
    }
    mapFromDriverValue(value) {
      return new Date(value);
    }
    mapToDriverValue(value) {
      return value.toISOString();
    }
  };
  PgDateStringBuilder = class PgDateStringBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = "PgDateStringBuilder";
    constructor(name) {
      super(name, "string", "PgDateString");
    }
    build(table) {
      return new PgDateString(table, this.config);
    }
  };
  PgDateString = class PgDateString extends PgColumn {
    static [entityKind] = "PgDateString";
    getSQLType() {
      return "date";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/double-precision.js
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}
var PgDoublePrecisionBuilder, PgDoublePrecision;
var init_double_precision = __esm(() => {
  init_entity();
  init_common();
  PgDoublePrecisionBuilder = class PgDoublePrecisionBuilder extends PgColumnBuilder {
    static [entityKind] = "PgDoublePrecisionBuilder";
    constructor(name) {
      super(name, "number", "PgDoublePrecision");
    }
    build(table) {
      return new PgDoublePrecision(table, this.config);
    }
  };
  PgDoublePrecision = class PgDoublePrecision extends PgColumn {
    static [entityKind] = "PgDoublePrecision";
    getSQLType() {
      return "double precision";
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        return Number.parseFloat(value);
      }
      return value;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/inet.js
function inet(name) {
  return new PgInetBuilder(name ?? "");
}
var PgInetBuilder, PgInet;
var init_inet = __esm(() => {
  init_entity();
  init_common();
  PgInetBuilder = class PgInetBuilder extends PgColumnBuilder {
    static [entityKind] = "PgInetBuilder";
    constructor(name) {
      super(name, "string", "PgInet");
    }
    build(table) {
      return new PgInet(table, this.config);
    }
  };
  PgInet = class PgInet extends PgColumn {
    static [entityKind] = "PgInet";
    getSQLType() {
      return "inet";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/integer.js
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}
var PgIntegerBuilder, PgInteger;
var init_integer = __esm(() => {
  init_entity();
  init_common();
  init_int_common();
  PgIntegerBuilder = class PgIntegerBuilder extends PgIntColumnBaseBuilder {
    static [entityKind] = "PgIntegerBuilder";
    constructor(name) {
      super(name, "number", "PgInteger");
    }
    build(table) {
      return new PgInteger(table, this.config);
    }
  };
  PgInteger = class PgInteger extends PgColumn {
    static [entityKind] = "PgInteger";
    getSQLType() {
      return "integer";
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        return Number.parseInt(value);
      }
      return value;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/interval.js
function interval(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name, config);
}
var PgIntervalBuilder, PgInterval;
var init_interval = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgIntervalBuilder = class PgIntervalBuilder extends PgColumnBuilder {
    static [entityKind] = "PgIntervalBuilder";
    constructor(name, intervalConfig) {
      super(name, "string", "PgInterval");
      this.config.intervalConfig = intervalConfig;
    }
    build(table) {
      return new PgInterval(table, this.config);
    }
  };
  PgInterval = class PgInterval extends PgColumn {
    static [entityKind] = "PgInterval";
    fields = this.config.intervalConfig.fields;
    precision = this.config.intervalConfig.precision;
    getSQLType() {
      const fields = this.fields ? ` ${this.fields}` : "";
      const precision = this.precision ? `(${this.precision})` : "";
      return `interval${fields}${precision}`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/json.js
function json(name) {
  return new PgJsonBuilder(name ?? "");
}
var PgJsonBuilder, PgJson;
var init_json = __esm(() => {
  init_entity();
  init_common();
  PgJsonBuilder = class PgJsonBuilder extends PgColumnBuilder {
    static [entityKind] = "PgJsonBuilder";
    constructor(name) {
      super(name, "json", "PgJson");
    }
    build(table) {
      return new PgJson(table, this.config);
    }
  };
  PgJson = class PgJson extends PgColumn {
    static [entityKind] = "PgJson";
    constructor(table, config) {
      super(table, config);
    }
    getSQLType() {
      return "json";
    }
    mapToDriverValue(value) {
      return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch {
          return value;
        }
      }
      return value;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/jsonb.js
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}
var PgJsonbBuilder, PgJsonb;
var init_jsonb = __esm(() => {
  init_entity();
  init_common();
  PgJsonbBuilder = class PgJsonbBuilder extends PgColumnBuilder {
    static [entityKind] = "PgJsonbBuilder";
    constructor(name) {
      super(name, "json", "PgJsonb");
    }
    build(table) {
      return new PgJsonb(table, this.config);
    }
  };
  PgJsonb = class PgJsonb extends PgColumn {
    static [entityKind] = "PgJsonb";
    constructor(table, config) {
      super(table, config);
    }
    getSQLType() {
      return "jsonb";
    }
    mapToDriverValue(value) {
      return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch {
          return value;
        }
      }
      return value;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/line.js
function line(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}
var PgLineBuilder, PgLineTuple, PgLineABCBuilder, PgLineABC;
var init_line = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgLineBuilder = class PgLineBuilder extends PgColumnBuilder {
    static [entityKind] = "PgLineBuilder";
    constructor(name) {
      super(name, "array", "PgLine");
    }
    build(table) {
      return new PgLineTuple(table, this.config);
    }
  };
  PgLineTuple = class PgLineTuple extends PgColumn {
    static [entityKind] = "PgLine";
    getSQLType() {
      return "line";
    }
    mapFromDriverValue(value) {
      const [a, b, c] = value.slice(1, -1).split(",");
      return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
    }
    mapToDriverValue(value) {
      return `{${value[0]},${value[1]},${value[2]}}`;
    }
  };
  PgLineABCBuilder = class PgLineABCBuilder extends PgColumnBuilder {
    static [entityKind] = "PgLineABCBuilder";
    constructor(name) {
      super(name, "json", "PgLineABC");
    }
    build(table) {
      return new PgLineABC(table, this.config);
    }
  };
  PgLineABC = class PgLineABC extends PgColumn {
    static [entityKind] = "PgLineABC";
    getSQLType() {
      return "line";
    }
    mapFromDriverValue(value) {
      const [a, b, c] = value.slice(1, -1).split(",");
      return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
    }
    mapToDriverValue(value) {
      return `{${value.a},${value.b},${value.c}}`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr.js
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}
var PgMacaddrBuilder, PgMacaddr;
var init_macaddr = __esm(() => {
  init_entity();
  init_common();
  PgMacaddrBuilder = class PgMacaddrBuilder extends PgColumnBuilder {
    static [entityKind] = "PgMacaddrBuilder";
    constructor(name) {
      super(name, "string", "PgMacaddr");
    }
    build(table) {
      return new PgMacaddr(table, this.config);
    }
  };
  PgMacaddr = class PgMacaddr extends PgColumn {
    static [entityKind] = "PgMacaddr";
    getSQLType() {
      return "macaddr";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr8.js
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}
var PgMacaddr8Builder, PgMacaddr8;
var init_macaddr8 = __esm(() => {
  init_entity();
  init_common();
  PgMacaddr8Builder = class PgMacaddr8Builder extends PgColumnBuilder {
    static [entityKind] = "PgMacaddr8Builder";
    constructor(name) {
      super(name, "string", "PgMacaddr8");
    }
    build(table) {
      return new PgMacaddr8(table, this.config);
    }
  };
  PgMacaddr8 = class PgMacaddr8 extends PgColumn {
    static [entityKind] = "PgMacaddr8";
    getSQLType() {
      return "macaddr8";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/numeric.js
function numeric(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}
var PgNumericBuilder, PgNumeric, PgNumericNumberBuilder, PgNumericNumber, PgNumericBigIntBuilder, PgNumericBigInt;
var init_numeric = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgNumericBuilder = class PgNumericBuilder extends PgColumnBuilder {
    static [entityKind] = "PgNumericBuilder";
    constructor(name, precision, scale) {
      super(name, "string", "PgNumeric");
      this.config.precision = precision;
      this.config.scale = scale;
    }
    build(table) {
      return new PgNumeric(table, this.config);
    }
  };
  PgNumeric = class PgNumeric extends PgColumn {
    static [entityKind] = "PgNumeric";
    precision;
    scale;
    constructor(table, config) {
      super(table, config);
      this.precision = config.precision;
      this.scale = config.scale;
    }
    mapFromDriverValue(value) {
      if (typeof value === "string")
        return value;
      return String(value);
    }
    getSQLType() {
      if (this.precision !== undefined && this.scale !== undefined) {
        return `numeric(${this.precision}, ${this.scale})`;
      } else if (this.precision === undefined) {
        return "numeric";
      } else {
        return `numeric(${this.precision})`;
      }
    }
  };
  PgNumericNumberBuilder = class PgNumericNumberBuilder extends PgColumnBuilder {
    static [entityKind] = "PgNumericNumberBuilder";
    constructor(name, precision, scale) {
      super(name, "number", "PgNumericNumber");
      this.config.precision = precision;
      this.config.scale = scale;
    }
    build(table) {
      return new PgNumericNumber(table, this.config);
    }
  };
  PgNumericNumber = class PgNumericNumber extends PgColumn {
    static [entityKind] = "PgNumericNumber";
    precision;
    scale;
    constructor(table, config) {
      super(table, config);
      this.precision = config.precision;
      this.scale = config.scale;
    }
    mapFromDriverValue(value) {
      if (typeof value === "number")
        return value;
      return Number(value);
    }
    mapToDriverValue = String;
    getSQLType() {
      if (this.precision !== undefined && this.scale !== undefined) {
        return `numeric(${this.precision}, ${this.scale})`;
      } else if (this.precision === undefined) {
        return "numeric";
      } else {
        return `numeric(${this.precision})`;
      }
    }
  };
  PgNumericBigIntBuilder = class PgNumericBigIntBuilder extends PgColumnBuilder {
    static [entityKind] = "PgNumericBigIntBuilder";
    constructor(name, precision, scale) {
      super(name, "bigint", "PgNumericBigInt");
      this.config.precision = precision;
      this.config.scale = scale;
    }
    build(table) {
      return new PgNumericBigInt(table, this.config);
    }
  };
  PgNumericBigInt = class PgNumericBigInt extends PgColumn {
    static [entityKind] = "PgNumericBigInt";
    precision;
    scale;
    constructor(table, config) {
      super(table, config);
      this.precision = config.precision;
      this.scale = config.scale;
    }
    mapFromDriverValue = BigInt;
    mapToDriverValue = String;
    getSQLType() {
      if (this.precision !== undefined && this.scale !== undefined) {
        return `numeric(${this.precision}, ${this.scale})`;
      } else if (this.precision === undefined) {
        return "numeric";
      } else {
        return `numeric(${this.precision})`;
      }
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/point.js
function point(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}
var PgPointTupleBuilder, PgPointTuple, PgPointObjectBuilder, PgPointObject;
var init_point = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgPointTupleBuilder = class PgPointTupleBuilder extends PgColumnBuilder {
    static [entityKind] = "PgPointTupleBuilder";
    constructor(name) {
      super(name, "array", "PgPointTuple");
    }
    build(table) {
      return new PgPointTuple(table, this.config);
    }
  };
  PgPointTuple = class PgPointTuple extends PgColumn {
    static [entityKind] = "PgPointTuple";
    getSQLType() {
      return "point";
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        const [x, y] = value.slice(1, -1).split(",");
        return [Number.parseFloat(x), Number.parseFloat(y)];
      }
      return [value.x, value.y];
    }
    mapToDriverValue(value) {
      return `(${value[0]},${value[1]})`;
    }
  };
  PgPointObjectBuilder = class PgPointObjectBuilder extends PgColumnBuilder {
    static [entityKind] = "PgPointObjectBuilder";
    constructor(name) {
      super(name, "json", "PgPointObject");
    }
    build(table) {
      return new PgPointObject(table, this.config);
    }
  };
  PgPointObject = class PgPointObject extends PgColumn {
    static [entityKind] = "PgPointObject";
    getSQLType() {
      return "point";
    }
    mapFromDriverValue(value) {
      if (typeof value === "string") {
        const [x, y] = value.slice(1, -1).split(",");
        return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
      }
      return value;
    }
    mapToDriverValue(value) {
      return `(${value.x},${value.y})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0;i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}
var init_utils2 = () => {};

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
function geometry(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}
var PgGeometryBuilder, PgGeometry, PgGeometryObjectBuilder, PgGeometryObject;
var init_geometry = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  init_utils2();
  PgGeometryBuilder = class PgGeometryBuilder extends PgColumnBuilder {
    static [entityKind] = "PgGeometryBuilder";
    constructor(name) {
      super(name, "array", "PgGeometry");
    }
    build(table) {
      return new PgGeometry(table, this.config);
    }
  };
  PgGeometry = class PgGeometry extends PgColumn {
    static [entityKind] = "PgGeometry";
    getSQLType() {
      return "geometry(point)";
    }
    mapFromDriverValue(value) {
      return parseEWKB(value);
    }
    mapToDriverValue(value) {
      return `point(${value[0]} ${value[1]})`;
    }
  };
  PgGeometryObjectBuilder = class PgGeometryObjectBuilder extends PgColumnBuilder {
    static [entityKind] = "PgGeometryObjectBuilder";
    constructor(name) {
      super(name, "json", "PgGeometryObject");
    }
    build(table) {
      return new PgGeometryObject(table, this.config);
    }
  };
  PgGeometryObject = class PgGeometryObject extends PgColumn {
    static [entityKind] = "PgGeometryObject";
    getSQLType() {
      return "geometry(point)";
    }
    mapFromDriverValue(value) {
      const parsed = parseEWKB(value);
      return { x: parsed[0], y: parsed[1] };
    }
    mapToDriverValue(value) {
      return `point(${value.x} ${value.y})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/real.js
function real(name) {
  return new PgRealBuilder(name ?? "");
}
var PgRealBuilder, PgReal;
var init_real = __esm(() => {
  init_entity();
  init_common();
  PgRealBuilder = class PgRealBuilder extends PgColumnBuilder {
    static [entityKind] = "PgRealBuilder";
    constructor(name, length) {
      super(name, "number", "PgReal");
      this.config.length = length;
    }
    build(table) {
      return new PgReal(table, this.config);
    }
  };
  PgReal = class PgReal extends PgColumn {
    static [entityKind] = "PgReal";
    constructor(table, config) {
      super(table, config);
    }
    getSQLType() {
      return "real";
    }
    mapFromDriverValue = (value) => {
      if (typeof value === "string") {
        return Number.parseFloat(value);
      }
      return value;
    };
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/serial.js
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}
var PgSerialBuilder, PgSerial;
var init_serial = __esm(() => {
  init_entity();
  init_common();
  PgSerialBuilder = class PgSerialBuilder extends PgColumnBuilder {
    static [entityKind] = "PgSerialBuilder";
    constructor(name) {
      super(name, "number", "PgSerial");
      this.config.hasDefault = true;
      this.config.notNull = true;
    }
    build(table) {
      return new PgSerial(table, this.config);
    }
  };
  PgSerial = class PgSerial extends PgColumn {
    static [entityKind] = "PgSerial";
    getSQLType() {
      return "serial";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/smallint.js
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}
var PgSmallIntBuilder, PgSmallInt;
var init_smallint = __esm(() => {
  init_entity();
  init_common();
  init_int_common();
  PgSmallIntBuilder = class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
    static [entityKind] = "PgSmallIntBuilder";
    constructor(name) {
      super(name, "number", "PgSmallInt");
    }
    build(table) {
      return new PgSmallInt(table, this.config);
    }
  };
  PgSmallInt = class PgSmallInt extends PgColumn {
    static [entityKind] = "PgSmallInt";
    getSQLType() {
      return "smallint";
    }
    mapFromDriverValue = (value) => {
      if (typeof value === "string") {
        return Number(value);
      }
      return value;
    };
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/smallserial.js
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}
var PgSmallSerialBuilder, PgSmallSerial;
var init_smallserial = __esm(() => {
  init_entity();
  init_common();
  PgSmallSerialBuilder = class PgSmallSerialBuilder extends PgColumnBuilder {
    static [entityKind] = "PgSmallSerialBuilder";
    constructor(name) {
      super(name, "number", "PgSmallSerial");
      this.config.hasDefault = true;
      this.config.notNull = true;
    }
    build(table) {
      return new PgSmallSerial(table, this.config);
    }
  };
  PgSmallSerial = class PgSmallSerial extends PgColumn {
    static [entityKind] = "PgSmallSerial";
    getSQLType() {
      return "smallserial";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/text.js
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name, config);
}
var PgTextBuilder, PgText;
var init_text = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgTextBuilder = class PgTextBuilder extends PgColumnBuilder {
    static [entityKind] = "PgTextBuilder";
    constructor(name, config) {
      super(name, "string", "PgText");
      this.config.enumValues = config.enum;
    }
    build(table) {
      return new PgText(table, this.config);
    }
  };
  PgText = class PgText extends PgColumn {
    static [entityKind] = "PgText";
    enumValues = this.config.enumValues;
    getSQLType() {
      return "text";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/time.js
function time(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}
var PgTimeBuilder, PgTime;
var init_time = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  init_date_common();
  PgTimeBuilder = class PgTimeBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
      super(name, "string", "PgTime");
      this.withTimezone = withTimezone;
      this.precision = precision;
      this.config.withTimezone = withTimezone;
      this.config.precision = precision;
    }
    static [entityKind] = "PgTimeBuilder";
    build(table) {
      return new PgTime(table, this.config);
    }
  };
  PgTime = class PgTime extends PgColumn {
    static [entityKind] = "PgTime";
    withTimezone;
    precision;
    constructor(table, config) {
      super(table, config);
      this.withTimezone = config.withTimezone;
      this.precision = config.precision;
    }
    getSQLType() {
      const precision = this.precision === undefined ? "" : `(${this.precision})`;
      return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/timestamp.js
function timestamp(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}
var PgTimestampBuilder, PgTimestamp, PgTimestampStringBuilder, PgTimestampString;
var init_timestamp = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  init_date_common();
  PgTimestampBuilder = class PgTimestampBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = "PgTimestampBuilder";
    constructor(name, withTimezone, precision) {
      super(name, "date", "PgTimestamp");
      this.config.withTimezone = withTimezone;
      this.config.precision = precision;
    }
    build(table) {
      return new PgTimestamp(table, this.config);
    }
  };
  PgTimestamp = class PgTimestamp extends PgColumn {
    static [entityKind] = "PgTimestamp";
    withTimezone;
    precision;
    constructor(table, config) {
      super(table, config);
      this.withTimezone = config.withTimezone;
      this.precision = config.precision;
    }
    getSQLType() {
      const precision = this.precision === undefined ? "" : ` (${this.precision})`;
      return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
    }
    mapFromDriverValue = (value) => {
      return new Date(this.withTimezone ? value : value + "+0000");
    };
    mapToDriverValue = (value) => {
      return value.toISOString();
    };
  };
  PgTimestampStringBuilder = class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = "PgTimestampStringBuilder";
    constructor(name, withTimezone, precision) {
      super(name, "string", "PgTimestampString");
      this.config.withTimezone = withTimezone;
      this.config.precision = precision;
    }
    build(table) {
      return new PgTimestampString(table, this.config);
    }
  };
  PgTimestampString = class PgTimestampString extends PgColumn {
    static [entityKind] = "PgTimestampString";
    withTimezone;
    precision;
    constructor(table, config) {
      super(table, config);
      this.withTimezone = config.withTimezone;
      this.precision = config.precision;
    }
    getSQLType() {
      const precision = this.precision === undefined ? "" : `(${this.precision})`;
      return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/uuid.js
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}
var PgUUIDBuilder, PgUUID;
var init_uuid = __esm(() => {
  init_entity();
  init_sql();
  init_common();
  PgUUIDBuilder = class PgUUIDBuilder extends PgColumnBuilder {
    static [entityKind] = "PgUUIDBuilder";
    constructor(name) {
      super(name, "string", "PgUUID");
    }
    defaultRandom() {
      return this.default(sql`gen_random_uuid()`);
    }
    build(table) {
      return new PgUUID(table, this.config);
    }
  };
  PgUUID = class PgUUID extends PgColumn {
    static [entityKind] = "PgUUID";
    getSQLType() {
      return "uuid";
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/varchar.js
function varchar(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name, config);
}
var PgVarcharBuilder, PgVarchar;
var init_varchar = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgVarcharBuilder = class PgVarcharBuilder extends PgColumnBuilder {
    static [entityKind] = "PgVarcharBuilder";
    constructor(name, config) {
      super(name, "string", "PgVarchar");
      this.config.length = config.length;
      this.config.enumValues = config.enum;
    }
    build(table) {
      return new PgVarchar(table, this.config);
    }
  };
  PgVarchar = class PgVarchar extends PgColumn {
    static [entityKind] = "PgVarchar";
    length = this.config.length;
    enumValues = this.config.enumValues;
    getSQLType() {
      return this.length === undefined ? `varchar` : `varchar(${this.length})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
function bit(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name, config);
}
var PgBinaryVectorBuilder, PgBinaryVector;
var init_bit = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgBinaryVectorBuilder = class PgBinaryVectorBuilder extends PgColumnBuilder {
    static [entityKind] = "PgBinaryVectorBuilder";
    constructor(name, config) {
      super(name, "string", "PgBinaryVector");
      this.config.dimensions = config.dimensions;
    }
    build(table) {
      return new PgBinaryVector(table, this.config);
    }
  };
  PgBinaryVector = class PgBinaryVector extends PgColumn {
    static [entityKind] = "PgBinaryVector";
    dimensions = this.config.dimensions;
    getSQLType() {
      return `bit(${this.dimensions})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
function halfvec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name, config);
}
var PgHalfVectorBuilder, PgHalfVector;
var init_halfvec = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgHalfVectorBuilder = class PgHalfVectorBuilder extends PgColumnBuilder {
    static [entityKind] = "PgHalfVectorBuilder";
    constructor(name, config) {
      super(name, "array", "PgHalfVector");
      this.config.dimensions = config.dimensions;
    }
    build(table) {
      return new PgHalfVector(table, this.config);
    }
  };
  PgHalfVector = class PgHalfVector extends PgColumn {
    static [entityKind] = "PgHalfVector";
    dimensions = this.config.dimensions;
    getSQLType() {
      return `halfvec(${this.dimensions})`;
    }
    mapToDriverValue(value) {
      return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
      return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
function sparsevec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name, config);
}
var PgSparseVectorBuilder, PgSparseVector;
var init_sparsevec = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgSparseVectorBuilder = class PgSparseVectorBuilder extends PgColumnBuilder {
    static [entityKind] = "PgSparseVectorBuilder";
    constructor(name, config) {
      super(name, "string", "PgSparseVector");
      this.config.dimensions = config.dimensions;
    }
    build(table) {
      return new PgSparseVector(table, this.config);
    }
  };
  PgSparseVector = class PgSparseVector extends PgColumn {
    static [entityKind] = "PgSparseVector";
    dimensions = this.config.dimensions;
    getSQLType() {
      return `sparsevec(${this.dimensions})`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
function vector(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name, config);
}
var PgVectorBuilder, PgVector;
var init_vector = __esm(() => {
  init_entity();
  init_utils();
  init_common();
  PgVectorBuilder = class PgVectorBuilder extends PgColumnBuilder {
    static [entityKind] = "PgVectorBuilder";
    constructor(name, config) {
      super(name, "array", "PgVector");
      this.config.dimensions = config.dimensions;
    }
    build(table) {
      return new PgVector(table, this.config);
    }
  };
  PgVector = class PgVector extends PgColumn {
    static [entityKind] = "PgVector";
    dimensions = this.config.dimensions;
    getSQLType() {
      return `vector(${this.dimensions})`;
    }
    mapToDriverValue(value) {
      return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
      return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}
var init_all = __esm(() => {
  init_bigint();
  init_bigserial();
  init_boolean();
  init_char();
  init_cidr();
  init_custom();
  init_date();
  init_double_precision();
  init_inet();
  init_integer();
  init_interval();
  init_json();
  init_jsonb();
  init_line();
  init_macaddr();
  init_macaddr8();
  init_numeric();
  init_point();
  init_geometry();
  init_real();
  init_serial();
  init_smallint();
  init_smallserial();
  init_text();
  init_time();
  init_timestamp();
  init_uuid();
  init_varchar();
  init_bit();
  init_halfvec();
  init_sparsevec();
  init_vector();
});

// ../../node_modules/drizzle-orm/pg-core/table.js
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var InlineForeignKeys, EnableRLS, PgTable, pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};
var init_table2 = __esm(() => {
  init_entity();
  init_table();
  init_all();
  InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
  EnableRLS = Symbol.for("drizzle:EnableRLS");
  PgTable = class PgTable extends Table {
    static [entityKind] = "PgTable";
    static Symbol = Object.assign({}, Table.Symbol, {
      InlineForeignKeys,
      EnableRLS
    });
    [InlineForeignKeys] = [];
    [EnableRLS] = false;
    [Table.Symbol.ExtraConfigBuilder] = undefined;
    [Table.Symbol.ExtraConfigColumns] = {};
  };
});

// ../../node_modules/drizzle-orm/pg-core/checks.js
function check(name, value) {
  return new CheckBuilder(name, value);
}
var CheckBuilder, Check;
var init_checks = __esm(() => {
  init_entity();
  CheckBuilder = class CheckBuilder {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
    static [entityKind] = "PgCheckBuilder";
    brand;
    build(table) {
      return new Check(table, this);
    }
  };
  Check = class Check {
    constructor(table, builder) {
      this.table = table;
      this.name = builder.name;
      this.value = builder.value;
    }
    static [entityKind] = "PgCheck";
    name;
    value;
  };
});

// ../../node_modules/drizzle-orm/pg-core/columns/index.js
var init_columns = __esm(() => {
  init_bigint();
  init_bigserial();
  init_boolean();
  init_char();
  init_cidr();
  init_common();
  init_custom();
  init_date();
  init_double_precision();
  init_enum();
  init_inet();
  init_int_common();
  init_integer();
  init_interval();
  init_json();
  init_jsonb();
  init_line();
  init_macaddr();
  init_macaddr8();
  init_numeric();
  init_point();
  init_geometry();
  init_real();
  init_serial();
  init_smallint();
  init_smallserial();
  init_text();
  init_time();
  init_timestamp();
  init_uuid();
  init_varchar();
  init_bit();
  init_halfvec();
  init_sparsevec();
  init_vector();
});

// ../../node_modules/drizzle-orm/pg-core/indexes.js
function index(name) {
  return new IndexBuilderOn(false, name);
}
var IndexBuilderOn, IndexBuilder, Index;
var init_indexes = __esm(() => {
  init_sql();
  init_entity();
  init_columns();
  IndexBuilderOn = class IndexBuilderOn {
    constructor(unique2, name) {
      this.unique = unique2;
      this.name = name;
    }
    static [entityKind] = "PgIndexBuilderOn";
    on(...columns) {
      return new IndexBuilder(columns.map((it) => {
        if (is(it, SQL)) {
          return it;
        }
        it = it;
        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
        it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
        return clonedIndexedColumn;
      }), this.unique, false, this.name);
    }
    onOnly(...columns) {
      return new IndexBuilder(columns.map((it) => {
        if (is(it, SQL)) {
          return it;
        }
        it = it;
        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
        it.indexConfig = it.defaultConfig;
        return clonedIndexedColumn;
      }), this.unique, true, this.name);
    }
    using(method, ...columns) {
      return new IndexBuilder(columns.map((it) => {
        if (is(it, SQL)) {
          return it;
        }
        it = it;
        const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
        it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
        return clonedIndexedColumn;
      }), this.unique, true, this.name, method);
    }
  };
  IndexBuilder = class IndexBuilder {
    static [entityKind] = "PgIndexBuilder";
    config;
    constructor(columns, unique2, only, name, method = "btree") {
      this.config = {
        name,
        columns,
        unique: unique2,
        only,
        method
      };
    }
    concurrently() {
      this.config.concurrently = true;
      return this;
    }
    with(obj) {
      this.config.with = obj;
      return this;
    }
    where(condition) {
      this.config.where = condition;
      return this;
    }
    build(table) {
      return new Index(this.config, table);
    }
  };
  Index = class Index {
    static [entityKind] = "PgIndex";
    config;
    constructor(config, table) {
      this.config = { ...config, table };
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/policies.js
var PgPolicy;
var init_policies = __esm(() => {
  init_entity();
  PgPolicy = class PgPolicy {
    constructor(name, config) {
      this.name = name;
      if (config) {
        this.as = config.as;
        this.for = config.for;
        this.to = config.to;
        this.using = config.using;
        this.withCheck = config.withCheck;
      }
    }
    static [entityKind] = "PgPolicy";
    as;
    for;
    to;
    using;
    withCheck;
    _linkedTable;
    link(table) {
      this._linkedTable = table;
      return this;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/primary-keys.js
function primaryKey(...config) {
  if (config[0].columns) {
    return new PrimaryKeyBuilder(config[0].columns, config[0].name);
  }
  return new PrimaryKeyBuilder(config);
}
var PrimaryKeyBuilder, PrimaryKey;
var init_primary_keys = __esm(() => {
  init_entity();
  init_table2();
  PrimaryKeyBuilder = class PrimaryKeyBuilder {
    static [entityKind] = "PgPrimaryKeyBuilder";
    columns;
    name;
    constructor(columns, name) {
      this.columns = columns;
      this.name = name;
    }
    build(table) {
      return new PrimaryKey(table, this.columns, this.name);
    }
  };
  PrimaryKey = class PrimaryKey {
    constructor(table, columns, name) {
      this.table = table;
      this.columns = columns;
      this.name = name;
    }
    static [entityKind] = "PgPrimaryKey";
    columns;
    name;
    getName() {
      return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/view-common.js
var PgViewConfig;
var init_view_common2 = __esm(() => {
  PgViewConfig = Symbol.for("drizzle:PgViewConfig");
});

// ../../node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}
var CasingCache;
var init_casing = __esm(() => {
  init_entity();
  init_table();
  CasingCache = class CasingCache {
    static [entityKind] = "CasingCache";
    cache = {};
    cachedTables = {};
    convert;
    constructor(casing) {
      this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
    }
    getColumnCasing(column) {
      if (!column.keyAsName)
        return column.name;
      const schema = column.table[Table.Symbol.Schema] ?? "public";
      const tableName = column.table[Table.Symbol.OriginalName];
      const key = `${schema}.${tableName}.${column.name}`;
      if (!this.cache[key]) {
        this.cacheTable(column.table);
      }
      return this.cache[key];
    }
    cacheTable(table) {
      const schema = table[Table.Symbol.Schema] ?? "public";
      const tableName = table[Table.Symbol.OriginalName];
      const tableKey = `${schema}.${tableName}`;
      if (!this.cachedTables[tableKey]) {
        for (const column of Object.values(table[Table.Symbol.Columns])) {
          const columnKey = `${tableKey}.${column.name}`;
          this.cache[columnKey] = this.convert(column.name);
        }
        this.cachedTables[tableKey] = true;
      }
    }
    clearCache() {
      this.cache = {};
      this.cachedTables = {};
    }
  };
});

// ../../node_modules/drizzle-orm/errors.js
var DrizzleError, DrizzleQueryError, TransactionRollbackError;
var init_errors = __esm(() => {
  init_entity();
  DrizzleError = class DrizzleError extends Error {
    static [entityKind] = "DrizzleError";
    constructor({ message, cause }) {
      super(message);
      this.name = "DrizzleError";
      this.cause = cause;
    }
  };
  DrizzleQueryError = class DrizzleQueryError extends Error {
    constructor(query, params, cause) {
      super(`Failed query: ${query}
params: ${params}`);
      this.query = query;
      this.params = params;
      this.cause = cause;
      Error.captureStackTrace(this, DrizzleQueryError);
      if (cause)
        this.cause = cause;
    }
  };
  TransactionRollbackError = class TransactionRollbackError extends DrizzleError {
    static [entityKind] = "TransactionRollbackError";
    constructor() {
      super({ message: "Rollback" });
    }
  };
});

// ../../node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
}, ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
}, gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
}, gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
}, lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
}, lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
var init_conditions = __esm(() => {
  init_column();
  init_entity();
  init_table();
  init_sql();
});

// ../../node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
var init_select = __esm(() => {
  init_sql();
});

// ../../node_modules/drizzle-orm/sql/expressions/index.js
var init_expressions = __esm(() => {
  init_conditions();
  init_select();
});

// ../../node_modules/drizzle-orm/relations.js
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey2;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey2) {
            tableConfig.primaryKey.push(...primaryKey2);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey: primaryKey2
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key, value]) => [
    key,
    value.withFieldName(key)
  ])));
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}
var Relation, Relations, One, Many;
var init_relations = __esm(() => {
  init_table();
  init_column();
  init_entity();
  init_primary_keys();
  init_expressions();
  init_sql();
  Relation = class Relation {
    constructor(sourceTable, referencedTable, relationName) {
      this.sourceTable = sourceTable;
      this.referencedTable = referencedTable;
      this.relationName = relationName;
      this.referencedTableName = referencedTable[Table.Symbol.Name];
    }
    static [entityKind] = "Relation";
    referencedTableName;
    fieldName;
  };
  Relations = class Relations {
    constructor(table, config) {
      this.table = table;
      this.config = config;
    }
    static [entityKind] = "Relations";
  };
  One = class One extends Relation {
    constructor(sourceTable, referencedTable, config, isNullable) {
      super(sourceTable, referencedTable, config?.relationName);
      this.config = config;
      this.isNullable = isNullable;
    }
    static [entityKind] = "One";
    withFieldName(fieldName) {
      const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
      relation.fieldName = fieldName;
      return relation;
    }
  };
  Many = class Many extends Relation {
    constructor(sourceTable, referencedTable, config) {
      super(sourceTable, referencedTable, config?.relationName);
      this.config = config;
    }
    static [entityKind] = "Many";
    withFieldName(fieldName) {
      const relation = new Many(this.sourceTable, this.referencedTable, this.config);
      relation.fieldName = fieldName;
      return relation;
    }
  };
});

// ../../node_modules/drizzle-orm/sql/functions/aggregate.js
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}
var init_aggregate = __esm(() => {
  init_sql();
});

// ../../node_modules/drizzle-orm/sql/functions/vector.js
function toSql(value) {
  return JSON.stringify(value);
}
function cosineDistance(column, value) {
  if (Array.isArray(value)) {
    return sql`${column} <=> ${toSql(value)}`;
  }
  return sql`${column} <=> ${value}`;
}
var init_vector2 = __esm(() => {
  init_sql();
});

// ../../node_modules/drizzle-orm/sql/functions/index.js
var init_functions = __esm(() => {
  init_aggregate();
  init_vector2();
});

// ../../node_modules/drizzle-orm/sql/index.js
var init_sql2 = __esm(() => {
  init_expressions();
  init_functions();
  init_sql();
});

// ../../node_modules/drizzle-orm/pg-core/view-base.js
var PgViewBase;
var init_view_base = __esm(() => {
  init_entity();
  init_sql();
  PgViewBase = class PgViewBase extends View {
    static [entityKind] = "PgViewBase";
  };
});

// ../../node_modules/drizzle-orm/pg-core/dialect.js
var PgDialect;
var init_dialect = __esm(() => {
  init_alias();
  init_casing();
  init_column();
  init_entity();
  init_errors();
  init_columns();
  init_table2();
  init_relations();
  init_sql2();
  init_sql();
  init_subquery();
  init_table();
  init_utils();
  init_view_common();
  init_view_base();
  PgDialect = class PgDialect {
    static [entityKind] = "PgDialect";
    casing;
    constructor(config) {
      this.casing = new CasingCache(config?.casing);
    }
    async migrate(migrations, session, config) {
      const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
      const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
      const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
      await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
      await session.execute(migrationTableCreate);
      const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
      const lastDbMigration = dbMigrations[0];
      await session.transaction(async (tx) => {
        for await (const migration of migrations) {
          if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
            for (const stmt of migration.sql) {
              await tx.execute(sql.raw(stmt));
            }
            await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
          }
        }
      });
    }
    escapeName(name) {
      return `"${name}"`;
    }
    escapeParam(num) {
      return `$${num + 1}`;
    }
    escapeString(str) {
      return `'${str.replace(/'/g, "''")}'`;
    }
    buildWithCTE(queries) {
      if (!queries?.length)
        return;
      const withSqlChunks = [sql`with `];
      for (const [i, w] of queries.entries()) {
        withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
        if (i < queries.length - 1) {
          withSqlChunks.push(sql`, `);
        }
      }
      withSqlChunks.push(sql` `);
      return sql.join(withSqlChunks);
    }
    buildDeleteQuery({ table, where, returning, withList }) {
      const withSql = this.buildWithCTE(withList);
      const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
      const whereSql = where ? sql` where ${where}` : undefined;
      return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
      const tableColumns = table[Table.Symbol.Columns];
      const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
      const setSize = columnNames.length;
      return sql.join(columnNames.flatMap((colName, i) => {
        const col = tableColumns[colName];
        const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
        const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
        if (i < setSize - 1) {
          return [res, sql.raw(", ")];
        }
        return [res];
      }));
    }
    buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
      const withSql = this.buildWithCTE(withList);
      const tableName = table[PgTable.Symbol.Name];
      const tableSchema = table[PgTable.Symbol.Schema];
      const origTableName = table[PgTable.Symbol.OriginalName];
      const alias = tableName === origTableName ? undefined : tableName;
      const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
      const setSql = this.buildUpdateSet(table, set);
      const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
      const joinsSql = this.buildJoins(joins);
      const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
      const whereSql = where ? sql` where ${where}` : undefined;
      return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
    }
    buildSelection(fields, { isSingleTable = false } = {}) {
      const columnsLen = fields.length;
      const chunks = fields.flatMap(({ field }, i) => {
        const chunk = [];
        if (is(field, SQL.Aliased) && field.isSelectionField) {
          chunk.push(sql.identifier(field.fieldAlias));
        } else if (is(field, SQL.Aliased) || is(field, SQL)) {
          const query = is(field, SQL.Aliased) ? field.sql : field;
          if (isSingleTable) {
            chunk.push(new SQL(query.queryChunks.map((c) => {
              if (is(c, PgColumn)) {
                return sql.identifier(this.casing.getColumnCasing(c));
              }
              return c;
            })));
          } else {
            chunk.push(query);
          }
          if (is(field, SQL.Aliased)) {
            chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
          }
        } else if (is(field, Column)) {
          if (isSingleTable) {
            chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
          } else {
            chunk.push(field);
          }
        }
        if (i < columnsLen - 1) {
          chunk.push(sql`, `);
        }
        return chunk;
      });
      return sql.join(chunks);
    }
    buildJoins(joins) {
      if (!joins || joins.length === 0) {
        return;
      }
      const joinsArray = [];
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
        const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
        if (is(table, PgTable)) {
          const tableName = table[PgTable.Symbol.Name];
          const tableSchema = table[PgTable.Symbol.Schema];
          const origTableName = table[PgTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
        } else if (is(table, View)) {
          const viewName = table[ViewBaseConfig].name;
          const viewSchema = table[ViewBaseConfig].schema;
          const origViewName = table[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
      return sql.join(joinsArray);
    }
    buildFromTable(table) {
      if (is(table, Table) && table[Table.Symbol.IsAlias]) {
        let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
        if (table[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    }
    buildSelectQuery({
      withList,
      fields,
      fieldsFlat,
      where,
      having,
      table,
      joins,
      orderBy,
      groupBy,
      limit,
      offset,
      lockingClause,
      distinct,
      setOperators
    }) {
      const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
      for (const f of fieldsList) {
        if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
          const tableName = getTableName(f.field.table);
          throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
        }
      }
      const isSingleTable = !joins || joins.length === 0;
      const withSql = this.buildWithCTE(withList);
      let distinctSql;
      if (distinct) {
        distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
      }
      const selection = this.buildSelection(fieldsList, { isSingleTable });
      const tableSql = this.buildFromTable(table);
      const joinsSql = this.buildJoins(joins);
      const whereSql = where ? sql` where ${where}` : undefined;
      const havingSql = having ? sql` having ${having}` : undefined;
      let orderBySql;
      if (orderBy && orderBy.length > 0) {
        orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
      }
      let groupBySql;
      if (groupBy && groupBy.length > 0) {
        groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
      }
      const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
      const offsetSql = offset ? sql` offset ${offset}` : undefined;
      const lockingClauseSql = sql.empty();
      if (lockingClause) {
        const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
        if (lockingClause.config.of) {
          clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
        }
        if (lockingClause.config.noWait) {
          clauseSql.append(sql` nowait`);
        } else if (lockingClause.config.skipLocked) {
          clauseSql.append(sql` skip locked`);
        }
        lockingClauseSql.append(clauseSql);
      }
      const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
      if (setOperators.length > 0) {
        return this.buildSetOperations(finalQuery, setOperators);
      }
      return finalQuery;
    }
    buildSetOperations(leftSelect, setOperators) {
      const [setOperator, ...rest] = setOperators;
      if (!setOperator) {
        throw new Error("Cannot pass undefined values to any set operator");
      }
      if (rest.length === 0) {
        return this.buildSetOperationQuery({ leftSelect, setOperator });
      }
      return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
    }
    buildSetOperationQuery({
      leftSelect,
      setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
    }) {
      const leftChunk = sql`(${leftSelect.getSQL()}) `;
      const rightChunk = sql`(${rightSelect.getSQL()})`;
      let orderBySql;
      if (orderBy && orderBy.length > 0) {
        const orderByValues = [];
        for (const singleOrderBy of orderBy) {
          if (is(singleOrderBy, PgColumn)) {
            orderByValues.push(sql.identifier(singleOrderBy.name));
          } else if (is(singleOrderBy, SQL)) {
            for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
              const chunk = singleOrderBy.queryChunks[i];
              if (is(chunk, PgColumn)) {
                singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
              }
            }
            orderByValues.push(sql`${singleOrderBy}`);
          } else {
            orderByValues.push(sql`${singleOrderBy}`);
          }
        }
        orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
      }
      const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
      const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
      const offsetSql = offset ? sql` offset ${offset}` : undefined;
      return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select: select2, overridingSystemValue_ }) {
      const valuesSqlList = [];
      const columns = table[Table.Symbol.Columns];
      const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
      const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
      if (select2) {
        const select22 = valuesOrSelect;
        if (is(select22, SQL)) {
          valuesSqlList.push(select22);
        } else {
          valuesSqlList.push(select22.getSQL());
        }
      } else {
        const values = valuesOrSelect;
        valuesSqlList.push(sql.raw("values "));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
              if (col.defaultFn !== undefined) {
                const defaultFnResult = col.defaultFn();
                const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                valueList.push(defaultValue);
              } else if (!col.default && col.onUpdateFn !== undefined) {
                const onUpdateFnResult = col.onUpdateFn();
                const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                valueList.push(newValue);
              } else {
                valueList.push(sql`default`);
              }
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
      }
      const withSql = this.buildWithCTE(withList);
      const valuesSql = sql.join(valuesSqlList);
      const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
      const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
      const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
      return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
    }
    buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
      const concurrentlySql = concurrently ? sql` concurrently` : undefined;
      const withNoDataSql = withNoData ? sql` with no data` : undefined;
      return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
    }
    prepareTyping(encoder) {
      if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
        return "json";
      } else if (is(encoder, PgNumeric)) {
        return "decimal";
      } else if (is(encoder, PgTime)) {
        return "time";
      } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
        return "timestamp";
      } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
        return "date";
      } else if (is(encoder, PgUUID)) {
        return "uuid";
      } else {
        return "none";
      }
    }
    sqlToQuery(sql22, invokeSource) {
      return sql22.toQuery({
        casing: this.casing,
        escapeName: this.escapeName,
        escapeParam: this.escapeParam,
        escapeString: this.escapeString,
        prepareTyping: this.prepareTyping,
        invokeSource
      });
    }
    buildRelationalQueryWithoutPK({
      fullSchema,
      schema,
      tableNamesMap,
      table,
      tableConfig,
      queryConfig: config,
      tableAlias,
      nestedQueryRelation,
      joinOn
    }) {
      let selection = [];
      let limit, offset, orderBy = [], where;
      const joins = [];
      if (config === true) {
        const selectionEntries = Object.entries(tableConfig.columns);
        selection = selectionEntries.map(([key, value]) => ({
          dbKey: value.name,
          tsKey: key,
          field: aliasedTableColumn(value, tableAlias),
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        }));
      } else {
        const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
        if (config.where) {
          const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
          where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
        }
        const fieldsSelection = [];
        let selectedColumns = [];
        if (config.columns) {
          let isIncludeMode = false;
          for (const [field, value] of Object.entries(config.columns)) {
            if (value === undefined) {
              continue;
            }
            if (field in tableConfig.columns) {
              if (!isIncludeMode && value === true) {
                isIncludeMode = true;
              }
              selectedColumns.push(field);
            }
          }
          if (selectedColumns.length > 0) {
            selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
          }
        } else {
          selectedColumns = Object.keys(tableConfig.columns);
        }
        for (const field of selectedColumns) {
          const column = tableConfig.columns[field];
          fieldsSelection.push({ tsKey: field, value: column });
        }
        let selectedRelations = [];
        if (config.with) {
          selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
        }
        let extras;
        if (config.extras) {
          extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
          for (const [tsKey, value] of Object.entries(extras)) {
            fieldsSelection.push({
              tsKey,
              value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
            });
          }
        }
        for (const { tsKey, value } of fieldsSelection) {
          selection.push({
            dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
            tsKey,
            field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
            relationTableTsKey: undefined,
            isJson: false,
            selection: []
          });
        }
        let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
        if (!Array.isArray(orderByOrig)) {
          orderByOrig = [orderByOrig];
        }
        orderBy = orderByOrig.map((orderByValue) => {
          if (is(orderByValue, Column)) {
            return aliasedTableColumn(orderByValue, tableAlias);
          }
          return mapColumnsInSQLToAlias(orderByValue, tableAlias);
        });
        limit = config.limit;
        offset = config.offset;
        for (const {
          tsKey: selectedRelationTsKey,
          queryConfig: selectedRelationConfigValue,
          relation
        } of selectedRelations) {
          const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
          const relationTableName = getTableUniqueName(relation.referencedTable);
          const relationTableTsName = tableNamesMap[relationTableName];
          const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
          const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
          const builtRelation = this.buildRelationalQueryWithoutPK({
            fullSchema,
            schema,
            tableNamesMap,
            table: fullSchema[relationTableTsName],
            tableConfig: schema[relationTableTsName],
            queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
            tableAlias: relationTableAlias,
            joinOn: joinOn2,
            nestedQueryRelation: relation
          });
          const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
          joins.push({
            on: sql`true`,
            table: new Subquery(builtRelation.sql, {}, relationTableAlias),
            alias: relationTableAlias,
            joinType: "left",
            lateral: true
          });
          selection.push({
            dbKey: selectedRelationTsKey,
            tsKey: selectedRelationTsKey,
            field,
            relationTableTsKey: relationTableTsName,
            isJson: true,
            selection: builtRelation.selection
          });
        }
      }
      if (selection.length === 0) {
        throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
      }
      let result;
      where = and(joinOn, where);
      if (nestedQueryRelation) {
        let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
        if (is(nestedQueryRelation, Many)) {
          field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
        }
        const nestedSelection = [{
          dbKey: "data",
          tsKey: "data",
          field: field.as("data"),
          isJson: true,
          relationTableTsKey: tableConfig.tsName,
          selection
        }];
        const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
        if (needsSubquery) {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: [{
              path: [],
              field: sql.raw("*")
            }],
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
          where = undefined;
          limit = undefined;
          offset = undefined;
          orderBy = [];
        } else {
          result = aliasedTable(table, tableAlias);
        }
        result = this.buildSelectQuery({
          table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
          fields: {},
          fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
            path: [],
            field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
          })),
          joins,
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
      } else {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: selection.map(({ field }) => ({
            path: [],
            field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
          })),
          joins,
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
      }
      return {
        tableTsKey: tableConfig.tsName,
        sql: result,
        selection
      };
    }
  };
});

// ../../node_modules/drizzle-orm/query-builders/query-builder.js
var TypedQueryBuilder;
var init_query_builder = __esm(() => {
  init_entity();
  TypedQueryBuilder = class TypedQueryBuilder {
    static [entityKind] = "TypedQueryBuilder";
    getSelectedFields() {
      return this._.selectedFields;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/select.js
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var PgSelectBuilder, PgSelectQueryBuilderBase, PgSelectBase, getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
}), union, unionAll, intersect, intersectAll, except, exceptAll;
var init_select2 = __esm(() => {
  init_entity();
  init_view_base();
  init_query_builder();
  init_query_promise();
  init_selection_proxy();
  init_sql();
  init_subquery();
  init_table();
  init_tracing();
  init_utils();
  init_utils();
  init_view_common();
  init_utils3();
  PgSelectBuilder = class PgSelectBuilder {
    static [entityKind] = "PgSelectBuilder";
    fields;
    session;
    dialect;
    withList = [];
    distinct;
    constructor(config) {
      this.fields = config.fields;
      this.session = config.session;
      this.dialect = config.dialect;
      if (config.withList) {
        this.withList = config.withList;
      }
      this.distinct = config.distinct;
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    from(source) {
      const isPartialSelect = !!this.fields;
      const src = source;
      let fields;
      if (this.fields) {
        fields = this.fields;
      } else if (is(src, Subquery)) {
        fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
      } else if (is(src, PgViewBase)) {
        fields = src[ViewBaseConfig].selectedFields;
      } else if (is(src, SQL)) {
        fields = {};
      } else {
        fields = getTableColumns(src);
      }
      return new PgSelectBase({
        table: src,
        fields,
        isPartialSelect,
        session: this.session,
        dialect: this.dialect,
        withList: this.withList,
        distinct: this.distinct
      }).setToken(this.authToken);
    }
  };
  PgSelectQueryBuilderBase = class PgSelectQueryBuilderBase extends TypedQueryBuilder {
    static [entityKind] = "PgSelectQueryBuilder";
    _;
    config;
    joinsNotNullableMap;
    tableName;
    isPartialSelect;
    session;
    dialect;
    cacheConfig = undefined;
    usedTables = /* @__PURE__ */ new Set;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
      super();
      this.config = {
        withList,
        table,
        fields: { ...fields },
        distinct,
        setOperators: []
      };
      this.isPartialSelect = isPartialSelect;
      this.session = session;
      this.dialect = dialect;
      this._ = {
        selectedFields: fields,
        config: this.config
      };
      this.tableName = getTableLikeName(table);
      this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
    }
    getUsedTables() {
      return [...this.usedTables];
    }
    createJoin(joinType, lateral) {
      return (table, on) => {
        const baseTableName = this.tableName;
        const tableName = getTableLikeName(table);
        for (const item of extractUsedTable(table))
          this.usedTables.add(item);
        if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
          throw new Error(`Alias "${tableName}" is already used in this query`);
        }
        if (!this.isPartialSelect) {
          if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
            this.config.fields = {
              [baseTableName]: this.config.fields
            };
          }
          if (typeof tableName === "string" && !is(table, SQL)) {
            const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
            this.config.fields[tableName] = selection;
          }
        }
        if (typeof on === "function") {
          on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        if (!this.config.joins) {
          this.config.joins = [];
        }
        this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
        if (typeof tableName === "string") {
          switch (joinType) {
            case "left": {
              this.joinsNotNullableMap[tableName] = false;
              break;
            }
            case "right": {
              this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
              this.joinsNotNullableMap[tableName] = true;
              break;
            }
            case "cross":
            case "inner": {
              this.joinsNotNullableMap[tableName] = true;
              break;
            }
            case "full": {
              this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
              this.joinsNotNullableMap[tableName] = false;
              break;
            }
          }
        }
        return this;
      };
    }
    leftJoin = this.createJoin("left", false);
    leftJoinLateral = this.createJoin("left", true);
    rightJoin = this.createJoin("right", false);
    innerJoin = this.createJoin("inner", false);
    innerJoinLateral = this.createJoin("inner", true);
    fullJoin = this.createJoin("full", false);
    crossJoin = this.createJoin("cross", false);
    crossJoinLateral = this.createJoin("cross", true);
    createSetOperator(type, isAll) {
      return (rightSelection) => {
        const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
        if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
          throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
        }
        this.config.setOperators.push({ type, isAll, rightSelect });
        return this;
      };
    }
    union = this.createSetOperator("union", false);
    unionAll = this.createSetOperator("union", true);
    intersect = this.createSetOperator("intersect", false);
    intersectAll = this.createSetOperator("intersect", true);
    except = this.createSetOperator("except", false);
    exceptAll = this.createSetOperator("except", true);
    addSetOperators(setOperators) {
      this.config.setOperators.push(...setOperators);
      return this;
    }
    where(where) {
      if (typeof where === "function") {
        where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.where = where;
      return this;
    }
    having(having) {
      if (typeof having === "function") {
        having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.having = having;
      return this;
    }
    groupBy(...columns) {
      if (typeof columns[0] === "function") {
        const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
        this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
      } else {
        this.config.groupBy = columns;
      }
      return this;
    }
    orderBy(...columns) {
      if (typeof columns[0] === "function") {
        const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
        const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).orderBy = orderByArray;
        } else {
          this.config.orderBy = orderByArray;
        }
      } else {
        const orderByArray = columns;
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).orderBy = orderByArray;
        } else {
          this.config.orderBy = orderByArray;
        }
      }
      return this;
    }
    limit(limit) {
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).limit = limit;
      } else {
        this.config.limit = limit;
      }
      return this;
    }
    offset(offset) {
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).offset = offset;
      } else {
        this.config.offset = offset;
      }
      return this;
    }
    for(strength, config = {}) {
      this.config.lockingClause = { strength, config };
      return this;
    }
    getSQL() {
      return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
      const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
      return rest;
    }
    as(alias) {
      const usedTables = [];
      usedTables.push(...extractUsedTable(this.config.table));
      if (this.config.joins) {
        for (const it of this.config.joins)
          usedTables.push(...extractUsedTable(it.table));
      }
      return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    }
    getSelectedFields() {
      return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    }
    $dynamic() {
      return this;
    }
    $withCache(config) {
      this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
      return this;
    }
  };
  PgSelectBase = class PgSelectBase extends PgSelectQueryBuilderBase {
    static [entityKind] = "PgSelect";
    _prepare(name) {
      const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
      if (!session) {
        throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
      }
      const { fields } = config;
      return tracer.startActiveSpan("drizzle.prepareQuery", () => {
        const fieldsList = orderSelectedFields(fields);
        const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {
          type: "select",
          tables: [...usedTables]
        }, cacheConfig);
        query.joinsNotNullableMap = joinsNotNullableMap;
        return query.setToken(authToken);
      });
    }
    prepare(name) {
      return this._prepare(name);
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute = (placeholderValues) => {
      return tracer.startActiveSpan("drizzle.operation", () => {
        return this._prepare().execute(placeholderValues, this.authToken);
      });
    };
  };
  applyMixins(PgSelectBase, [QueryPromise]);
  union = createSetOperator("union", false);
  unionAll = createSetOperator("union", true);
  intersect = createSetOperator("intersect", false);
  intersectAll = createSetOperator("intersect", true);
  except = createSetOperator("except", false);
  exceptAll = createSetOperator("except", true);
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var QueryBuilder;
var init_query_builder2 = __esm(() => {
  init_entity();
  init_dialect();
  init_selection_proxy();
  init_subquery();
  init_select2();
  QueryBuilder = class QueryBuilder {
    static [entityKind] = "PgQueryBuilder";
    dialect;
    dialectConfig;
    constructor(dialect) {
      this.dialect = is(dialect, PgDialect) ? dialect : undefined;
      this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
    }
    $with = (alias, selection) => {
      const queryBuilder = this;
      const as = (qb) => {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      };
      return { as };
    };
    with(...queries) {
      const self = this;
      function select2(fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: undefined,
          dialect: self.getDialect(),
          withList: queries
        });
      }
      function selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: undefined,
          dialect: self.getDialect(),
          distinct: true
        });
      }
      function selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: undefined,
          dialect: self.getDialect(),
          distinct: { on }
        });
      }
      return { select: select2, selectDistinct, selectDistinctOn };
    }
    select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: this.getDialect()
      });
    }
    selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: this.getDialect(),
        distinct: true
      });
    }
    selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: this.getDialect(),
        distinct: { on }
      });
    }
    getDialect() {
      if (!this.dialect) {
        this.dialect = new PgDialect(this.dialectConfig);
      }
      return this.dialect;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/view.js
var PgMaterializedViewConfig;
var init_view = __esm(() => {
  PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
});

// ../../node_modules/drizzle-orm/pg-core/utils.js
function getTableConfig(table) {
  const columns = Object.values(table[Table.Symbol.Columns]);
  const indexes = [];
  const checks = [];
  const primaryKeys = [];
  const foreignKeys = Object.values(table[PgTable.Symbol.InlineForeignKeys]);
  const uniqueConstraints = [];
  const name = table[Table.Symbol.Name];
  const schema = table[Table.Symbol.Schema];
  const policies = [];
  const enableRLS = table[PgTable.Symbol.EnableRLS];
  const extraConfigBuilder = table[PgTable.Symbol.ExtraConfigBuilder];
  if (extraConfigBuilder !== undefined) {
    const extraConfig = extraConfigBuilder(table[Table.Symbol.ExtraConfigColumns]);
    const extraValues = Array.isArray(extraConfig) ? extraConfig.flat(1) : Object.values(extraConfig);
    for (const builder of extraValues) {
      if (is(builder, IndexBuilder)) {
        indexes.push(builder.build(table));
      } else if (is(builder, CheckBuilder)) {
        checks.push(builder.build(table));
      } else if (is(builder, UniqueConstraintBuilder)) {
        uniqueConstraints.push(builder.build(table));
      } else if (is(builder, PrimaryKeyBuilder)) {
        primaryKeys.push(builder.build(table));
      } else if (is(builder, ForeignKeyBuilder)) {
        foreignKeys.push(builder.build(table));
      } else if (is(builder, PgPolicy)) {
        policies.push(builder);
      }
    }
  }
  return {
    columns,
    indexes,
    foreignKeys,
    checks,
    primaryKeys,
    uniqueConstraints,
    name,
    schema,
    policies,
    enableRLS
  };
}
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}
var init_utils3 = __esm(() => {
  init_entity();
  init_table2();
  init_sql();
  init_subquery();
  init_table();
  init_checks();
  init_foreign_keys();
  init_indexes();
  init_policies();
  init_primary_keys();
  init_unique_constraint();
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/delete.js
var PgDeleteBase;
var init_delete = __esm(() => {
  init_entity();
  init_query_promise();
  init_selection_proxy();
  init_table();
  init_tracing();
  init_utils();
  init_utils3();
  PgDeleteBase = class PgDeleteBase extends QueryPromise {
    constructor(table, session, dialect, withList) {
      super();
      this.session = session;
      this.dialect = dialect;
      this.config = { table, withList };
    }
    static [entityKind] = "PgDelete";
    config;
    cacheConfig;
    where(where) {
      this.config.where = where;
      return this;
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
      this.config.returningFields = fields;
      this.config.returning = orderSelectedFields(fields);
      return this;
    }
    getSQL() {
      return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
      const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
      return rest;
    }
    _prepare(name) {
      return tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
          type: "delete",
          tables: extractUsedTable(this.config.table)
        }, this.cacheConfig);
      });
    }
    prepare(name) {
      return this._prepare(name);
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute = (placeholderValues) => {
      return tracer.startActiveSpan("drizzle.operation", () => {
        return this._prepare().execute(placeholderValues, this.authToken);
      });
    };
    getSelectedFields() {
      return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })) : undefined;
    }
    $dynamic() {
      return this;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/insert.js
var PgInsertBuilder, PgInsertBase;
var init_insert = __esm(() => {
  init_entity();
  init_query_promise();
  init_selection_proxy();
  init_sql();
  init_table();
  init_tracing();
  init_utils();
  init_utils3();
  init_query_builder2();
  PgInsertBuilder = class PgInsertBuilder {
    constructor(table, session, dialect, withList, overridingSystemValue_) {
      this.table = table;
      this.session = session;
      this.dialect = dialect;
      this.withList = withList;
      this.overridingSystemValue_ = overridingSystemValue_;
    }
    static [entityKind] = "PgInsertBuilder";
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    overridingSystemValue() {
      this.overridingSystemValue_ = true;
      return this;
    }
    values(values) {
      values = Array.isArray(values) ? values : [values];
      if (values.length === 0) {
        throw new Error("values() must be called with at least one value");
      }
      const mappedValues = values.map((entry) => {
        const result = {};
        const cols = this.table[Table.Symbol.Columns];
        for (const colKey of Object.keys(entry)) {
          const colValue = entry[colKey];
          result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
        }
        return result;
      });
      return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
    }
    select(selectQuery) {
      const select2 = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
      if (!is(select2, SQL) && !haveSameKeys(this.table[Columns], select2._.selectedFields)) {
        throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
      }
      return new PgInsertBase(this.table, select2, this.session, this.dialect, this.withList, true);
    }
  };
  PgInsertBase = class PgInsertBase extends QueryPromise {
    constructor(table, values, session, dialect, withList, select2, overridingSystemValue_) {
      super();
      this.session = session;
      this.dialect = dialect;
      this.config = { table, values, withList, select: select2, overridingSystemValue_ };
    }
    static [entityKind] = "PgInsert";
    config;
    cacheConfig;
    returning(fields = this.config.table[Table.Symbol.Columns]) {
      this.config.returningFields = fields;
      this.config.returning = orderSelectedFields(fields);
      return this;
    }
    onConflictDoNothing(config = {}) {
      if (config.target === undefined) {
        this.config.onConflict = sql`do nothing`;
      } else {
        let targetColumn = "";
        targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
        const whereSql = config.where ? sql` where ${config.where}` : undefined;
        this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
      }
      return this;
    }
    onConflictDoUpdate(config) {
      if (config.where && (config.targetWhere || config.setWhere)) {
        throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
      }
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
      const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
      const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
      return this;
    }
    getSQL() {
      return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
      const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
      return rest;
    }
    _prepare(name) {
      return tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
          type: "insert",
          tables: extractUsedTable(this.config.table)
        }, this.cacheConfig);
      });
    }
    prepare(name) {
      return this._prepare(name);
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute = (placeholderValues) => {
      return tracer.startActiveSpan("drizzle.operation", () => {
        return this._prepare().execute(placeholderValues, this.authToken);
      });
    };
    getSelectedFields() {
      return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })) : undefined;
    }
    $dynamic() {
      return this;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
var PgRefreshMaterializedView;
var init_refresh_materialized_view = __esm(() => {
  init_entity();
  init_query_promise();
  init_tracing();
  PgRefreshMaterializedView = class PgRefreshMaterializedView extends QueryPromise {
    constructor(view, session, dialect) {
      super();
      this.session = session;
      this.dialect = dialect;
      this.config = { view };
    }
    static [entityKind] = "PgRefreshMaterializedView";
    config;
    concurrently() {
      if (this.config.withNoData !== undefined) {
        throw new Error("Cannot use concurrently and withNoData together");
      }
      this.config.concurrently = true;
      return this;
    }
    withNoData() {
      if (this.config.concurrently !== undefined) {
        throw new Error("Cannot use concurrently and withNoData together");
      }
      this.config.withNoData = true;
      return this;
    }
    getSQL() {
      return this.dialect.buildRefreshMaterializedViewQuery(this.config);
    }
    toSQL() {
      const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
      return rest;
    }
    _prepare(name) {
      return tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
      });
    }
    prepare(name) {
      return this._prepare(name);
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute = (placeholderValues) => {
      return tracer.startActiveSpan("drizzle.operation", () => {
        return this._prepare().execute(placeholderValues, this.authToken);
      });
    };
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/update.js
var PgUpdateBuilder, PgUpdateBase;
var init_update = __esm(() => {
  init_entity();
  init_table2();
  init_query_promise();
  init_selection_proxy();
  init_sql();
  init_subquery();
  init_table();
  init_utils();
  init_view_common();
  init_utils3();
  PgUpdateBuilder = class PgUpdateBuilder {
    constructor(table, session, dialect, withList) {
      this.table = table;
      this.session = session;
      this.dialect = dialect;
      this.withList = withList;
    }
    static [entityKind] = "PgUpdateBuilder";
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    set(values) {
      return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList).setToken(this.authToken);
    }
  };
  PgUpdateBase = class PgUpdateBase extends QueryPromise {
    constructor(table, set, session, dialect, withList) {
      super();
      this.session = session;
      this.dialect = dialect;
      this.config = { set, table, withList, joins: [] };
      this.tableName = getTableLikeName(table);
      this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    }
    static [entityKind] = "PgUpdate";
    config;
    tableName;
    joinsNotNullableMap;
    cacheConfig;
    from(source) {
      const src = source;
      const tableName = getTableLikeName(src);
      if (typeof tableName === "string") {
        this.joinsNotNullableMap[tableName] = true;
      }
      this.config.from = src;
      return this;
    }
    getTableLikeFields(table) {
      if (is(table, PgTable)) {
        return table[Table.Symbol.Columns];
      } else if (is(table, Subquery)) {
        return table._.selectedFields;
      }
      return table[ViewBaseConfig].selectedFields;
    }
    createJoin(joinType) {
      return (table, on) => {
        const tableName = getTableLikeName(table);
        if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
          throw new Error(`Alias "${tableName}" is already used in this query`);
        }
        if (typeof on === "function") {
          const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
          on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
        }
        this.config.joins.push({ on, table, joinType, alias: tableName });
        if (typeof tableName === "string") {
          switch (joinType) {
            case "left": {
              this.joinsNotNullableMap[tableName] = false;
              break;
            }
            case "right": {
              this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
              this.joinsNotNullableMap[tableName] = true;
              break;
            }
            case "inner": {
              this.joinsNotNullableMap[tableName] = true;
              break;
            }
            case "full": {
              this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
              this.joinsNotNullableMap[tableName] = false;
              break;
            }
          }
        }
        return this;
      };
    }
    leftJoin = this.createJoin("left");
    rightJoin = this.createJoin("right");
    innerJoin = this.createJoin("inner");
    fullJoin = this.createJoin("full");
    where(where) {
      this.config.where = where;
      return this;
    }
    returning(fields) {
      if (!fields) {
        fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
        if (this.config.from) {
          const tableName = getTableLikeName(this.config.from);
          if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
            const fromFields = this.getTableLikeFields(this.config.from);
            fields[tableName] = fromFields;
          }
          for (const join of this.config.joins) {
            const tableName2 = getTableLikeName(join.table);
            if (typeof tableName2 === "string" && !is(join.table, SQL)) {
              const fromFields = this.getTableLikeFields(join.table);
              fields[tableName2] = fromFields;
            }
          }
        }
      }
      this.config.returningFields = fields;
      this.config.returning = orderSelectedFields(fields);
      return this;
    }
    getSQL() {
      return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
      const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
      return rest;
    }
    _prepare(name) {
      const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
      query.joinsNotNullableMap = this.joinsNotNullableMap;
      return query;
    }
    prepare(name) {
      return this._prepare(name);
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute = (placeholderValues) => {
      return this._prepare().execute(placeholderValues, this.authToken);
    };
    getSelectedFields() {
      return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
        alias: getTableName(this.config.table),
        sqlAliasedBehavior: "alias",
        sqlBehavior: "error"
      })) : undefined;
    }
    $dynamic() {
      return this;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/index.js
var init_query_builders = __esm(() => {
  init_delete();
  init_insert();
  init_query_builder2();
  init_refresh_materialized_view();
  init_select2();
  init_update();
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/count.js
var PgCountBuilder;
var init_count = __esm(() => {
  init_entity();
  init_sql();
  PgCountBuilder = class PgCountBuilder extends SQL {
    constructor(params) {
      super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
      this.params = params;
      this.mapWith(Number);
      this.session = params.session;
      this.sql = PgCountBuilder.buildCount(params.source, params.filters);
    }
    sql;
    token;
    static [entityKind] = "PgCountBuilder";
    [Symbol.toStringTag] = "PgCountBuilder";
    session;
    static buildEmbeddedCount(source, filters) {
      return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
    }
    static buildCount(source, filters) {
      return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
    }
    setToken(token) {
      this.token = token;
      return this;
    }
    then(onfulfilled, onrejected) {
      return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
    }
    catch(onRejected) {
      return this.then(undefined, onRejected);
    }
    finally(onFinally) {
      return this.then((value) => {
        onFinally?.();
        return value;
      }, (reason) => {
        onFinally?.();
        throw reason;
      });
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/query.js
var RelationalQueryBuilder, PgRelationalQuery;
var init_query = __esm(() => {
  init_entity();
  init_query_promise();
  init_relations();
  init_tracing();
  RelationalQueryBuilder = class RelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
      this.fullSchema = fullSchema;
      this.schema = schema;
      this.tableNamesMap = tableNamesMap;
      this.table = table;
      this.tableConfig = tableConfig;
      this.dialect = dialect;
      this.session = session;
    }
    static [entityKind] = "PgRelationalQueryBuilder";
    findMany(config) {
      return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
    }
    findFirst(config) {
      return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
    }
  };
  PgRelationalQuery = class PgRelationalQuery extends QueryPromise {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
      super();
      this.fullSchema = fullSchema;
      this.schema = schema;
      this.tableNamesMap = tableNamesMap;
      this.table = table;
      this.tableConfig = tableConfig;
      this.dialect = dialect;
      this.session = session;
      this.config = config;
      this.mode = mode;
    }
    static [entityKind] = "PgRelationalQuery";
    _prepare(name) {
      return tracer.startActiveSpan("drizzle.prepareQuery", () => {
        const { query, builtQuery } = this._toSQL();
        return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
          const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
          if (this.mode === "first") {
            return rows[0];
          }
          return rows;
        });
      });
    }
    prepare(name) {
      return this._prepare(name);
    }
    _getQuery() {
      return this.dialect.buildRelationalQueryWithoutPK({
        fullSchema: this.fullSchema,
        schema: this.schema,
        tableNamesMap: this.tableNamesMap,
        table: this.table,
        tableConfig: this.tableConfig,
        queryConfig: this.config,
        tableAlias: this.tableConfig.tsName
      });
    }
    getSQL() {
      return this._getQuery().sql;
    }
    _toSQL() {
      const query = this._getQuery();
      const builtQuery = this.dialect.sqlToQuery(query.sql);
      return { query, builtQuery };
    }
    toSQL() {
      return this._toSQL().builtQuery;
    }
    authToken;
    setToken(token) {
      this.authToken = token;
      return this;
    }
    execute() {
      return tracer.startActiveSpan("drizzle.operation", () => {
        return this._prepare().execute(undefined, this.authToken);
      });
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/query-builders/raw.js
var PgRaw;
var init_raw = __esm(() => {
  init_entity();
  init_query_promise();
  PgRaw = class PgRaw extends QueryPromise {
    constructor(execute, sql3, query, mapBatchResult) {
      super();
      this.execute = execute;
      this.sql = sql3;
      this.query = query;
      this.mapBatchResult = mapBatchResult;
    }
    static [entityKind] = "PgRaw";
    getSQL() {
      return this.sql;
    }
    getQuery() {
      return this.query;
    }
    mapResult(result, isFromBatch) {
      return isFromBatch ? this.mapBatchResult(result) : result;
    }
    _prepare() {
      return this;
    }
    isResponseInArrayMode() {
      return false;
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/db.js
var PgDatabase;
var init_db = __esm(() => {
  init_entity();
  init_query_builders();
  init_selection_proxy();
  init_sql();
  init_subquery();
  init_count();
  init_query();
  init_raw();
  init_refresh_materialized_view();
  PgDatabase = class PgDatabase {
    constructor(dialect, session, schema) {
      this.dialect = dialect;
      this.session = session;
      this._ = schema ? {
        schema: schema.schema,
        fullSchema: schema.fullSchema,
        tableNamesMap: schema.tableNamesMap,
        session
      } : {
        schema: undefined,
        fullSchema: {},
        tableNamesMap: {},
        session
      };
      this.query = {};
      if (this._.schema) {
        for (const [tableName, columns] of Object.entries(this._.schema)) {
          this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
        }
      }
      this.$cache = { invalidate: async (_params) => {} };
    }
    static [entityKind] = "PgDatabase";
    query;
    $with = (alias, selection) => {
      const self = this;
      const as = (qb) => {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder(self.dialect));
        }
        return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      };
      return { as };
    };
    $count(source, filters) {
      return new PgCountBuilder({ source, filters, session: this.session });
    }
    $cache;
    with(...queries) {
      const self = this;
      function select3(fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: self.session,
          dialect: self.dialect,
          withList: queries
        });
      }
      function selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: self.session,
          dialect: self.dialect,
          withList: queries,
          distinct: true
        });
      }
      function selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
          fields: fields ?? undefined,
          session: self.session,
          dialect: self.dialect,
          withList: queries,
          distinct: { on }
        });
      }
      function update2(table) {
        return new PgUpdateBuilder(table, self.session, self.dialect, queries);
      }
      function insert2(table) {
        return new PgInsertBuilder(table, self.session, self.dialect, queries);
      }
      function delete_(table) {
        return new PgDeleteBase(table, self.session, self.dialect, queries);
      }
      return { select: select3, selectDistinct, selectDistinctOn, update: update2, insert: insert2, delete: delete_ };
    }
    select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: this.session,
        dialect: this.dialect
      });
    }
    selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: this.session,
        dialect: this.dialect,
        distinct: true
      });
    }
    selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: this.session,
        dialect: this.dialect,
        distinct: { on }
      });
    }
    update(table) {
      return new PgUpdateBuilder(table, this.session, this.dialect);
    }
    insert(table) {
      return new PgInsertBuilder(table, this.session, this.dialect);
    }
    delete(table) {
      return new PgDeleteBase(table, this.session, this.dialect);
    }
    refreshMaterializedView(view) {
      return new PgRefreshMaterializedView(view, this.session, this.dialect);
    }
    authToken;
    execute(query) {
      const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
      const builtQuery = this.dialect.sqlToQuery(sequel);
      const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
      return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
    }
    transaction(transaction, config) {
      return this.session.transaction(transaction, config);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/alias.js
var init_alias2 = () => {};

// ../../node_modules/drizzle-orm/pg-core/roles.js
var init_roles = () => {};

// ../../node_modules/drizzle-orm/pg-core/sequence.js
var init_sequence = () => {};

// ../../node_modules/drizzle-orm/pg-core/schema.js
var init_schema = () => {};

// ../../node_modules/drizzle-orm/cache/core/cache.js
async function hashQuery(sql3, params) {
  const dataToHash = `${sql3}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
var Cache, NoopCache;
var init_cache = __esm(() => {
  init_entity();
  Cache = class Cache {
    static [entityKind] = "Cache";
  };
  NoopCache = class NoopCache extends Cache {
    strategy() {
      return "all";
    }
    static [entityKind] = "NoopCache";
    async get(_key) {
      return;
    }
    async put(_hashedQuery, _response, _tables, _config) {}
    async onMutate(_params) {}
  };
});

// ../../node_modules/drizzle-orm/pg-core/session.js
var PgPreparedQuery, PgSession, PgTransaction;
var init_session = __esm(() => {
  init_cache();
  init_entity();
  init_errors();
  init_sql2();
  init_tracing();
  init_db();
  PgPreparedQuery = class PgPreparedQuery {
    constructor(query, cache, queryMetadata, cacheConfig) {
      this.query = query;
      this.cache = cache;
      this.queryMetadata = queryMetadata;
      this.cacheConfig = cacheConfig;
      if (cache && cache.strategy() === "all" && cacheConfig === undefined) {
        this.cacheConfig = { enable: true, autoInvalidate: true };
      }
      if (!this.cacheConfig?.enable) {
        this.cacheConfig = undefined;
      }
    }
    authToken;
    getQuery() {
      return this.query;
    }
    mapResult(response, _isFromBatch) {
      return response;
    }
    setToken(token) {
      this.authToken = token;
      return this;
    }
    static [entityKind] = "PgPreparedQuery";
    joinsNotNullableMap;
    async queryWithCache(queryString, params, query) {
      if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
        try {
          return await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
      }
      if (this.cacheConfig && !this.cacheConfig.enable) {
        try {
          return await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
      }
      if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
        try {
          const [res] = await Promise.all([
            query(),
            this.cache.onMutate({ tables: this.queryMetadata.tables })
          ]);
          return res;
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
      }
      if (!this.cacheConfig) {
        try {
          return await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
      }
      if (this.queryMetadata.type === "select") {
        const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
        if (fromCache === undefined) {
          let result;
          try {
            result = await query();
          } catch (e) {
            throw new DrizzleQueryError(queryString, params, e);
          }
          await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
          return result;
        }
        return fromCache;
      }
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
  };
  PgSession = class PgSession {
    constructor(dialect) {
      this.dialect = dialect;
    }
    static [entityKind] = "PgSession";
    execute(query, token) {
      return tracer.startActiveSpan("drizzle.operation", () => {
        const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
        });
        return prepared.setToken(token).execute(undefined, token);
      });
    }
    all(query) {
      return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
    }
    async count(sql22, token) {
      const res = await this.execute(sql22, token);
      return Number(res[0]["count"]);
    }
  };
  PgTransaction = class PgTransaction extends PgDatabase {
    constructor(dialect, session, schema, nestedIndex = 0) {
      super(dialect, session, schema);
      this.schema = schema;
      this.nestedIndex = nestedIndex;
    }
    static [entityKind] = "PgTransaction";
    rollback() {
      throw new TransactionRollbackError;
    }
    getTransactionConfigSQL(config) {
      const chunks = [];
      if (config.isolationLevel) {
        chunks.push(`isolation level ${config.isolationLevel}`);
      }
      if (config.accessMode) {
        chunks.push(config.accessMode);
      }
      if (typeof config.deferrable === "boolean") {
        chunks.push(config.deferrable ? "deferrable" : "not deferrable");
      }
      return sql.raw(chunks.join(" "));
    }
    setTransaction(config) {
      return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
    }
  };
});

// ../../node_modules/drizzle-orm/pg-core/utils/index.js
var init_utils4 = __esm(() => {
  init_array();
});

// ../../node_modules/drizzle-orm/pg-core/index.js
var init_pg_core = __esm(() => {
  init_alias2();
  init_checks();
  init_columns();
  init_db();
  init_dialect();
  init_foreign_keys();
  init_indexes();
  init_policies();
  init_primary_keys();
  init_query_builders();
  init_roles();
  init_schema();
  init_sequence();
  init_session();
  init_table2();
  init_unique_constraint();
  init_utils3();
  init_utils4();
  init_view_common2();
  init_view();
});

// ../../node_modules/drizzle-orm/index.js
var init_drizzle_orm = __esm(() => {
  init_alias();
  init_column_builder();
  init_column();
  init_entity();
  init_errors();
  init_logger();
  init_query_promise();
  init_relations();
  init_sql2();
  init_subquery();
  init_table();
  init_utils();
  init_view_common();
});

// src/runtime-migrator/storage/migration-tracker.ts
class MigrationTracker {
  db;
  constructor(db2) {
    this.db = db2;
  }
  async ensureSchema() {
    await this.db.execute(sql`CREATE SCHEMA IF NOT EXISTS migrations`);
  }
  async ensureTables() {
    await this.ensureSchema();
    await this.db.execute(sql`
      CREATE TABLE IF NOT EXISTS migrations._migrations (
        id SERIAL PRIMARY KEY,
        plugin_name TEXT NOT NULL,
        hash TEXT NOT NULL,
        created_at BIGINT NOT NULL
      )
    `);
    await this.db.execute(sql`
      CREATE TABLE IF NOT EXISTS migrations._journal (
        plugin_name TEXT PRIMARY KEY,
        version TEXT NOT NULL,
        dialect TEXT NOT NULL DEFAULT 'postgresql',
        entries JSONB NOT NULL DEFAULT '[]'
      )
    `);
    await this.db.execute(sql`
      CREATE TABLE IF NOT EXISTS migrations._snapshots (
        id SERIAL PRIMARY KEY,
        plugin_name TEXT NOT NULL,
        idx INTEGER NOT NULL,
        snapshot JSONB NOT NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(plugin_name, idx)
      )
    `);
  }
  async getLastMigration(pluginName) {
    const result = await this.db.execute(sql`SELECT id, hash, created_at 
          FROM migrations._migrations 
          WHERE plugin_name = ${pluginName} 
          ORDER BY created_at DESC 
          LIMIT 1`);
    return result.rows[0] || null;
  }
  async recordMigration(pluginName, hash, createdAt) {
    await this.db.execute(sql`INSERT INTO migrations._migrations (plugin_name, hash, created_at) 
          VALUES (${pluginName}, ${hash}, ${createdAt})`);
  }
}
var init_migration_tracker = __esm(() => {
  init_drizzle_orm();
});

// src/runtime-migrator/storage/journal-storage.ts
class JournalStorage {
  db;
  constructor(db2) {
    this.db = db2;
  }
  async loadJournal(pluginName) {
    const result = await this.db.execute(sql`SELECT version, dialect, entries 
          FROM migrations._journal 
          WHERE plugin_name = ${pluginName}`);
    if (result.rows.length === 0) {
      return null;
    }
    const row = result.rows[0];
    return {
      version: row.version,
      dialect: row.dialect,
      entries: row.entries
    };
  }
  async saveJournal(pluginName, journal) {
    await this.db.execute(sql`INSERT INTO migrations._journal (plugin_name, version, dialect, entries)
          VALUES (${pluginName}, ${journal.version}, ${journal.dialect}, ${JSON.stringify(journal.entries)}::jsonb)
          ON CONFLICT (plugin_name) 
          DO UPDATE SET 
            version = EXCLUDED.version,
            dialect = EXCLUDED.dialect,
            entries = EXCLUDED.entries`);
  }
  async addEntry(pluginName, entry) {
    let journal = await this.loadJournal(pluginName);
    if (!journal) {
      journal = {
        version: "7",
        dialect: "postgresql",
        entries: []
      };
    }
    journal.entries.push(entry);
    await this.saveJournal(pluginName, journal);
  }
  async getNextIdx(pluginName) {
    const journal = await this.loadJournal(pluginName);
    if (!journal || journal.entries.length === 0) {
      return 0;
    }
    const lastEntry = journal.entries[journal.entries.length - 1];
    return lastEntry.idx + 1;
  }
  async updateJournal(pluginName, idx, tag, breakpoints = true) {
    const entry = {
      idx,
      version: "7",
      when: Date.now(),
      tag,
      breakpoints
    };
    await this.addEntry(pluginName, entry);
  }
}
var init_journal_storage = __esm(() => {
  init_drizzle_orm();
});

// src/runtime-migrator/storage/snapshot-storage.ts
class SnapshotStorage {
  db;
  constructor(db2) {
    this.db = db2;
  }
  async saveSnapshot(pluginName, idx, snapshot) {
    await this.db.execute(sql`INSERT INTO migrations._snapshots (plugin_name, idx, snapshot)
          VALUES (${pluginName}, ${idx}, ${JSON.stringify(snapshot)}::jsonb)
          ON CONFLICT (plugin_name, idx) 
          DO UPDATE SET 
            snapshot = EXCLUDED.snapshot,
            created_at = NOW()`);
  }
  async loadSnapshot(pluginName, idx) {
    const result = await this.db.execute(sql`SELECT snapshot 
          FROM migrations._snapshots 
          WHERE plugin_name = ${pluginName} AND idx = ${idx}`);
    if (result.rows.length === 0) {
      return null;
    }
    return result.rows[0].snapshot;
  }
  async getLatestSnapshot(pluginName) {
    const result = await this.db.execute(sql`SELECT snapshot 
          FROM migrations._snapshots 
          WHERE plugin_name = ${pluginName}
          ORDER BY idx DESC
          LIMIT 1`);
    if (result.rows.length === 0) {
      return null;
    }
    return result.rows[0].snapshot;
  }
  async getAllSnapshots(pluginName) {
    const result = await this.db.execute(sql`SELECT snapshot 
          FROM migrations._snapshots 
          WHERE plugin_name = ${pluginName}
          ORDER BY idx ASC`);
    return result.rows.map((row) => row.snapshot);
  }
}
var init_snapshot_storage = __esm(() => {
  init_drizzle_orm();
});

// src/runtime-migrator/extension-manager.ts
import { logger as logger2 } from "@elizaos/core";

class ExtensionManager {
  db;
  constructor(db2) {
    this.db = db2;
  }
  async installRequiredExtensions(extensions) {
    for (const extension of extensions) {
      try {
        if (!/^[a-zA-Z0-9_-]+$/.test(extension)) {
          logger2.warn(`[RuntimeMigrator] Invalid extension name "${extension}" - contains invalid characters`);
          continue;
        }
        await this.db.execute(sql`CREATE EXTENSION IF NOT EXISTS ${sql.identifier(extension)}`);
        logger2.debug(`[RuntimeMigrator] Extension installed: ${extension}`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger2.warn(`[RuntimeMigrator] Could not install extension ${extension}: ${errorMessage}`);
      }
    }
  }
}
var init_extension_manager = __esm(() => {
  init_drizzle_orm();
});

// src/runtime-migrator/drizzle-adapters/snapshot-generator.ts
import { createHash } from "crypto";
function escapeSingleQuotes(str) {
  return str.replace(/'/g, "''");
}
function isPgArrayType(sqlType) {
  return sqlType.match(/.*\[\d*\].*|.*\[\].*/g) !== null;
}
function buildArrayString(array2, sqlType) {
  sqlType = sqlType.split("[")[0];
  const values = array2.map((value) => {
    if (typeof value === "number" || typeof value === "bigint") {
      return value.toString();
    } else if (typeof value === "boolean") {
      return value ? "true" : "false";
    } else if (Array.isArray(value)) {
      return buildArrayString(value, sqlType);
    } else if (value instanceof Date) {
      if (sqlType === "date") {
        return `"${value.toISOString().split("T")[0]}"`;
      } else if (sqlType === "timestamp") {
        return `"${value.toISOString().replace("T", " ").slice(0, 23)}"`;
      } else {
        return `"${value.toISOString()}"`;
      }
    } else if (typeof value === "object") {
      return `"${JSON.stringify(value).replaceAll('"', "\\\"")}"`;
    }
    return `"${value}"`;
  }).join(",");
  return `{${values}}`;
}
function extractTablesFromSchema(schema2) {
  const tables = [];
  const exports = Object.values(schema2);
  exports.forEach((t) => {
    if (is(t, PgTable)) {
      tables.push(t);
    }
  });
  return tables;
}
async function generateSnapshot(schema2) {
  const dialect2 = new PgDialect({ casing: undefined });
  const tables = {};
  const schemas = {};
  const enums = {};
  const pgTables = extractTablesFromSchema(schema2);
  for (const table3 of pgTables) {
    const config = getTableConfig(table3);
    const {
      name: tableName,
      columns: columns2,
      indexes: indexes2,
      foreignKeys,
      schema: tableSchema,
      primaryKeys,
      uniqueConstraints,
      checks: checks2
    } = config;
    const columnsObject = {};
    const indexesObject = {};
    const foreignKeysObject = {};
    const primaryKeysObject = {};
    const uniqueConstraintObject = {};
    const checksObject = {};
    columns2.forEach((column2) => {
      const name = column2.name;
      const notNull = column2.notNull;
      const primaryKey2 = column2.primary;
      const sqlType = column2.getSQLType();
      const sqlTypeLowered = sqlType.toLowerCase();
      const columnToSet = {
        name,
        type: sqlType,
        primaryKey: primaryKey2,
        notNull
      };
      if (column2.default !== undefined) {
        if (is(column2.default, SQL)) {
          columnToSet.default = sqlToStr(column2.default, undefined);
        } else {
          if (typeof column2.default === "string") {
            columnToSet.default = `'${escapeSingleQuotes(column2.default)}'`;
          } else {
            if (sqlTypeLowered === "jsonb" || sqlTypeLowered === "json") {
              columnToSet.default = `'${JSON.stringify(column2.default)}'::${sqlTypeLowered}`;
            } else if (column2.default instanceof Date) {
              if (sqlTypeLowered === "date") {
                columnToSet.default = `'${column2.default.toISOString().split("T")[0]}'`;
              } else if (sqlTypeLowered === "timestamp") {
                columnToSet.default = `'${column2.default.toISOString().replace("T", " ").slice(0, 23)}'`;
              } else {
                columnToSet.default = `'${column2.default.toISOString()}'`;
              }
            } else if (isPgArrayType(sqlTypeLowered) && Array.isArray(column2.default)) {
              columnToSet.default = `'${buildArrayString(column2.default, sqlTypeLowered)}'`;
            } else {
              columnToSet.default = column2.default;
            }
          }
        }
      }
      if (column2.isUnique && column2.config?.uniqueName) {
        uniqueConstraintObject[column2.config.uniqueName] = {
          name: column2.config.uniqueName,
          columns: [name],
          nullsNotDistinct: column2.config?.uniqueType === "not distinct"
        };
      }
      columnsObject[name] = columnToSet;
    });
    primaryKeys.forEach((pk) => {
      const columnNames = pk.columns.map((c) => c.name);
      const name = pk.getName();
      primaryKeysObject[name] = {
        name,
        columns: columnNames
      };
    });
    uniqueConstraints?.forEach((unq) => {
      const columnNames = unq.columns.map((c) => c.name);
      const name = unq.name || `${tableName}_${columnNames.join("_")}_unique`;
      uniqueConstraintObject[name] = {
        name,
        columns: columnNames,
        nullsNotDistinct: unq.nullsNotDistinct
      };
    });
    foreignKeys.forEach((fk) => {
      const reference = fk.reference();
      const columnsFrom = reference.columns.map((it) => it.name);
      const columnsTo = reference.foreignColumns.map((it) => it.name);
      const tableTo = getTableConfig(reference.foreignTable).name;
      const schemaTo = getTableConfig(reference.foreignTable).schema || "public";
      const name = fk.getName();
      foreignKeysObject[name] = {
        name,
        tableFrom: tableName,
        schemaFrom: tableSchema,
        tableTo,
        schemaTo,
        columnsFrom,
        columnsTo,
        onDelete: fk.onDelete || "no action",
        onUpdate: fk.onUpdate || "no action"
      };
    });
    indexes2.forEach((idx) => {
      const columns3 = idx.config.columns;
      const indexColumns = columns3.map((col) => {
        if (is(col, SQL)) {
          return {
            expression: dialect2.sqlToQuery(col).sql,
            isExpression: true
          };
        } else {
          const indexCol = {
            expression: col.name,
            isExpression: false,
            asc: col.indexConfig?.order === "asc"
          };
          if (col.indexConfig?.nulls) {
            indexCol.nulls = col.indexConfig.nulls;
          }
          return indexCol;
        }
      });
      const name = idx.config.name || `${tableName}_${indexColumns.map((c) => c.expression).join("_")}_index`;
      indexesObject[name] = {
        name,
        columns: indexColumns,
        isUnique: idx.config.unique || false,
        method: idx.config.method || "btree"
      };
    });
    if (checks2) {
      checks2.forEach((check2) => {
        const checkName = check2.name;
        checksObject[checkName] = {
          name: checkName,
          value: dialect2.sqlToQuery(check2.value).sql
        };
      });
    }
    tables[`${tableSchema || "public"}.${tableName}`] = {
      name: tableName,
      schema: tableSchema || "public",
      columns: columnsObject,
      indexes: indexesObject,
      foreignKeys: foreignKeysObject,
      compositePrimaryKeys: primaryKeysObject,
      uniqueConstraints: uniqueConstraintObject,
      checkConstraints: checksObject
    };
    if (tableSchema && tableSchema !== "public") {
      schemas[tableSchema] = tableSchema;
    }
  }
  const snapshot = {
    version: "7",
    dialect: "postgresql",
    tables,
    schemas,
    enums,
    _meta: {
      schemas: {},
      tables: {},
      columns: {}
    }
  };
  return snapshot;
}
function hashSnapshot(snapshot) {
  const content = JSON.stringify(snapshot);
  return createHash("sha256").update(content).digest("hex");
}
function hasChanges(previousSnapshot, currentSnapshot) {
  if (!previousSnapshot) {
    return Object.keys(currentSnapshot.tables).length > 0;
  }
  const prevHash = hashSnapshot(previousSnapshot);
  const currHash = hashSnapshot(currentSnapshot);
  return prevHash !== currHash;
}
var sqlToStr = (sql4, casing) => {
  return sql4.toQuery({
    escapeName: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    escapeParam: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    escapeString: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    casing
  }).sql;
};
var init_snapshot_generator = __esm(() => {
  init_drizzle_orm();
  init_pg_core();
});

// src/runtime-migrator/drizzle-adapters/diff-calculator.ts
var exports_diff_calculator = {};
__export(exports_diff_calculator, {
  hasDiffChanges: () => hasDiffChanges,
  calculateDiff: () => calculateDiff
});
function normalizeType(type) {
  if (!type)
    return "";
  const normalized = type.toLowerCase().trim();
  if (normalized === "timestamp without time zone" || normalized === "timestamp with time zone") {
    return "timestamp";
  }
  if (normalized === "serial") {
    return "integer";
  }
  if (normalized === "bigserial") {
    return "bigint";
  }
  if (normalized === "smallserial") {
    return "smallint";
  }
  if (normalized.startsWith("numeric") || normalized.startsWith("decimal")) {
    const match = normalized.match(/\((\d+)(?:,\s*(\d+))?\)/);
    if (match) {
      return `numeric(${match[1]}${match[2] ? `,${match[2]}` : ""})`;
    }
    return "numeric";
  }
  if (normalized.startsWith("character varying")) {
    return normalized.replace("character varying", "varchar");
  }
  if (normalized === "text[]" || normalized === "_text") {
    return "text[]";
  }
  return normalized;
}
function isIndexChanged(prevIndex, currIndex) {
  if (prevIndex.isUnique !== currIndex.isUnique)
    return true;
  if (prevIndex.method !== currIndex.method)
    return true;
  if (prevIndex.where !== currIndex.where)
    return true;
  if (prevIndex.concurrently !== currIndex.concurrently)
    return true;
  const prevColumns = prevIndex.columns || [];
  const currColumns = currIndex.columns || [];
  if (prevColumns.length !== currColumns.length)
    return true;
  for (let i = 0;i < prevColumns.length; i++) {
    const prevCol = prevColumns[i];
    const currCol = currColumns[i];
    if (typeof prevCol === "string" && typeof currCol === "string") {
      if (prevCol !== currCol)
        return true;
    } else if (typeof prevCol === "object" && typeof currCol === "object") {
      if (prevCol.expression !== currCol.expression)
        return true;
      if (prevCol.isExpression !== currCol.isExpression)
        return true;
      if (prevCol.asc !== currCol.asc)
        return true;
      if (prevCol.nulls !== currCol.nulls)
        return true;
    } else {
      return true;
    }
  }
  return false;
}
async function calculateDiff(previousSnapshot, currentSnapshot) {
  const diff = {
    tables: {
      created: [],
      deleted: [],
      modified: []
    },
    columns: {
      added: [],
      deleted: [],
      modified: []
    },
    indexes: {
      created: [],
      deleted: [],
      altered: []
    },
    foreignKeys: {
      created: [],
      deleted: [],
      altered: []
    },
    uniqueConstraints: {
      created: [],
      deleted: []
    },
    checkConstraints: {
      created: [],
      deleted: []
    }
  };
  if (!previousSnapshot) {
    diff.tables.created = Object.keys(currentSnapshot.tables);
    for (const tableName in currentSnapshot.tables) {
      const table3 = currentSnapshot.tables[tableName];
      if (table3.indexes) {
        for (const indexName in table3.indexes) {
          diff.indexes.created.push({
            ...table3.indexes[indexName],
            table: tableName
          });
        }
      }
      if (table3.foreignKeys) {
        for (const fkName in table3.foreignKeys) {
          diff.foreignKeys.created.push(table3.foreignKeys[fkName]);
        }
      }
    }
    return diff;
  }
  const prevTables = previousSnapshot.tables || {};
  const currTables = currentSnapshot.tables || {};
  for (const tableName in currTables) {
    if (!(tableName in prevTables)) {
      diff.tables.created.push(tableName);
      const table3 = currTables[tableName];
      if (table3.indexes) {
        for (const indexName in table3.indexes) {
          diff.indexes.created.push({
            ...table3.indexes[indexName],
            table: tableName
          });
        }
      }
      if (table3.uniqueConstraints) {
        for (const uqName in table3.uniqueConstraints) {
          diff.uniqueConstraints.created.push({
            ...table3.uniqueConstraints[uqName],
            table: tableName
          });
        }
      }
      if (table3.checkConstraints) {
        for (const checkName in table3.checkConstraints) {
          diff.checkConstraints.created.push({
            ...table3.checkConstraints[checkName],
            table: tableName
          });
        }
      }
      if (table3.foreignKeys) {
        for (const fkName in table3.foreignKeys) {
          diff.foreignKeys.created.push(table3.foreignKeys[fkName]);
        }
      }
    }
  }
  for (const tableName in prevTables) {
    if (!(tableName in currTables)) {
      diff.tables.deleted.push(tableName);
    }
  }
  for (const tableName in currTables) {
    if (tableName in prevTables) {
      const prevTable = prevTables[tableName];
      const currTable = currTables[tableName];
      const prevTableJson = JSON.stringify({
        columns: prevTable.columns || {},
        indexes: prevTable.indexes || {},
        foreignKeys: prevTable.foreignKeys || {},
        uniqueConstraints: prevTable.uniqueConstraints || {},
        checkConstraints: prevTable.checkConstraints || {}
      });
      const currTableJson = JSON.stringify({
        columns: currTable.columns || {},
        indexes: currTable.indexes || {},
        foreignKeys: currTable.foreignKeys || {},
        uniqueConstraints: currTable.uniqueConstraints || {},
        checkConstraints: currTable.checkConstraints || {}
      });
      if (prevTableJson === currTableJson) {
        continue;
      }
      const prevColumns = prevTable.columns || {};
      const currColumns = currTable.columns || {};
      for (const colName in currColumns) {
        if (!(colName in prevColumns)) {
          diff.columns.added.push({
            table: tableName,
            column: colName,
            definition: currColumns[colName]
          });
        }
      }
      for (const colName in prevColumns) {
        if (!(colName in currColumns)) {
          diff.columns.deleted.push({
            table: tableName,
            column: colName
          });
        }
      }
      for (const colName in currColumns) {
        if (colName in prevColumns) {
          const prevCol = prevColumns[colName];
          const currCol = currColumns[colName];
          const typeChanged = normalizeType(prevCol.type) !== normalizeType(currCol.type);
          const hasChanges2 = typeChanged || prevCol.notNull !== currCol.notNull || prevCol.default !== currCol.default || prevCol.primaryKey !== currCol.primaryKey;
          if (hasChanges2) {
            diff.columns.modified.push({
              table: tableName,
              column: colName,
              changes: {
                from: prevCol,
                to: currCol
              }
            });
          }
        }
      }
      const prevIndexes = prevTable.indexes || {};
      const currIndexes = currTable.indexes || {};
      for (const indexName in currIndexes) {
        if (!(indexName in prevIndexes)) {
          diff.indexes.created.push({
            ...currIndexes[indexName],
            table: tableName
          });
        } else {
          const prevIndex = prevIndexes[indexName];
          const currIndex = currIndexes[indexName];
          const indexChanged = isIndexChanged(prevIndex, currIndex);
          if (indexChanged) {
            diff.indexes.altered.push({
              old: {
                ...prevIndex,
                table: tableName,
                name: indexName
              },
              new: {
                ...currIndex,
                table: tableName,
                name: indexName
              }
            });
          }
        }
      }
      for (const indexName in prevIndexes) {
        if (!(indexName in currIndexes)) {
          diff.indexes.deleted.push({
            name: indexName,
            table: tableName
          });
        }
      }
      const prevUniqueConstraints = prevTable.uniqueConstraints || {};
      const currUniqueConstraints = currTable.uniqueConstraints || {};
      for (const uqName in currUniqueConstraints) {
        if (!(uqName in prevUniqueConstraints)) {
          diff.uniqueConstraints.created.push({
            ...currUniqueConstraints[uqName],
            table: tableName
          });
        }
      }
      for (const uqName in prevUniqueConstraints) {
        if (!(uqName in currUniqueConstraints)) {
          diff.uniqueConstraints.deleted.push({
            name: uqName,
            table: tableName
          });
        }
      }
      const prevCheckConstraints = prevTable.checkConstraints || {};
      const currCheckConstraints = currTable.checkConstraints || {};
      for (const checkName in currCheckConstraints) {
        if (!(checkName in prevCheckConstraints)) {
          diff.checkConstraints.created.push({
            ...currCheckConstraints[checkName],
            table: tableName
          });
        }
      }
      for (const checkName in prevCheckConstraints) {
        if (!(checkName in currCheckConstraints)) {
          diff.checkConstraints.deleted.push({
            name: checkName,
            table: tableName
          });
        }
      }
      const prevFKs = prevTable.foreignKeys || {};
      const currFKs = currTable.foreignKeys || {};
      for (const fkName in currFKs) {
        if (!(fkName in prevFKs)) {
          diff.foreignKeys.created.push(currFKs[fkName]);
        } else {
          const prevFK = prevFKs[fkName];
          const currFK = currFKs[fkName];
          const prevOnDelete = prevFK.onDelete || "no action";
          const currOnDelete = currFK.onDelete || "no action";
          const prevOnUpdate = prevFK.onUpdate || "no action";
          const currOnUpdate = currFK.onUpdate || "no action";
          if (prevOnDelete !== currOnDelete || prevOnUpdate !== currOnUpdate) {
            diff.foreignKeys.altered.push({
              old: prevFK,
              new: currFK
            });
          }
        }
      }
      for (const fkName in prevFKs) {
        if (!(fkName in currFKs)) {
          diff.foreignKeys.deleted.push({
            name: fkName,
            tableFrom: tableName
          });
        }
      }
    }
  }
  return diff;
}
function hasDiffChanges(diff) {
  return diff.tables.created.length > 0 || diff.tables.deleted.length > 0 || diff.tables.modified.length > 0 || diff.columns.added.length > 0 || diff.columns.deleted.length > 0 || diff.columns.modified.length > 0 || diff.indexes.created.length > 0 || diff.indexes.deleted.length > 0 || diff.indexes.altered.length > 0 || diff.foreignKeys.created.length > 0 || diff.foreignKeys.deleted.length > 0 || diff.foreignKeys.altered.length > 0 || diff.uniqueConstraints.created.length > 0 || diff.uniqueConstraints.deleted.length > 0 || diff.checkConstraints.created.length > 0 || diff.checkConstraints.deleted.length > 0;
}

// src/runtime-migrator/drizzle-adapters/sql-generator.ts
import { logger as logger3 } from "@elizaos/core";
function checkForDataLoss(diff) {
  const result = {
    hasDataLoss: false,
    tablesToRemove: [],
    columnsToRemove: [],
    tablesToTruncate: [],
    typeChanges: [],
    warnings: [],
    requiresConfirmation: false
  };
  if (diff.tables.deleted.length > 0) {
    result.hasDataLoss = true;
    result.requiresConfirmation = true;
    result.tablesToRemove = [...diff.tables.deleted];
    for (const table3 of diff.tables.deleted) {
      result.warnings.push(`Table "${table3}" will be dropped with all its data`);
    }
  }
  if (diff.columns.deleted.length > 0) {
    result.hasDataLoss = true;
    result.requiresConfirmation = true;
    for (const col of diff.columns.deleted) {
      result.columnsToRemove.push(`${col.table}.${col.column}`);
      result.warnings.push(`Column "${col.column}" in table "${col.table}" will be dropped`);
    }
  }
  for (const modified of diff.columns.modified) {
    const from = modified.changes.from;
    const to = modified.changes.to;
    if (from.type !== to.type) {
      const isDestructive = checkIfTypeChangeIsDestructive(from.type, to.type);
      if (isDestructive) {
        result.hasDataLoss = true;
        result.requiresConfirmation = true;
        result.typeChanges.push({
          table: modified.table,
          column: modified.column,
          from: from.type,
          to: to.type
        });
        result.tablesToTruncate.push(modified.table);
        result.warnings.push(`Column "${modified.column}" in table "${modified.table}" changes type from "${from.type}" to "${to.type}". ` + `This may require truncating the table to avoid data conversion errors.`);
      }
    }
    if (!from.notNull && to.notNull && !to.default) {
      result.hasDataLoss = true;
      result.requiresConfirmation = true;
      result.warnings.push(`Column "${modified.column}" in table "${modified.table}" is becoming NOT NULL without a default value. ` + `This will fail if the table contains NULL values.`);
    }
  }
  for (const added of diff.columns.added) {
    if (added.definition.notNull && !added.definition.default) {
      result.warnings.push(`Column "${added.column}" is being added to table "${added.table}" as NOT NULL without a default value. ` + `This will fail if the table contains data.`);
    }
  }
  return result;
}
function normalizeType2(type) {
  if (!type)
    return "";
  const normalized = type.toLowerCase().trim();
  if (normalized === "timestamp without time zone" || normalized === "timestamp with time zone" || normalized === "timestamptz") {
    return "timestamp";
  }
  if (normalized === "serial") {
    return "integer";
  }
  if (normalized === "bigserial") {
    return "bigint";
  }
  if (normalized === "smallserial") {
    return "smallint";
  }
  if (normalized.startsWith("numeric") || normalized.startsWith("decimal")) {
    const match = normalized.match(/\((\d+)(?:,\s*(\d+))?\)/);
    if (match) {
      return `numeric(${match[1]}${match[2] ? `,${match[2]}` : ""})`;
    }
    return "numeric";
  }
  if (normalized.startsWith("character varying")) {
    return normalized.replace("character varying", "varchar");
  }
  if (normalized === "text[]" || normalized === "_text") {
    return "text[]";
  }
  return normalized;
}
function checkIfTypeChangeIsDestructive(fromType, toType) {
  const normalizedFrom = normalizeType2(fromType);
  const normalizedTo = normalizeType2(toType);
  if (normalizedFrom === normalizedTo) {
    return false;
  }
  const safeConversions = {
    smallint: ["integer", "bigint", "numeric", "real", "double precision"],
    integer: ["bigint", "numeric", "real", "double precision"],
    bigint: ["numeric"],
    real: ["double precision"],
    varchar: ["text"],
    char: ["varchar", "text"],
    citext: ["text"],
    text: ["citext"],
    uuid: ["text", "varchar"],
    timestamp: ["timestamp"],
    date: ["timestamp"],
    time: ["timetz"]
  };
  const fromBase = normalizedFrom.split("(")[0];
  const toBase = normalizedTo.split("(")[0];
  if (fromBase === toBase) {
    return false;
  }
  const safeTo = safeConversions[fromBase];
  if (safeTo && safeTo.includes(toBase)) {
    return false;
  }
  return true;
}
async function generateMigrationSQL(previousSnapshot, currentSnapshot, diff) {
  const statements = [];
  if (!diff) {
    const { calculateDiff: calculateDiff2 } = await Promise.resolve().then(() => exports_diff_calculator);
    diff = await calculateDiff2(previousSnapshot, currentSnapshot);
  }
  const dataLossCheck = checkForDataLoss(diff);
  if (dataLossCheck.warnings.length > 0) {
    logger3.warn("[RuntimeMigrator] Schema changes may cause data loss:");
    for (const warning of dataLossCheck.warnings) {
      logger3.warn(`  - ${warning}`);
    }
  }
  const schemasToCreate = new Set;
  for (const tableName of diff.tables.created) {
    const table3 = currentSnapshot.tables[tableName];
    if (table3) {
      const schema2 = table3.schema || "public";
      if (schema2 !== "public") {
        schemasToCreate.add(schema2);
      }
    }
  }
  for (const schema2 of schemasToCreate) {
    statements.push(`CREATE SCHEMA IF NOT EXISTS "${schema2}";`);
  }
  const createTableStatements = [];
  const foreignKeyStatements = [];
  for (const tableName of diff.tables.created) {
    const table3 = currentSnapshot.tables[tableName];
    if (table3) {
      const { tableSQL, fkSQLs } = generateCreateTableSQL(tableName, table3);
      createTableStatements.push(tableSQL);
      foreignKeyStatements.push(...fkSQLs);
    }
  }
  statements.push(...createTableStatements);
  const uniqueFKs = new Set;
  const dedupedFKStatements = [];
  for (const fkSQL of foreignKeyStatements) {
    const match = fkSQL.match(/ADD CONSTRAINT "([^"]+)"/);
    if (match) {
      const constraintName = match[1];
      if (!uniqueFKs.has(constraintName)) {
        uniqueFKs.add(constraintName);
        dedupedFKStatements.push(fkSQL);
      }
    } else {
      dedupedFKStatements.push(fkSQL);
    }
  }
  statements.push(...dedupedFKStatements);
  for (const tableName of diff.tables.deleted) {
    const [schema2, name] = tableName.includes(".") ? tableName.split(".") : ["public", tableName];
    statements.push(`DROP TABLE IF EXISTS "${schema2}"."${name}" CASCADE;`);
  }
  for (const added of diff.columns.added) {
    statements.push(generateAddColumnSQL(added.table, added.column, added.definition));
  }
  for (const deleted of diff.columns.deleted) {
    statements.push(generateDropColumnSQL(deleted.table, deleted.column));
  }
  for (const modified of diff.columns.modified) {
    const alterStatements = generateAlterColumnSQL(modified.table, modified.column, modified.changes);
    statements.push(...alterStatements);
  }
  for (const index2 of diff.indexes.deleted) {
    statements.push(generateDropIndexSQL(index2));
  }
  for (const alteredIndex of diff.indexes.altered) {
    statements.push(generateDropIndexSQL(alteredIndex.old));
  }
  for (const index2 of diff.indexes.created) {
    statements.push(generateCreateIndexSQL(index2));
  }
  for (const alteredIndex of diff.indexes.altered) {
    statements.push(generateCreateIndexSQL(alteredIndex.new));
  }
  for (const constraint of diff.uniqueConstraints.created) {
    const isNewTable = diff.tables.created.some((tableName) => {
      const [schema2, table3] = tableName.includes(".") ? tableName.split(".") : ["public", tableName];
      const constraintTable = constraint.table || "";
      const [constraintSchema, constraintTableName] = constraintTable.includes(".") ? constraintTable.split(".") : ["public", constraintTable];
      return table3 === constraintTableName && schema2 === constraintSchema;
    });
    if (!isNewTable) {
      statements.push(generateCreateUniqueConstraintSQL(constraint));
    }
  }
  for (const constraint of diff.uniqueConstraints.deleted) {
    statements.push(generateDropUniqueConstraintSQL(constraint));
  }
  for (const constraint of diff.checkConstraints.created) {
    const isNewTable = diff.tables.created.some((tableName) => {
      const [schema2, table3] = tableName.includes(".") ? tableName.split(".") : ["public", tableName];
      const constraintTable = constraint.table || "";
      const [constraintSchema, constraintTableName] = constraintTable.includes(".") ? constraintTable.split(".") : ["public", constraintTable];
      return table3 === constraintTableName && schema2 === constraintSchema;
    });
    if (!isNewTable) {
      statements.push(generateCreateCheckConstraintSQL(constraint));
    }
  }
  for (const constraint of diff.checkConstraints.deleted) {
    statements.push(generateDropCheckConstraintSQL(constraint));
  }
  for (const fk of diff.foreignKeys.deleted) {
    statements.push(generateDropForeignKeySQL(fk));
  }
  for (const alteredFK of diff.foreignKeys.altered) {
    statements.push(generateDropForeignKeySQL(alteredFK.old));
  }
  for (const fk of diff.foreignKeys.created) {
    const tableFrom = fk.tableFrom || "";
    const schemaFrom = fk.schemaFrom || "public";
    const isNewTable = diff.tables.created.some((tableName) => {
      const [createdSchema, createdTable] = tableName.includes(".") ? tableName.split(".") : ["public", tableName];
      return createdTable === tableFrom && createdSchema === schemaFrom;
    });
    if (!isNewTable) {
      statements.push(generateCreateForeignKeySQL(fk));
    }
  }
  for (const alteredFK of diff.foreignKeys.altered) {
    statements.push(generateCreateForeignKeySQL(alteredFK.new));
  }
  return statements;
}
function generateCreateTableSQL(fullTableName, table3) {
  const [schema2, tableName] = fullTableName.includes(".") ? fullTableName.split(".") : ["public", fullTableName];
  const columns2 = [];
  const fkSQLs = [];
  for (const [colName, colDef] of Object.entries(table3.columns || {})) {
    columns2.push(generateColumnDefinition(colName, colDef));
  }
  const primaryKeys = table3.compositePrimaryKeys || {};
  for (const [pkName, pkDef] of Object.entries(primaryKeys)) {
    const pk = pkDef;
    if (pk.columns && pk.columns.length > 0) {
      columns2.push(`CONSTRAINT "${pkName}" PRIMARY KEY (${pk.columns.map((c) => `"${c}"`).join(", ")})`);
    }
  }
  const uniqueConstraints = table3.uniqueConstraints || {};
  for (const [uqName, uqDef] of Object.entries(uniqueConstraints)) {
    const uq = uqDef;
    if (uq.columns && uq.columns.length > 0) {
      const uniqueDef = uq.nullsNotDistinct ? `CONSTRAINT "${uqName}" UNIQUE NULLS NOT DISTINCT (${uq.columns.map((c) => `"${c}"`).join(", ")})` : `CONSTRAINT "${uqName}" UNIQUE (${uq.columns.map((c) => `"${c}"`).join(", ")})`;
      columns2.push(uniqueDef);
    }
  }
  const checkConstraints = table3.checkConstraints || {};
  for (const [checkName, checkDef] of Object.entries(checkConstraints)) {
    const check2 = checkDef;
    if (check2.value) {
      columns2.push(`CONSTRAINT "${checkName}" CHECK (${check2.value})`);
    }
  }
  const tableSQL = `CREATE TABLE IF NOT EXISTS "${schema2}"."${tableName}" (
  ${columns2.join(`,
  `)}
);`;
  const foreignKeys = table3.foreignKeys || {};
  for (const [fkName, fkDef] of Object.entries(foreignKeys)) {
    const fk = fkDef;
    const fkSQL = `ALTER TABLE "${schema2}"."${tableName}" ADD CONSTRAINT "${fkName}" FOREIGN KEY (${fk.columnsFrom.map((c) => `"${c}"`).join(", ")}) REFERENCES "${fk.schemaTo || "public"}"."${fk.tableTo}" (${fk.columnsTo.map((c) => `"${c}"`).join(", ")})${fk.onDelete ? ` ON DELETE ${fk.onDelete}` : ""}${fk.onUpdate ? ` ON UPDATE ${fk.onUpdate}` : ""};`;
    fkSQLs.push(fkSQL);
  }
  return { tableSQL, fkSQLs };
}
function generateColumnDefinition(name, def) {
  let sql4 = `"${name}" ${def.type}`;
  if (def.primaryKey && !def.type.includes("SERIAL")) {
    sql4 += " PRIMARY KEY";
  }
  if (def.notNull) {
    sql4 += " NOT NULL";
  }
  if (def.default !== undefined) {
    const defaultValue = formatDefaultValue(def.default, def.type);
    sql4 += ` DEFAULT ${defaultValue}`;
  }
  return sql4;
}
function generateAddColumnSQL(table3, column2, definition) {
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  const tableNameWithSchema = `"${schema2}"."${tableName}"`;
  const parts = [`"${column2}"`];
  parts.push(definition.type);
  if (definition.primaryKey) {
    parts.push("PRIMARY KEY");
  }
  if (definition.default !== undefined) {
    const defaultValue = formatDefaultValue(definition.default, definition.type);
    if (defaultValue) {
      parts.push(`DEFAULT ${defaultValue}`);
    }
  }
  if (definition.generated) {
    parts.push(`GENERATED ALWAYS AS (${definition.generated}) STORED`);
  }
  if (definition.notNull) {
    parts.push("NOT NULL");
  }
  return `ALTER TABLE ${tableNameWithSchema} ADD COLUMN ${parts.join(" ")};`;
}
function generateDropColumnSQL(table3, column2) {
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  const tableNameWithSchema = `"${schema2}"."${tableName}"`;
  return `ALTER TABLE ${tableNameWithSchema} DROP COLUMN "${column2}" CASCADE;`;
}
function generateAlterColumnSQL(table3, column2, changes) {
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  const tableNameWithSchema = `"${schema2}"."${tableName}"`;
  const statements = [];
  if (changes.to?.type !== changes.from?.type) {
    const newType = changes.to?.type || "TEXT";
    const needsUsing = checkIfNeedsUsingClause(changes.from?.type, newType);
    if (needsUsing) {
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" TYPE ${newType} USING "${column2}"::text::${newType};`);
    } else {
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" SET DATA TYPE ${newType};`);
    }
  }
  if (changes.to?.notNull !== changes.from?.notNull) {
    if (changes.to?.notNull) {
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" SET NOT NULL;`);
    } else {
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" DROP NOT NULL;`);
    }
  }
  if (changes.to?.default !== changes.from?.default) {
    if (changes.to?.default !== undefined) {
      const defaultValue = formatDefaultValue(changes.to.default, changes.to?.type);
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" SET DEFAULT ${defaultValue};`);
    } else {
      statements.push(`ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${column2}" DROP DEFAULT;`);
    }
  }
  return statements;
}
function checkIfNeedsUsingClause(fromType, toType) {
  if (!fromType || !toType)
    return false;
  if (fromType.includes("enum") || toType.includes("enum")) {
    return true;
  }
  const fromBase = fromType.split("(")[0].toLowerCase();
  const toBase = toType.split("(")[0].toLowerCase();
  if ((fromBase === "text" || fromBase === "varchar" || fromBase === "character varying") && (toBase === "jsonb" || toBase === "json")) {
    return true;
  }
  const needsUsingPairs = [
    ["integer", "boolean"],
    ["boolean", "integer"],
    ["text", "integer"],
    ["text", "numeric"],
    ["text", "boolean"],
    ["text", "uuid"],
    ["text", "jsonb"],
    ["text", "json"],
    ["varchar", "integer"],
    ["varchar", "numeric"],
    ["varchar", "boolean"],
    ["varchar", "uuid"],
    ["varchar", "jsonb"],
    ["varchar", "json"],
    ["character varying", "jsonb"],
    ["character varying", "json"]
  ];
  for (const [from, to] of needsUsingPairs) {
    if (fromBase === from && toBase === to || fromBase === to && toBase === from) {
      return true;
    }
  }
  return false;
}
function formatDefaultValue(value, type) {
  if (value === null || value === "NULL") {
    return "NULL";
  }
  if (type && (type.toLowerCase().includes("boolean") || type.toLowerCase() === "bool")) {
    if (value === true || value === "true" || value === "t" || value === 1) {
      return "true";
    }
    if (value === false || value === "false" || value === "f" || value === 0) {
      return "false";
    }
  }
  if (type && type.match(/^(integer|bigint|smallint|numeric|decimal|real|double)/i)) {
    return String(value);
  }
  if (typeof value === "string") {
    if (value.includes("::")) {
      return value;
    }
    if (value.startsWith("'") && value.endsWith("'")) {
      return value;
    }
    if (value.match(/^\w+\(\)/i) || value.includes("(") && value.includes(")")) {
      return value;
    }
    if (value.toUpperCase().startsWith("CURRENT_")) {
      return value;
    }
    return `'${value.replace(/'/g, "''")}'`;
  }
  return String(value);
}
function generateCreateIndexSQL(index2) {
  const unique2 = index2.isUnique ? "UNIQUE " : "";
  const method = index2.method || "btree";
  const columns2 = index2.columns.map((c) => {
    if (c.isExpression) {
      return c.expression;
    }
    return `"${c.expression}"${c.asc === false ? " DESC" : ""}`;
  }).join(", ");
  const indexName = index2.name.includes(".") ? index2.name.split(".")[1] : index2.name;
  let tableRef;
  if (index2.table && index2.table.includes(".")) {
    const [schema2, table3] = index2.table.split(".");
    tableRef = `"${schema2}"."${table3}"`;
  } else {
    tableRef = `"${index2.table || ""}"`;
  }
  return `CREATE ${unique2}INDEX "${indexName}" ON ${tableRef} USING ${method} (${columns2});`;
}
function generateDropIndexSQL(index2) {
  const indexName = index2.name ? index2.name.includes(".") ? index2.name.split(".")[1] : index2.name : index2;
  return `DROP INDEX IF EXISTS "${indexName}";`;
}
function generateCreateForeignKeySQL(fk) {
  const schemaFrom = fk.schemaFrom || "public";
  const schemaTo = fk.schemaTo || "public";
  const tableFrom = fk.tableFrom;
  const columnsFrom = fk.columnsFrom.map((c) => `"${c}"`).join(", ");
  const columnsTo = fk.columnsTo.map((c) => `"${c}"`).join(", ");
  let sql4 = `ALTER TABLE "${schemaFrom}"."${tableFrom}" ADD CONSTRAINT "${fk.name}" FOREIGN KEY (${columnsFrom}) REFERENCES "${schemaTo}"."${fk.tableTo}" (${columnsTo})`;
  if (fk.onDelete) {
    sql4 += ` ON DELETE ${fk.onDelete}`;
  }
  if (fk.onUpdate) {
    sql4 += ` ON UPDATE ${fk.onUpdate}`;
  }
  return sql4 + ";";
}
function generateDropForeignKeySQL(fk) {
  const [schema2, tableName] = fk.tableFrom ? fk.tableFrom.includes(".") ? fk.tableFrom.split(".") : ["public", fk.tableFrom] : ["public", ""];
  return `ALTER TABLE "${schema2}"."${tableName}" DROP CONSTRAINT "${fk.name}";`;
}
function generateCreateUniqueConstraintSQL(constraint) {
  const table3 = constraint.table || "";
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  const name = constraint.name;
  const columns2 = constraint.columns.map((c) => `"${c}"`).join(", ");
  let sql4 = `ALTER TABLE "${schema2}"."${tableName}" ADD CONSTRAINT "${name}" UNIQUE`;
  if (constraint.nullsNotDistinct) {
    sql4 += ` NULLS NOT DISTINCT`;
  }
  sql4 += ` (${columns2});`;
  return sql4;
}
function generateDropUniqueConstraintSQL(constraint) {
  const table3 = constraint.table || "";
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  return `ALTER TABLE "${schema2}"."${tableName}" DROP CONSTRAINT "${constraint.name}";`;
}
function generateCreateCheckConstraintSQL(constraint) {
  const table3 = constraint.table || "";
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  const name = constraint.name;
  const value = constraint.value;
  return `ALTER TABLE "${schema2}"."${tableName}" ADD CONSTRAINT "${name}" CHECK (${value});`;
}
function generateDropCheckConstraintSQL(constraint) {
  const table3 = constraint.table || "";
  const [schema2, tableName] = table3.includes(".") ? table3.split(".") : ["public", table3];
  return `ALTER TABLE "${schema2}"."${tableName}" DROP CONSTRAINT "${constraint.name}";`;
}
var init_sql_generator = () => {};

// src/runtime-migrator/schema-transformer.ts
import { logger as logger4 } from "@elizaos/core";
function deriveSchemaName(pluginName) {
  let schemaName = pluginName.replace(/^@[^/]+\//, "").replace(/^plugin-/, "").toLowerCase();
  schemaName = normalizeSchemaName(schemaName);
  const reserved = ["public", "pg_catalog", "information_schema", "migrations"];
  if (!schemaName || reserved.includes(schemaName)) {
    schemaName = "plugin_" + normalizeSchemaName(pluginName.toLowerCase());
  }
  if (!/^[a-z]/.test(schemaName)) {
    schemaName = "p_" + schemaName;
  }
  if (schemaName.length > 63) {
    schemaName = schemaName.substring(0, 63);
  }
  return schemaName;
}
function normalizeSchemaName(input) {
  const chars = [];
  let prevWasUnderscore = false;
  for (let i = 0;i < input.length; i++) {
    const char3 = input[i];
    if (/[a-z0-9]/.test(char3)) {
      chars.push(char3);
      prevWasUnderscore = false;
    } else if (!prevWasUnderscore) {
      chars.push("_");
      prevWasUnderscore = true;
    }
  }
  const result = chars.join("");
  let start = 0;
  let end = result.length;
  while (start < end && result[start] === "_") {
    start++;
  }
  while (end > start && result[end - 1] === "_") {
    end--;
  }
  return result.slice(start, end);
}
var init_schema_transformer = () => {};

// src/runtime-migrator/drizzle-adapters/database-introspector.ts
import { logger as logger5 } from "@elizaos/core";

class DatabaseIntrospector {
  db;
  constructor(db2) {
    this.db = db2;
  }
  async introspectSchema(schemaName = "public") {
    logger5.info(`[DatabaseIntrospector] Starting introspection for schema: ${schemaName}`);
    const tables = {};
    const schemas = {};
    const enums = {};
    const allTables = await this.getTables(schemaName);
    for (const tableInfo of allTables) {
      const tableName = tableInfo.table_name;
      const tableSchema = tableInfo.table_schema || "public";
      logger5.debug(`[DatabaseIntrospector] Introspecting table: ${tableSchema}.${tableName}`);
      const columns2 = await this.getColumns(tableSchema, tableName);
      const columnsObject = {};
      const uniqueConstraintObject = {};
      for (const col of columns2) {
        columnsObject[col.column_name] = {
          name: col.column_name,
          type: col.data_type,
          primaryKey: col.is_primary || false,
          notNull: col.is_nullable === "NO",
          default: col.column_default ? this.parseDefault(col.column_default, col.data_type) : undefined
        };
      }
      const indexes2 = await this.getIndexes(tableSchema, tableName);
      const indexesObject = {};
      for (const idx of indexes2) {
        if (!idx.is_primary && !idx.is_unique_constraint) {
          indexesObject[idx.name] = {
            name: idx.name,
            columns: idx.columns.map((col) => ({
              expression: col,
              isExpression: false
            })),
            isUnique: idx.is_unique,
            method: idx.method || "btree"
          };
        }
      }
      const foreignKeys = await this.getForeignKeys(tableSchema, tableName);
      const foreignKeysObject = {};
      for (const fk of foreignKeys) {
        foreignKeysObject[fk.name] = {
          name: fk.name,
          tableFrom: tableName,
          schemaFrom: tableSchema,
          tableTo: fk.foreign_table_name,
          schemaTo: fk.foreign_table_schema || "public",
          columnsFrom: [fk.column_name],
          columnsTo: [fk.foreign_column_name],
          onDelete: fk.delete_rule?.toLowerCase() || "no action",
          onUpdate: fk.update_rule?.toLowerCase() || "no action"
        };
      }
      const primaryKeys = await this.getPrimaryKeys(tableSchema, tableName);
      const primaryKeysObject = {};
      for (const pk of primaryKeys) {
        primaryKeysObject[pk.name] = {
          name: pk.name,
          columns: pk.columns
        };
      }
      const uniqueConstraints = await this.getUniqueConstraints(tableSchema, tableName);
      for (const unq of uniqueConstraints) {
        uniqueConstraintObject[unq.name] = {
          name: unq.name,
          columns: unq.columns,
          nullsNotDistinct: false
        };
      }
      const checkConstraints = await this.getCheckConstraints(tableSchema, tableName);
      const checksObject = {};
      for (const check2 of checkConstraints) {
        checksObject[check2.name] = {
          name: check2.name,
          value: check2.definition
        };
      }
      tables[`${tableSchema}.${tableName}`] = {
        name: tableName,
        schema: tableSchema,
        columns: columnsObject,
        indexes: indexesObject,
        foreignKeys: foreignKeysObject,
        compositePrimaryKeys: primaryKeysObject,
        uniqueConstraints: uniqueConstraintObject,
        checkConstraints: checksObject
      };
      if (tableSchema && tableSchema !== "public") {
        schemas[tableSchema] = tableSchema;
      }
    }
    const enumsResult = await this.getEnums(schemaName);
    for (const enumInfo of enumsResult) {
      const key = `${enumInfo.schema}.${enumInfo.name}`;
      if (!enums[key]) {
        enums[key] = {
          name: enumInfo.name,
          schema: enumInfo.schema,
          values: []
        };
      }
      enums[key].values.push(enumInfo.value);
    }
    logger5.info(`[DatabaseIntrospector] Introspection complete. Found ${Object.keys(tables).length} tables`);
    return {
      version: "7",
      dialect: "postgresql",
      tables,
      schemas,
      enums,
      _meta: {
        schemas: {},
        tables: {},
        columns: {}
      }
    };
  }
  async getTables(schemaName) {
    const result = await this.db.execute(sql`SELECT 
            table_schema,
            table_name
          FROM information_schema.tables
          WHERE table_schema = ${schemaName}
            AND table_type = 'BASE TABLE'
          ORDER BY table_name`);
    return result.rows;
  }
  async getColumns(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT 
            a.attname AS column_name,
            CASE 
              WHEN a.attnotnull THEN 'NO'
              ELSE 'YES'
            END AS is_nullable,
            CASE 
              WHEN a.atttypid = ANY ('{int,int8,int2}'::regtype[]) 
              AND EXISTS (
                SELECT FROM pg_attrdef ad
                WHERE ad.adrelid = a.attrelid 
                AND ad.adnum = a.attnum 
                AND pg_get_expr(ad.adbin, ad.adrelid) = 'nextval(''' 
                    || pg_get_serial_sequence(a.attrelid::regclass::text, a.attname)::regclass || '''::regclass)'
              )
              THEN CASE a.atttypid
                WHEN 'int'::regtype THEN 'serial'
                WHEN 'int8'::regtype THEN 'bigserial'
                WHEN 'int2'::regtype THEN 'smallserial'
              END
              ELSE format_type(a.atttypid, a.atttypmod)
            END AS data_type,
            pg_get_expr(ad.adbin, ad.adrelid) AS column_default,
            CASE 
              WHEN con.contype = 'p' THEN true
              ELSE false
            END AS is_primary
          FROM pg_attribute a
          JOIN pg_class cls ON cls.oid = a.attrelid
          JOIN pg_namespace ns ON ns.oid = cls.relnamespace
          LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
          LEFT JOIN pg_constraint con ON con.conrelid = a.attrelid 
            AND a.attnum = ANY(con.conkey) 
            AND con.contype = 'p'
          WHERE 
            a.attnum > 0
            AND NOT a.attisdropped
            AND ns.nspname = ${schemaName}
            AND cls.relname = ${tableName}
          ORDER BY a.attnum`);
    return result.rows;
  }
  async getIndexes(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT 
            i.relname AS name,
            idx.indisunique AS is_unique,
            idx.indisprimary AS is_primary,
            con.contype = 'u' AS is_unique_constraint,
            ARRAY(
              SELECT a.attname
              FROM pg_attribute a
              WHERE a.attrelid = idx.indrelid
                AND a.attnum = ANY(idx.indkey::int[])
              ORDER BY a.attnum
            ) AS columns,
            am.amname AS method
          FROM pg_index idx
          JOIN pg_class i ON i.oid = idx.indexrelid
          JOIN pg_class c ON c.oid = idx.indrelid
          JOIN pg_namespace n ON n.oid = c.relnamespace
          JOIN pg_am am ON am.oid = i.relam
          LEFT JOIN pg_constraint con ON con.conindid = idx.indexrelid
          WHERE n.nspname = ${schemaName}
            AND c.relname = ${tableName}`);
    return result.rows;
  }
  async getForeignKeys(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT
            con.conname AS name,
            att.attname AS column_name,
            fnsp.nspname AS foreign_table_schema,
            frel.relname AS foreign_table_name,
            fatt.attname AS foreign_column_name,
            CASE con.confupdtype
              WHEN 'a' THEN 'NO ACTION'
              WHEN 'r' THEN 'RESTRICT'
              WHEN 'n' THEN 'SET NULL'
              WHEN 'c' THEN 'CASCADE'
              WHEN 'd' THEN 'SET DEFAULT'
            END AS update_rule,
            CASE con.confdeltype
              WHEN 'a' THEN 'NO ACTION'
              WHEN 'r' THEN 'RESTRICT'
              WHEN 'n' THEN 'SET NULL'
              WHEN 'c' THEN 'CASCADE'
              WHEN 'd' THEN 'SET DEFAULT'
            END AS delete_rule
          FROM pg_catalog.pg_constraint con
          JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid
          JOIN pg_catalog.pg_namespace nsp ON nsp.oid = con.connamespace
          LEFT JOIN pg_catalog.pg_attribute att ON att.attnum = ANY (con.conkey)
            AND att.attrelid = con.conrelid
          LEFT JOIN pg_catalog.pg_class frel ON frel.oid = con.confrelid
          LEFT JOIN pg_catalog.pg_namespace fnsp ON fnsp.oid = frel.relnamespace
          LEFT JOIN pg_catalog.pg_attribute fatt ON fatt.attnum = ANY (con.confkey)
            AND fatt.attrelid = con.confrelid
          WHERE con.contype = 'f'
            AND nsp.nspname = ${schemaName}
            AND rel.relname = ${tableName}`);
    return result.rows;
  }
  async getPrimaryKeys(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT 
            con.conname AS name,
            ARRAY(
              SELECT a.attname
              FROM pg_attribute a
              WHERE a.attrelid = con.conrelid
                AND a.attnum = ANY(con.conkey)
              ORDER BY a.attnum
            ) AS columns
          FROM pg_constraint con
          JOIN pg_class rel ON rel.oid = con.conrelid
          JOIN pg_namespace nsp ON nsp.oid = con.connamespace
          WHERE con.contype = 'p'
            AND nsp.nspname = ${schemaName}
            AND rel.relname = ${tableName}`);
    return result.rows;
  }
  async getUniqueConstraints(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT 
            con.conname AS name,
            ARRAY(
              SELECT a.attname
              FROM pg_attribute a
              WHERE a.attrelid = con.conrelid
                AND a.attnum = ANY(con.conkey)
              ORDER BY a.attnum
            ) AS columns
          FROM pg_constraint con
          JOIN pg_class rel ON rel.oid = con.conrelid
          JOIN pg_namespace nsp ON nsp.oid = con.connamespace
          WHERE con.contype = 'u'
            AND nsp.nspname = ${schemaName}
            AND rel.relname = ${tableName}`);
    return result.rows;
  }
  async getCheckConstraints(schemaName, tableName) {
    const result = await this.db.execute(sql`SELECT 
            con.conname AS name,
            pg_get_constraintdef(con.oid) AS definition
          FROM pg_constraint con
          JOIN pg_class rel ON rel.oid = con.conrelid
          JOIN pg_namespace nsp ON nsp.oid = con.connamespace
          WHERE con.contype = 'c'
            AND nsp.nspname = ${schemaName}
            AND rel.relname = ${tableName}`);
    return result.rows;
  }
  async getEnums(schemaName) {
    const result = await this.db.execute(sql`SELECT 
            n.nspname AS schema,
            t.typname AS name,
            e.enumlabel AS value,
            e.enumsortorder AS sort_order
          FROM pg_type t
          JOIN pg_enum e ON t.oid = e.enumtypid
          JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
          WHERE n.nspname = ${schemaName}
          ORDER BY schema, name, sort_order`);
    return result.rows;
  }
  parseDefault(defaultValue, dataType) {
    if (!defaultValue)
      return;
    const match = defaultValue.match(/^'(.*)'::/);
    if (match) {
      return `'${match[1]}'`;
    }
    if (defaultValue.includes("nextval(")) {
      return;
    }
    if (dataType === "boolean") {
      if (defaultValue === "true")
        return "true";
      if (defaultValue === "false")
        return "false";
    }
    return defaultValue;
  }
  async hasExistingTables(pluginName) {
    const schemaName = pluginName === "@elizaos/plugin-sql" ? "public" : this.deriveSchemaName(pluginName);
    const result = await this.db.execute(sql`SELECT COUNT(*) AS count
          FROM information_schema.tables
          WHERE table_schema = ${schemaName}
            AND table_type = 'BASE TABLE'`);
    const count2 = parseInt(result.rows[0]?.count || "0", 10);
    return count2 > 0;
  }
  deriveSchemaName(pluginName) {
    return pluginName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
  }
}
var init_database_introspector = __esm(() => {
  init_drizzle_orm();
});

// src/runtime-migrator/runtime-migrator.ts
import { logger as logger6 } from "@elizaos/core";
import { createHash as createHash2 } from "crypto";

class RuntimeMigrator {
  db;
  migrationTracker;
  journalStorage;
  snapshotStorage;
  extensionManager;
  introspector;
  constructor(db2) {
    this.db = db2;
    this.migrationTracker = new MigrationTracker(db2);
    this.journalStorage = new JournalStorage(db2);
    this.snapshotStorage = new SnapshotStorage(db2);
    this.extensionManager = new ExtensionManager(db2);
    this.introspector = new DatabaseIntrospector(db2);
  }
  getExpectedSchemaName(pluginName) {
    if (pluginName === "@elizaos/plugin-sql") {
      return "public";
    }
    return deriveSchemaName(pluginName);
  }
  async ensureSchemasExist(snapshot) {
    const schemasToCreate = new Set;
    for (const table3 of Object.values(snapshot.tables)) {
      const tableData = table3;
      const schema2 = tableData.schema || "public";
      if (schema2 !== "public") {
        schemasToCreate.add(schema2);
      }
    }
    for (const schema2 of Object.keys(snapshot.schemas || {})) {
      if (schema2 !== "public") {
        schemasToCreate.add(schema2);
      }
    }
    for (const schemaName of schemasToCreate) {
      logger6.debug(`[RuntimeMigrator] Ensuring schema '${schemaName}' exists`);
      await this.db.execute(sql.raw(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`));
    }
  }
  validateSchemaUsage(pluginName, snapshot) {
    const expectedSchema = this.getExpectedSchemaName(pluginName);
    const isCorePLugin = pluginName === "@elizaos/plugin-sql";
    for (const table3 of Object.values(snapshot.tables)) {
      const tableData = table3;
      const actualSchema = tableData.schema || "public";
      if (!isCorePLugin && actualSchema === "public") {
        logger6.warn(`[RuntimeMigrator] WARNING: Plugin '${pluginName}' table '${tableData.name}' is using public schema. ` + `Consider using pgSchema('${expectedSchema}').table(...) for better isolation.`);
      }
      if (isCorePLugin && actualSchema !== "public") {
        logger6.warn(`[RuntimeMigrator] WARNING: Core plugin '@elizaos/plugin-sql' table '${tableData.name}' is using schema '${actualSchema}'. ` + `Core tables should use public schema.`);
      }
    }
  }
  getAdvisoryLockId(pluginName) {
    const hash = createHash2("sha256").update(pluginName).digest();
    const buffer = hash.slice(0, 8);
    let lockId = BigInt("0x" + buffer.toString("hex"));
    const mask63Bits = 0x7fffffffffffffffn;
    lockId = lockId & mask63Bits;
    if (lockId === 0n) {
      lockId = 1n;
    }
    return lockId;
  }
  validateBigInt(value) {
    const MIN_BIGINT = -9223372036854775808n;
    const MAX_BIGINT = 9223372036854775807n;
    return value >= MIN_BIGINT && value <= MAX_BIGINT;
  }
  isRealPostgresDatabase(connectionUrl) {
    if (!connectionUrl || connectionUrl.trim() === "") {
      return false;
    }
    const trimmedUrl = connectionUrl.trim();
    const url = trimmedUrl.toLowerCase();
    const originalUrl = trimmedUrl;
    const nonPostgresSchemes = [
      "mysql://",
      "mysqli://",
      "mariadb://",
      "mongodb://",
      "mongodb+srv://"
    ];
    for (const scheme of nonPostgresSchemes) {
      if (url.startsWith(scheme)) {
        return false;
      }
    }
    const excludePatterns = [
      ":memory:",
      "pglite://",
      "/pglite",
      "sqlite://",
      "sqlite3://",
      ".sqlite",
      ".sqlite3",
      "file::memory:",
      "file:"
    ];
    const urlWithoutQuery = url.split("?")[0];
    if (urlWithoutQuery.endsWith(".db") || urlWithoutQuery.endsWith(".sqlite") || urlWithoutQuery.endsWith(".sqlite3")) {
      return false;
    }
    for (const pattern of excludePatterns) {
      if (url.includes(pattern)) {
        if (pattern === "file:" && url.includes("postgres")) {
          continue;
        }
        return false;
      }
    }
    const postgresSchemes = [
      "postgres://",
      "postgresql://",
      "postgis://",
      "pgbouncer://",
      "pgpool://",
      "cockroach://",
      "cockroachdb://",
      "redshift://",
      "timescaledb://",
      "yugabyte://"
    ];
    for (const scheme of postgresSchemes) {
      if (url.startsWith(scheme)) {
        return true;
      }
    }
    const connectionParams = [
      "host=",
      "dbname=",
      "sslmode=",
      "connect_timeout=",
      "application_name=",
      "user=",
      "password=",
      "port=",
      "options=",
      "sslcert=",
      "sslkey=",
      "sslrootcert="
    ];
    for (const param of connectionParams) {
      if (url.includes(param)) {
        return true;
      }
    }
    if (url.includes("@") && (url.includes("postgres") || /:\d{4,5}/.test(url))) {
      return true;
    }
    const postgresPorts = [
      ":5432",
      ":5433",
      ":5434",
      ":25060",
      ":26257",
      ":6432",
      ":9999",
      ":8432"
    ];
    for (const port of postgresPorts) {
      if (url.includes(port)) {
        return true;
      }
    }
    const cloudProviderPatterns = [
      "amazonaws.com",
      "rds.amazonaws.com",
      ".rds.",
      "redshift.amazonaws.com",
      "azure.com",
      "database.azure.com",
      "postgres.database.azure.com",
      "googleusercontent",
      "cloudsql",
      "cloud.google.com",
      "supabase",
      ".supabase.co",
      ".supabase.com",
      "pooler.supabase",
      "neon.tech",
      ".neon.tech",
      "neon.build",
      "railway.app",
      ".railway.app",
      "railway.internal",
      "render.com",
      ".render.com",
      "onrender.com",
      "heroku.com",
      "herokuapp.com",
      ".heroku.com",
      "timescale",
      "timescaledb",
      ".tsdb.cloud",
      "cockroachlabs",
      "cockroachdb.cloud",
      ".crdb.io",
      "digitalocean.com",
      "db.ondigitalocean",
      "do-user-",
      ".db.ondigitalocean.com",
      "aiven",
      "aivencloud",
      ".aiven.io",
      ".aivencloud.com",
      "crunchydata",
      ".crunchydata.com",
      "elephantsql",
      ".elephantsql.com",
      "yugabyte",
      ".yugabyte.cloud",
      "scaleway",
      ".rdb.fr-par.scw.cloud",
      "vercel-storage",
      ".postgres.vercel-storage.com",
      "psdb.cloud",
      ".psdb.cloud",
      "xata.sh",
      ".xata.sh",
      "fly.dev",
      ".fly.dev",
      "fly.io"
    ];
    for (const pattern of cloudProviderPatterns) {
      if (url.includes(pattern)) {
        return true;
      }
    }
    const ipv4PortPattern = /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5}\b/;
    if (ipv4PortPattern.test(originalUrl)) {
      return true;
    }
    const ipv6Pattern = /\[[0-9a-f:]+\](:\d{1,5})?/i;
    if (ipv6Pattern.test(originalUrl)) {
      return true;
    }
    const hostPortDbPattern = /^[a-z0-9.-]+:\d{1,5}\/[a-z0-9_-]+/i;
    if (hostPortDbPattern.test(originalUrl)) {
      return true;
    }
    if (url.includes("?") || url.includes("&")) {
      const postgresQueryParams = [
        "sslmode=",
        "sslcert=",
        "sslkey=",
        "sslrootcert=",
        "connect_timeout=",
        "application_name=",
        "options=",
        "fallback_application_name=",
        "keepalives=",
        "target_session_attrs="
      ];
      for (const param of postgresQueryParams) {
        if (url.includes(param)) {
          return true;
        }
      }
    }
    logger6.debug(`[RuntimeMigrator] Connection string did not match any PostgreSQL patterns: ${url.substring(0, 50)}...`);
    return false;
  }
  async initialize() {
    logger6.info("[RuntimeMigrator] Initializing migration system...");
    await this.migrationTracker.ensureTables();
    logger6.info("[RuntimeMigrator] Migration system initialized");
  }
  async migrate(pluginName, schema2, options = {}) {
    const lockId = this.getAdvisoryLockId(pluginName);
    if (!this.validateBigInt(lockId)) {
      throw new Error(`Invalid advisory lock ID generated for plugin ${pluginName}`);
    }
    let lockAcquired = false;
    try {
      logger6.info(`[RuntimeMigrator] Starting migration for plugin: ${pluginName}`);
      await this.initialize();
      const postgresUrl = process.env.POSTGRES_URL || process.env.DATABASE_URL || "";
      const isRealPostgres = this.isRealPostgresDatabase(postgresUrl);
      if (isRealPostgres) {
        try {
          logger6.debug(`[RuntimeMigrator] Using PostgreSQL advisory locks for ${pluginName}`);
          const lockIdStr = lockId.toString();
          const lockResult = await this.db.execute(sql`SELECT pg_try_advisory_lock(CAST(${lockIdStr} AS bigint)) as acquired`);
          lockAcquired = lockResult.rows[0]?.acquired === true;
          if (!lockAcquired) {
            logger6.info(`[RuntimeMigrator] Migration already in progress for ${pluginName}, waiting for lock...`);
            await this.db.execute(sql`SELECT pg_advisory_lock(CAST(${lockIdStr} AS bigint))`);
            lockAcquired = true;
            logger6.info(`[RuntimeMigrator] Lock acquired for ${pluginName}`);
          } else {
            logger6.debug(`[RuntimeMigrator] Advisory lock acquired for ${pluginName} (lock ID: ${lockIdStr})`);
          }
        } catch (lockError) {
          logger6.warn(`[RuntimeMigrator] Failed to acquire advisory lock, continuing without lock: ${lockError}`);
          lockAcquired = false;
        }
      } else {
        logger6.debug(`[RuntimeMigrator] Development database detected (PGLite or non-PostgreSQL), skipping advisory locks`);
      }
      await this.extensionManager.installRequiredExtensions(["vector", "fuzzystrmatch"]);
      const currentSnapshot = await generateSnapshot(schema2);
      await this.ensureSchemasExist(currentSnapshot);
      this.validateSchemaUsage(pluginName, currentSnapshot);
      const currentHash = hashSnapshot(currentSnapshot);
      const lastMigration = await this.migrationTracker.getLastMigration(pluginName);
      if (lastMigration && lastMigration.hash === currentHash) {
        logger6.info(`[RuntimeMigrator] No changes detected for ${pluginName}, skipping migration (hash: ${currentHash})`);
        return;
      }
      let previousSnapshot = await this.snapshotStorage.getLatestSnapshot(pluginName);
      if (!previousSnapshot && Object.keys(currentSnapshot.tables).length > 0) {
        const hasExistingTables = await this.introspector.hasExistingTables(pluginName);
        if (hasExistingTables) {
          logger6.info(`[RuntimeMigrator] No snapshot found for ${pluginName} but tables exist in database. Introspecting...`);
          const schemaName = this.getExpectedSchemaName(pluginName);
          const introspectedSnapshot = await this.introspector.introspectSchema(schemaName);
          if (Object.keys(introspectedSnapshot.tables).length > 0) {
            await this.snapshotStorage.saveSnapshot(pluginName, 0, introspectedSnapshot);
            await this.journalStorage.updateJournal(pluginName, 0, `introspected_${Date.now()}`, true);
            const introspectedHash = hashSnapshot(introspectedSnapshot);
            await this.migrationTracker.recordMigration(pluginName, introspectedHash, Date.now());
            logger6.info(`[RuntimeMigrator] Created initial snapshot from existing database for ${pluginName}`);
            previousSnapshot = introspectedSnapshot;
          }
        }
      }
      if (!hasChanges(previousSnapshot, currentSnapshot)) {
        logger6.info(`[RuntimeMigrator] No schema changes for ${pluginName}`);
        if (!previousSnapshot && Object.keys(currentSnapshot.tables).length === 0) {
          logger6.info(`[RuntimeMigrator] Recording empty schema for ${pluginName}`);
          await this.migrationTracker.recordMigration(pluginName, currentHash, Date.now());
          const idx = await this.journalStorage.getNextIdx(pluginName);
          const tag = this.generateMigrationTag(idx, pluginName);
          await this.journalStorage.updateJournal(pluginName, idx, tag, true);
          await this.snapshotStorage.saveSnapshot(pluginName, idx, currentSnapshot);
        }
        return;
      }
      const diff = await calculateDiff(previousSnapshot, currentSnapshot);
      if (!hasDiffChanges(diff)) {
        logger6.info(`[RuntimeMigrator] No actionable changes for ${pluginName}`);
        return;
      }
      const dataLossCheck = checkForDataLoss(diff);
      if (dataLossCheck.hasDataLoss) {
        const isProduction = false;
        const allowDestructive = options.force || options.allowDataLoss || process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS === "true";
        if (!allowDestructive) {
          logger6.error("[RuntimeMigrator] Destructive migration blocked");
          logger6.error(`[RuntimeMigrator] Plugin: ${pluginName}`);
          logger6.error(`[RuntimeMigrator] Environment: ${isProduction ? "PRODUCTION" : "DEVELOPMENT"}`);
          logger6.error("[RuntimeMigrator] Destructive operations detected:");
          for (const warning of dataLossCheck.warnings) {
            logger6.error(`[RuntimeMigrator]   - ${warning}`);
          }
          logger6.error("[RuntimeMigrator] To proceed with destructive migrations:");
          logger6.error("[RuntimeMigrator]   1. Set environment variable: export ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true");
          logger6.error("[RuntimeMigrator]   2. Or use option: migrate(plugin, schema, { force: true })");
          if (isProduction) {
            logger6.error("[RuntimeMigrator]   3. For production, consider using drizzle-kit for manual migration");
          }
          const errorMessage = isProduction ? `Destructive migration blocked in production for ${pluginName}. Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true or use drizzle-kit.` : `Destructive migration blocked for ${pluginName}. Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true to proceed.`;
          throw new Error(errorMessage);
        }
        if (dataLossCheck.requiresConfirmation) {
          logger6.warn("[RuntimeMigrator] Proceeding with destructive migration");
          logger6.warn(`[RuntimeMigrator] Plugin: ${pluginName}`);
          logger6.warn("[RuntimeMigrator] The following operations will be performed:");
          for (const warning of dataLossCheck.warnings) {
            logger6.warn(`[RuntimeMigrator]   ⚠️ ${warning}`);
          }
        }
      }
      const sqlStatements = await generateMigrationSQL(previousSnapshot, currentSnapshot, diff);
      if (sqlStatements.length === 0) {
        logger6.info(`[RuntimeMigrator] No SQL statements to execute for ${pluginName}`);
        return;
      }
      logger6.info(`[RuntimeMigrator] Executing ${sqlStatements.length} SQL statements for ${pluginName}`);
      if (options.verbose) {
        sqlStatements.forEach((stmt, i) => {
          logger6.debug(`[RuntimeMigrator] Statement ${i + 1}: ${stmt}`);
        });
      }
      if (options.dryRun) {
        logger6.info("[RuntimeMigrator] DRY RUN mode - not executing statements");
        logger6.info("[RuntimeMigrator] Would execute:");
        sqlStatements.forEach((stmt, i) => {
          logger6.info(`  ${i + 1}. ${stmt}`);
        });
        return;
      }
      await this.executeMigration(pluginName, currentSnapshot, currentHash, sqlStatements);
      logger6.info(`[RuntimeMigrator] Migration completed successfully for ${pluginName}`);
      return;
    } catch (error) {
      logger6.error(`[RuntimeMigrator] Migration failed for ${pluginName}:`, JSON.stringify(error));
      throw error;
    } finally {
      const postgresUrl = process.env.POSTGRES_URL || process.env.DATABASE_URL || "";
      const isRealPostgres = this.isRealPostgresDatabase(postgresUrl);
      if (lockAcquired && isRealPostgres) {
        try {
          const lockIdStr = lockId.toString();
          await this.db.execute(sql`SELECT pg_advisory_unlock(CAST(${lockIdStr} AS bigint))`);
          logger6.debug(`[RuntimeMigrator] Advisory lock released for ${pluginName}`);
        } catch (unlockError) {
          logger6.warn(`[RuntimeMigrator] Failed to release advisory lock for ${pluginName}:`, JSON.stringify(unlockError));
        }
      }
    }
  }
  async executeMigration(pluginName, snapshot, hash, sqlStatements) {
    let transactionStarted = false;
    try {
      await this.db.execute(sql`BEGIN`);
      transactionStarted = true;
      for (const stmt of sqlStatements) {
        logger6.debug(`[RuntimeMigrator] Executing: ${stmt}`);
        await this.db.execute(sql.raw(stmt));
      }
      const idx = await this.journalStorage.getNextIdx(pluginName);
      await this.migrationTracker.recordMigration(pluginName, hash, Date.now());
      const tag = this.generateMigrationTag(idx, pluginName);
      await this.journalStorage.updateJournal(pluginName, idx, tag, true);
      await this.snapshotStorage.saveSnapshot(pluginName, idx, snapshot);
      await this.db.execute(sql`COMMIT`);
      logger6.info(`[RuntimeMigrator] Recorded migration ${tag} for ${pluginName}`);
    } catch (error) {
      if (transactionStarted) {
        try {
          await this.db.execute(sql`ROLLBACK`);
          logger6.error("[RuntimeMigrator] Migration failed, rolled back:", JSON.stringify(error));
        } catch (rollbackError) {
          logger6.error("[RuntimeMigrator] Failed to rollback transaction:", JSON.stringify(rollbackError));
        }
      }
      throw error;
    }
  }
  generateMigrationTag(idx, pluginName) {
    const prefix = idx.toString().padStart(4, "0");
    const timestamp3 = Date.now().toString(36);
    return `${prefix}_${pluginName}_${timestamp3}`;
  }
  async getStatus(pluginName) {
    const lastMigration = await this.migrationTracker.getLastMigration(pluginName);
    const journal = await this.journalStorage.loadJournal(pluginName);
    const snapshots = await this.snapshotStorage.getAllSnapshots(pluginName);
    return {
      hasRun: !!lastMigration,
      lastMigration,
      journal,
      snapshots: snapshots.length
    };
  }
  async reset(pluginName) {
    logger6.warn(`[RuntimeMigrator] Resetting migrations for ${pluginName}`);
    await this.db.execute(sql`DELETE FROM migrations._migrations WHERE plugin_name = ${pluginName}`);
    await this.db.execute(sql`DELETE FROM migrations._journal WHERE plugin_name = ${pluginName}`);
    await this.db.execute(sql`DELETE FROM migrations._snapshots WHERE plugin_name = ${pluginName}`);
    logger6.warn(`[RuntimeMigrator] Reset complete for ${pluginName}`);
  }
  async checkMigration(pluginName, schema2) {
    try {
      logger6.info(`[RuntimeMigrator] Checking migration for ${pluginName}...`);
      const currentSnapshot = await generateSnapshot(schema2);
      const previousSnapshot = await this.snapshotStorage.getLatestSnapshot(pluginName);
      if (!hasChanges(previousSnapshot, currentSnapshot)) {
        logger6.info(`[RuntimeMigrator] No changes detected for ${pluginName}`);
        return null;
      }
      const diff = await calculateDiff(previousSnapshot, currentSnapshot);
      const dataLossCheck = checkForDataLoss(diff);
      if (dataLossCheck.hasDataLoss) {
        logger6.warn(`[RuntimeMigrator] Migration for ${pluginName} would cause data loss`);
      } else {
        logger6.info(`[RuntimeMigrator] Migration for ${pluginName} is safe (no data loss)`);
      }
      return dataLossCheck;
    } catch (error) {
      logger6.error(`[RuntimeMigrator] Failed to check migration for ${pluginName}:`, JSON.stringify(error));
      throw error;
    }
  }
}
var init_runtime_migrator = __esm(() => {
  init_drizzle_orm();
  init_migration_tracker();
  init_journal_storage();
  init_snapshot_storage();
  init_extension_manager();
  init_snapshot_generator();
  init_sql_generator();
  init_schema_transformer();
  init_database_introspector();
});

// src/runtime-migrator/index.ts
var init_runtime_migrator2 = __esm(() => {
  init_runtime_migrator();
});

// src/migration-service.ts
var exports_migration_service = {};
__export(exports_migration_service, {
  DatabaseMigrationService: () => DatabaseMigrationService
});
import { logger as logger7 } from "@elizaos/core";

class DatabaseMigrationService {
  db = null;
  registeredSchemas = new Map;
  migrator = null;
  constructor() {}
  async initializeWithDatabase(db2) {
    this.db = db2;
    this.migrator = new RuntimeMigrator(db2);
    await this.migrator.initialize();
    logger7.info("DatabaseMigrationService initialized with database and runtime migrator");
  }
  discoverAndRegisterPluginSchemas(plugins) {
    for (const plugin of plugins) {
      if (plugin.schema) {
        this.registeredSchemas.set(plugin.name, plugin.schema);
        logger7.info(`Registered schema for plugin: ${plugin.name}`);
      }
    }
    logger7.info(`Discovered ${this.registeredSchemas.size} plugin schemas out of ${plugins.length} plugins`);
  }
  registerSchema(pluginName, schema2) {
    this.registeredSchemas.set(pluginName, schema2);
    logger7.info(`Registered schema for plugin: ${pluginName}`);
  }
  async runAllPluginMigrations(options) {
    if (!this.db || !this.migrator) {
      throw new Error("Database or migrator not initialized in DatabaseMigrationService");
    }
    const isProduction = false;
    const migrationOptions = {
      verbose: options?.verbose ?? !isProduction,
      force: options?.force ?? false,
      dryRun: options?.dryRun ?? false
    };
    logger7.info("[DatabaseMigrationService] Starting migrations");
    logger7.info(`[DatabaseMigrationService] Environment: ${isProduction ? "PRODUCTION" : "DEVELOPMENT"}`);
    logger7.info(`[DatabaseMigrationService] Plugins to migrate: ${this.registeredSchemas.size}`);
    if (migrationOptions.dryRun) {
      logger7.info("[DatabaseMigrationService] DRY RUN mode - no changes will be applied");
    }
    let successCount = 0;
    let failureCount = 0;
    const errors2 = [];
    for (const [pluginName, schema2] of this.registeredSchemas) {
      try {
        await this.migrator.migrate(pluginName, schema2, migrationOptions);
        successCount++;
        logger7.info(`[DatabaseMigrationService] ✅ Completed: ${pluginName}`);
      } catch (error) {
        failureCount++;
        const errorMessage = error.message;
        errors2.push({ pluginName, error });
        if (errorMessage.includes("Destructive migration blocked")) {
          logger7.error(`[DatabaseMigrationService] ❌ Blocked: ${pluginName} (destructive changes detected)`);
          if (!migrationOptions.force && process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS !== "true") {
            logger7.error("[DatabaseMigrationService] To allow destructive migrations:");
            logger7.error("[DatabaseMigrationService]   - Set ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS=true");
            logger7.error("[DatabaseMigrationService]   - Or pass { force: true } to this method");
          }
        } else {
          logger7.error(`[DatabaseMigrationService] ❌ Failed: ${pluginName}`, JSON.stringify(error));
        }
      }
    }
    if (failureCount === 0) {
      logger7.info(`[DatabaseMigrationService] All ${successCount} migrations completed successfully`);
    } else {
      logger7.error(`[DatabaseMigrationService] Migrations failed: ${failureCount} failed, ${successCount} succeeded`);
      const errorSummary = errors2.map((e) => `${e.pluginName}: ${e.error.message}`).join(`
  `);
      throw new Error(`${failureCount} migration(s) failed:
  ${errorSummary}`);
    }
  }
  getMigrator() {
    return this.migrator;
  }
}
var init_migration_service = __esm(() => {
  init_runtime_migrator2();
});

// src/index.node.ts
import { logger as logger12 } from "@elizaos/core";

// src/pglite/adapter.ts
import { logger as logger9 } from "@elizaos/core";

// ../../node_modules/drizzle-orm/pglite/driver.js
init_entity();
init_logger();
init_db();
init_dialect();
init_relations();
init_utils();
import { PGlite } from "@electric-sql/pglite";

// ../../node_modules/drizzle-orm/pglite/session.js
init_entity();
init_logger();
init_pg_core();
init_session();
init_sql();
init_utils();
init_cache();
import { types } from "@electric-sql/pglite";

class PglitePreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      rowMode: "object",
      parsers: {
        [types.TIMESTAMP]: (value) => value,
        [types.TIMESTAMPTZ]: (value) => value,
        [types.INTERVAL]: (value) => value,
        [types.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
    this.queryConfig = {
      rowMode: "array",
      parsers: {
        [types.TIMESTAMP]: (value) => value,
        [types.TIMESTAMPTZ]: (value) => value,
        [types.INTERVAL]: (value) => value,
        [types.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
  }
  static [entityKind] = "PglitePreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    const { fields, client, queryConfig, joinsNotNullableMap, customResultMapper, queryString, rawQueryConfig } = this;
    if (!fields && !customResultMapper) {
      return this.queryWithCache(queryString, params, async () => {
        return await client.query(queryString, params, rawQueryConfig);
      });
    }
    const result = await this.queryWithCache(queryString, params, async () => {
      return await client.query(queryString, params, queryConfig);
    });
    return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    return this.queryWithCache(this.queryString, params, async () => {
      return await this.client.query(this.queryString, params, this.rawQueryConfig);
    }).then((result) => result.rows);
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class PgliteSession extends PgSession {
  constructor(client, dialect2, schema2, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema2;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "PgliteSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new PglitePreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    return this.client.transaction(async (client) => {
      const session2 = new PgliteSession(client, this.dialect, this.schema, this.options);
      const tx = new PgliteTransaction(this.dialect, session2, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
  async count(sql22) {
    const res = await this.execute(sql22);
    return Number(res["rows"][0]["count"]);
  }
}

class PgliteTransaction extends PgTransaction {
  static [entityKind] = "PgliteTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new PgliteTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// ../../node_modules/drizzle-orm/pglite/driver.js
class PgliteDriver {
  constructor(client, dialect2, options = {}) {
    this.client = client;
    this.dialect = dialect2;
    this.options = options;
  }
  static [entityKind] = "PgliteDriver";
  createSession(schema2) {
    return new PgliteSession(this.client, this.dialect, schema2, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class PgliteDatabase extends PgDatabase {
  static [entityKind] = "PgliteDatabase";
}
function construct(client, config = {}) {
  const dialect2 = new PgDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema2;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema2 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new PgliteDriver(client, dialect2, { logger, cache: config.cache });
  const session2 = driver.createSession(schema2);
  const db2 = new PgliteDatabase(dialect2, session2, schema2);
  db2.$client = client;
  db2.$cache = config.cache;
  if (db2.$cache) {
    db2.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db2;
}
function drizzle(...params) {
  if (params[0] === undefined || typeof params[0] === "string") {
    const instance = new PGlite(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { dataDir, ...options } = connection;
      const instance2 = new PGlite(dataDir, options);
      return construct(instance2, drizzleConfig);
    }
    const instance = new PGlite(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/base.ts
init_drizzle_orm();
import {
  ChannelType,
  DatabaseAdapter,
  logger as logger8
} from "@elizaos/core";
import { v4 } from "uuid";

// src/schema/embedding.ts
init_drizzle_orm();
init_pg_core();
import { VECTOR_DIMS } from "@elizaos/core";

// src/schema/memory.ts
init_drizzle_orm();
init_pg_core();

// src/schema/agent.ts
init_drizzle_orm();
init_pg_core();
var agentTable = pgTable("agents", {
  id: uuid("id").primaryKey().defaultRandom(),
  enabled: boolean("enabled").default(true).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).default(sql`now()`).notNull(),
  name: text("name").notNull(),
  username: text("username"),
  system: text("system").default(""),
  bio: jsonb("bio").$type().default(sql`'[]'::jsonb`),
  messageExamples: jsonb("message_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  postExamples: jsonb("post_examples").$type().default(sql`'[]'::jsonb`).notNull(),
  topics: jsonb("topics").$type().default(sql`'[]'::jsonb`).notNull(),
  adjectives: jsonb("adjectives").$type().default(sql`'[]'::jsonb`).notNull(),
  knowledge: jsonb("knowledge").$type().default(sql`'[]'::jsonb`).notNull(),
  plugins: jsonb("plugins").$type().default(sql`'[]'::jsonb`).notNull(),
  settings: jsonb("settings").$type().default(sql`'{}'::jsonb`).notNull(),
  style: jsonb("style").$type().default(sql`'{}'::jsonb`).notNull()
}, (table3) => {
  return {
    nameUnique: unique("name_unique").on(table3.name)
  };
});

// src/schema/entity.ts
init_drizzle_orm();
init_pg_core();
var entityTable = pgTable("entities", {
  id: uuid("id").notNull().primaryKey(),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  createdAt: timestamp("created_at").default(sql`now()`).notNull(),
  names: text("names").array().default(sql`'{}'::text[]`).notNull(),
  metadata: jsonb("metadata").default(sql`'{}'::jsonb`).notNull()
}, (table3) => {
  return {
    idAgentIdUnique: unique("id_agent_id_unique").on(table3.id, table3.agentId)
  };
});

// src/schema/room.ts
init_drizzle_orm();
init_pg_core();
var roomTable = pgTable("rooms", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  source: text("source").notNull(),
  type: text("type").notNull(),
  serverId: text("serverId"),
  worldId: uuid("worldId"),
  name: text("name"),
  metadata: jsonb("metadata"),
  channelId: text("channelId"),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});

// src/schema/memory.ts
var memoryTable = pgTable("memories", {
  id: uuid("id").primaryKey().notNull(),
  type: text("type").notNull(),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull(),
  content: jsonb("content").notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }).notNull(),
  roomId: uuid("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  worldId: uuid("worldId"),
  unique: boolean("unique").default(true).notNull(),
  metadata: jsonb("metadata").default({}).notNull()
}, (table3) => [
  index("idx_memories_type_room").on(table3.type, table3.roomId),
  index("idx_memories_world_id").on(table3.worldId),
  foreignKey({
    name: "fk_room",
    columns: [table3.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table3.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_agent",
    columns: [table3.agentId],
    foreignColumns: [agentTable.id]
  }).onDelete("cascade"),
  index("idx_memories_metadata_type").on(sql`((metadata->>'type'))`),
  index("idx_memories_document_id").on(sql`((metadata->>'documentId'))`),
  index("idx_fragments_order").on(sql`((metadata->>'documentId'))`, sql`((metadata->>'position'))`),
  check("fragment_metadata_check", sql`
            CASE 
                WHEN metadata->>'type' = 'fragment' THEN
                    metadata ? 'documentId' AND 
                    metadata ? 'position'
                ELSE true
            END
        `),
  check("document_metadata_check", sql`
            CASE 
                WHEN metadata->>'type' = 'document' THEN
                    metadata ? 'timestamp'
                ELSE true
            END
        `)
]);
var memoryRelations = relations(memoryTable, ({ one }) => ({
  embedding: one(embeddingTable)
}));

// src/schema/embedding.ts
var DIMENSION_MAP = {
  [VECTOR_DIMS.SMALL]: "dim384",
  [VECTOR_DIMS.MEDIUM]: "dim512",
  [VECTOR_DIMS.LARGE]: "dim768",
  [VECTOR_DIMS.XL]: "dim1024",
  [VECTOR_DIMS.XXL]: "dim1536",
  [VECTOR_DIMS.XXXL]: "dim3072"
};
var embeddingTable = pgTable("embeddings", {
  id: uuid("id").primaryKey().defaultRandom().notNull(),
  memoryId: uuid("memory_id").references(() => memoryTable.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").default(sql`now()`).notNull(),
  dim384: vector("dim_384", { dimensions: VECTOR_DIMS.SMALL }),
  dim512: vector("dim_512", { dimensions: VECTOR_DIMS.MEDIUM }),
  dim768: vector("dim_768", { dimensions: VECTOR_DIMS.LARGE }),
  dim1024: vector("dim_1024", { dimensions: VECTOR_DIMS.XL }),
  dim1536: vector("dim_1536", { dimensions: VECTOR_DIMS.XXL }),
  dim3072: vector("dim_3072", { dimensions: VECTOR_DIMS.XXXL })
}, (table3) => [
  check("embedding_source_check", sql`"memory_id" IS NOT NULL`),
  index("idx_embedding_memory").on(table3.memoryId),
  foreignKey({
    name: "fk_embedding_memory",
    columns: [table3.memoryId],
    foreignColumns: [memoryTable.id]
  }).onDelete("cascade")
]);

// src/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  worldTable: () => worldTable,
  taskTable: () => taskTable,
  serverAgentsTable: () => serverAgentsTable,
  roomTable: () => roomTable,
  relationshipTable: () => relationshipTable,
  participantTable: () => participantTable,
  messageTable: () => messageTable,
  messageServerTable: () => messageServerTable,
  memoryTable: () => memoryTable,
  logTable: () => logTable,
  entityTable: () => entityTable,
  embeddingTable: () => embeddingTable,
  componentTable: () => componentTable,
  channelTable: () => channelTable,
  channelParticipantsTable: () => channelParticipantsTable,
  cacheTable: () => cacheTable,
  agentTable: () => agentTable
});

// src/schema/cache.ts
init_drizzle_orm();
init_pg_core();
var cacheTable = pgTable("cache", {
  key: text("key").notNull(),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  value: jsonb("value").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true })
}, (table3) => ({
  pk: primaryKey({ columns: [table3.key, table3.agentId] })
}));
// src/schema/component.ts
init_drizzle_orm();
init_pg_core();

// src/schema/world.ts
init_drizzle_orm();
init_pg_core();
var worldTable = pgTable("worlds", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  agentId: uuid("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  metadata: jsonb("metadata"),
  serverId: text("serverId").notNull().default("local"),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});

// src/schema/component.ts
var componentTable = pgTable("components", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`).notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, { onDelete: "cascade" }).notNull(),
  agentId: uuid("agentId").references(() => agentTable.id, { onDelete: "cascade" }).notNull(),
  roomId: uuid("roomId").references(() => roomTable.id, { onDelete: "cascade" }).notNull(),
  worldId: uuid("worldId").references(() => worldTable.id, { onDelete: "cascade" }),
  sourceEntityId: uuid("sourceEntityId").references(() => entityTable.id, { onDelete: "cascade" }),
  type: text("type").notNull(),
  data: jsonb("data").default(sql`'{}'::jsonb`),
  createdAt: timestamp("createdAt").default(sql`now()`).notNull()
});
// src/schema/log.ts
init_drizzle_orm();
init_pg_core();
var logTable = pgTable("logs", {
  id: uuid("id").defaultRandom().notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  entityId: uuid("entityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  body: jsonb("body").notNull(),
  type: text("type").notNull(),
  roomId: uuid("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" })
}, (table3) => [
  foreignKey({
    name: "fk_room",
    columns: [table3.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table3.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/participant.ts
init_drizzle_orm();
init_pg_core();
var participantTable = pgTable("participants", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  entityId: uuid("entityId").references(() => entityTable.id, {
    onDelete: "cascade"
  }),
  roomId: uuid("roomId").references(() => roomTable.id, {
    onDelete: "cascade"
  }),
  agentId: uuid("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  roomState: text("roomState")
}, (table3) => [
  index("idx_participants_user").on(table3.entityId),
  index("idx_participants_room").on(table3.roomId),
  foreignKey({
    name: "fk_room",
    columns: [table3.roomId],
    foreignColumns: [roomTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user",
    columns: [table3.entityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/relationship.ts
init_drizzle_orm();
init_pg_core();
var relationshipTable = pgTable("relationships", {
  id: uuid("id").notNull().primaryKey().default(sql`gen_random_uuid()`),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
  sourceEntityId: uuid("sourceEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  targetEntityId: uuid("targetEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
  agentId: uuid("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text("tags").array(),
  metadata: jsonb("metadata")
}, (table3) => [
  index("idx_relationships_users").on(table3.sourceEntityId, table3.targetEntityId),
  unique("unique_relationship").on(table3.sourceEntityId, table3.targetEntityId, table3.agentId),
  foreignKey({
    name: "fk_user_a",
    columns: [table3.sourceEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade"),
  foreignKey({
    name: "fk_user_b",
    columns: [table3.targetEntityId],
    foreignColumns: [entityTable.id]
  }).onDelete("cascade")
]);
// src/schema/tasks.ts
init_pg_core();
init_drizzle_orm();
var taskTable = pgTable("tasks", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  description: text("description"),
  roomId: uuid("roomId"),
  worldId: uuid("worldId"),
  entityId: uuid("entityId"),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text("tags").array().default(sql`'{}'::text[]`),
  metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow()
});
// src/schema/messageServer.ts
init_pg_core();
init_drizzle_orm();
var messageServerTable = pgTable("message_servers", {
  id: uuid("id").primaryKey(),
  name: text("name").notNull(),
  sourceType: text("source_type").notNull(),
  sourceId: text("source_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channel.ts
init_pg_core();
init_drizzle_orm();
var channelTable = pgTable("channels", {
  id: text("id").primaryKey(),
  messageServerId: uuid("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  type: text("type").notNull(),
  sourceType: text("source_type"),
  sourceId: text("source_id"),
  topic: text("topic"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/message.ts
init_pg_core();
init_drizzle_orm();
var messageTable = pgTable("central_messages", {
  id: text("id").primaryKey(),
  channelId: text("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  authorId: text("author_id").notNull(),
  content: text("content").notNull(),
  rawMessage: jsonb("raw_message"),
  inReplyToRootMessageId: text("in_reply_to_root_message_id").references(() => messageTable.id, {
    onDelete: "set null"
  }),
  sourceType: text("source_type"),
  sourceId: text("source_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp("updated_at", { mode: "date" }).default(sql`CURRENT_TIMESTAMP`).notNull()
});
// src/schema/channelParticipant.ts
init_pg_core();
var channelParticipantsTable = pgTable("channel_participants", {
  channelId: text("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  userId: text("user_id").notNull()
}, (table3) => ({
  pk: primaryKey({ columns: [table3.channelId, table3.userId] })
}));
// src/schema/serverAgent.ts
init_pg_core();
var serverAgentsTable = pgTable("server_agents", {
  serverId: uuid("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  agentId: uuid("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" })
}, (table3) => ({
  pk: primaryKey({ columns: [table3.serverId, table3.agentId] })
}));
// src/base.ts
class BaseDrizzleAdapter extends DatabaseAdapter {
  maxRetries = 3;
  baseDelay = 1000;
  maxDelay = 1e4;
  jitterMax = 1000;
  embeddingDimension = DIMENSION_MAP[384];
  migrationService;
  async initialize() {
    await this.init();
  }
  async runPluginMigrations(plugins, options) {
    if (!this.migrationService) {
      const { DatabaseMigrationService: DatabaseMigrationService2 } = await Promise.resolve().then(() => (init_migration_service(), exports_migration_service));
      this.migrationService = new DatabaseMigrationService2;
      await this.migrationService.initializeWithDatabase(this.db);
    }
    for (const plugin of plugins) {
      if (plugin.schema) {
        this.migrationService.registerSchema(plugin.name, plugin.schema);
      }
    }
    await this.migrationService.runAllPluginMigrations(options);
  }
  getDatabase() {
    return this.db;
  }
  agentId;
  constructor(agentId) {
    super();
    this.agentId = agentId;
  }
  async withRetry(operation) {
    let lastError = new Error("Unknown error");
    for (let attempt = 1;attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < this.maxRetries) {
          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);
          const jitter = Math.random() * this.jitterMax;
          const delay = backoffDelay + jitter;
          logger8.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}): ${error instanceof Error ? error.message : String(error)}, nextRetryIn: ${(delay / 1000).toFixed(1)}s`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          logger8.error(`Max retry attempts reached: ${error instanceof Error ? error.message : String(error)}, totalAttempts: ${attempt}`);
          throw error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    throw lastError;
  }
  async ensureEmbeddingDimension(dimension) {
    return this.withDatabase(async () => {
      const existingMemory = await this.db.select().from(memoryTable).innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(eq(memoryTable.agentId, this.agentId)).limit(1);
      if (existingMemory.length > 0) {
        Object.entries(DIMENSION_MAP).find(([_, colName]) => existingMemory[0].embeddings[colName] !== null);
      }
      this.embeddingDimension = DIMENSION_MAP[dimension];
    });
  }
  async getAgent(agentId) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
      if (rows.length === 0)
        return null;
      const row = rows[0];
      return {
        ...row,
        username: row.username || "",
        id: row.id,
        system: !row.system ? undefined : row.system,
        bio: !row.bio ? "" : row.bio,
        createdAt: row.createdAt.getTime(),
        updatedAt: row.updatedAt.getTime()
      };
    });
  }
  async getAgents() {
    const result = await this.withDatabase(async () => {
      const rows = await this.db.select({
        id: agentTable.id,
        name: agentTable.name,
        bio: agentTable.bio
      }).from(agentTable);
      return rows.map((row) => ({
        ...row,
        id: row.id,
        bio: row.bio === null ? "" : row.bio
      }));
    });
    return result || [];
  }
  async createAgent(agent) {
    return this.withDatabase(async () => {
      try {
        const conditions2 = [];
        if (agent.id) {
          conditions2.push(eq(agentTable.id, agent.id));
        }
        if (agent.name) {
          conditions2.push(eq(agentTable.name, agent.name));
        }
        const existing = conditions2.length > 0 ? await this.db.select({ id: agentTable.id }).from(agentTable).where(or(...conditions2)).limit(1) : [];
        if (existing.length > 0) {
          logger8.warn(`Attempted to create an agent with a duplicate ID or name. ID: ${agent.id}, name: ${agent.name}`);
          return false;
        }
        await this.db.transaction(async (tx) => {
          await tx.insert(agentTable).values({
            ...agent,
            createdAt: new Date(agent.createdAt || Date.now()),
            updatedAt: new Date(agent.updatedAt || Date.now())
          });
        });
        logger8.debug(`Agent created successfully: ${agent.id}`);
        return true;
      } catch (error) {
        logger8.error(`Error creating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agent.id}`);
        return false;
      }
    });
  }
  async updateAgent(agentId, agent) {
    return this.withDatabase(async () => {
      try {
        if (!agentId) {
          throw new Error("Agent ID is required for update");
        }
        await this.db.transaction(async (tx) => {
          if (agent?.settings) {
            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);
          }
          const updateData = { ...agent };
          if (updateData.createdAt) {
            if (typeof updateData.createdAt === "number") {
              updateData.createdAt = new Date(updateData.createdAt);
            } else {
              delete updateData.createdAt;
            }
          }
          if (updateData.updatedAt) {
            if (typeof updateData.updatedAt === "number") {
              updateData.updatedAt = new Date(updateData.updatedAt);
            } else {
              updateData.updatedAt = new Date;
            }
          } else {
            updateData.updatedAt = new Date;
          }
          await tx.update(agentTable).set(updateData).where(eq(agentTable.id, agentId));
        });
        logger8.debug(`Agent updated successfully: ${agentId}`);
        return true;
      } catch (error) {
        logger8.error(`Error updating agent: ${error instanceof Error ? error.message : String(error)}, agentId: ${agentId}`);
        return false;
      }
    });
  }
  async mergeAgentSettings(tx, agentId, updatedSettings) {
    const currentAgent = await tx.select({ settings: agentTable.settings }).from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
    const currentSettings = currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};
    const deepMerge = (target, source) => {
      if (source === null) {
        return;
      }
      if (Array.isArray(source) || typeof source !== "object") {
        return source;
      }
      const output = typeof target === "object" && target !== null && !Array.isArray(target) ? { ...target } : {};
      for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue === null) {
          delete output[key];
        } else if (typeof sourceValue === "object" && !Array.isArray(sourceValue)) {
          const nestedMergeResult = deepMerge(output[key], sourceValue);
          if (nestedMergeResult === undefined) {
            delete output[key];
          } else {
            output[key] = nestedMergeResult;
          }
        } else {
          output[key] = sourceValue;
        }
      }
      if (Object.keys(output).length === 0) {
        if (!(typeof source === "object" && source !== null && Object.keys(source).length === 0)) {
          return;
        }
      }
      return output;
    };
    const finalSettings = deepMerge(currentSettings, updatedSettings);
    return finalSettings === undefined ? {} : finalSettings;
  }
  async deleteAgent(agentId) {
    logger8.debug(`[DB] Deleting agent with ID: ${agentId}`);
    return this.withDatabase(async () => {
      try {
        const result = await this.db.delete(agentTable).where(eq(agentTable.id, agentId)).returning();
        if (result.length === 0) {
          logger8.warn(`[DB] Agent ${agentId} not found`);
          return false;
        }
        logger8.success(`[DB] Agent ${agentId} and all related data successfully deleted via cascade`);
        return true;
      } catch (error) {
        logger8.error(`[DB] Failed to delete agent ${agentId}: ${error instanceof Error ? error.message : String(error)}`);
        if (error instanceof Error) {
          logger8.error(`[DB] Error details: ${error.name} - ${error.message}`);
          logger8.error(`[DB] Stack trace: ${error.stack}`);
        }
        throw error;
      }
    });
  }
  async countAgents() {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ count: count() }).from(agentTable);
        return result[0]?.count || 0;
      } catch (error) {
        logger8.error(`Error counting agents: ${error instanceof Error ? error.message : String(error)}`);
        return 0;
      }
    });
  }
  async cleanupAgents() {
    return this.withDatabase(async () => {
      try {
        await this.db.delete(agentTable);
        logger8.success("Successfully cleaned up agent table");
      } catch (error) {
        logger8.error(`Error cleaning up agent table: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async getEntitiesByIds(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        entity: entityTable,
        components: componentTable
      }).from(entityTable).leftJoin(componentTable, eq(componentTable.entityId, entityTable.id)).where(inArray(entityTable.id, entityIds));
      if (result.length === 0)
        return [];
      const entities = {};
      const entityComponents = {};
      for (const e of result) {
        const key = e.entity.id;
        entities[key] = e.entity;
        if (entityComponents[key] === undefined)
          entityComponents[key] = [];
        if (e.components) {
          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];
          entityComponents[key] = [...entityComponents[key], ...componentsArray];
        }
      }
      for (const k of Object.keys(entityComponents)) {
        entities[k].components = entityComponents[k];
      }
      return Object.values(entities);
    });
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return this.withDatabase(async () => {
      const query = this.db.select({
        entity: entityTable,
        ...includeComponents && { components: componentTable }
      }).from(participantTable).leftJoin(entityTable, and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId)));
      if (includeComponents) {
        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));
      }
      const result = await query.where(eq(participantTable.roomId, roomId));
      const entitiesByIdMap = new Map;
      for (const row of result) {
        if (!row.entity)
          continue;
        const entityId = row.entity.id;
        if (!entitiesByIdMap.has(entityId)) {
          const entity2 = {
            ...row.entity,
            id: entityId,
            agentId: row.entity.agentId,
            metadata: row.entity.metadata,
            components: includeComponents ? [] : undefined
          };
          entitiesByIdMap.set(entityId, entity2);
        }
        if (includeComponents && row.components) {
          const entity2 = entitiesByIdMap.get(entityId);
          if (entity2) {
            if (!entity2.components) {
              entity2.components = [];
            }
            entity2.components.push(row.components);
          }
        }
      }
      return Array.from(entitiesByIdMap.values());
    });
  }
  async createEntities(entities) {
    return this.withDatabase(async () => {
      try {
        return await this.db.transaction(async (tx) => {
          await tx.insert(entityTable).values(entities);
          logger8.debug(`${entities.length} Entities created successfully`);
          return true;
        });
      } catch (error) {
        logger8.error(`Error creating entities, entityId: ${entities[0].id}, (metadata?.)name: ${entities[0].metadata?.name}`, error instanceof Error ? error.message : String(error));
        if (error instanceof Error && error.stack) {
          logger8.trace("Stack trace:", error.stack);
        }
        return false;
      }
    });
  }
  async ensureEntityExists(entity2) {
    if (!entity2.id) {
      logger8.error("Entity ID is required for ensureEntityExists");
      return false;
    }
    try {
      const existingEntities = await this.getEntitiesByIds([entity2.id]);
      if (!existingEntities || !existingEntities.length) {
        return await this.createEntities([entity2]);
      }
      return true;
    } catch (error) {
      logger8.error(`Error ensuring entity exists: ${error instanceof Error ? error.message : String(error)}, entityId: ${entity2.id}`);
      return false;
    }
  }
  async updateEntity(entity2) {
    if (!entity2.id) {
      throw new Error("Entity ID is required for update");
    }
    return this.withDatabase(async () => {
      await this.db.update(entityTable).set(entity2).where(eq(entityTable.id, entity2.id));
    });
  }
  async deleteEntity(entityId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(componentTable).where(or(eq(componentTable.entityId, entityId), eq(componentTable.sourceEntityId, entityId)));
        await tx.delete(entityTable).where(eq(entityTable.id, entityId));
      });
    });
  }
  async getEntitiesByNames(params) {
    return this.withDatabase(async () => {
      const { names, agentId } = params;
      const nameConditions = names.map((name) => sql`${name} = ANY(${entityTable.names})`);
      const query = sql`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND (${sql.join(nameConditions, sql` OR `)})
      `;
      const result = await this.db.execute(query);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async searchEntitiesByName(params) {
    return this.withDatabase(async () => {
      const { query, agentId, limit = 10 } = params;
      if (!query || query.trim() === "") {
        const result2 = await this.db.select().from(entityTable).where(eq(entityTable.agentId, agentId)).limit(limit);
        return result2.map((row) => ({
          id: row.id,
          agentId: row.agentId,
          names: row.names || [],
          metadata: row.metadata || {}
        }));
      }
      const searchQuery = sql`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND EXISTS (
          SELECT 1 FROM unnest(${entityTable.names}) AS name
          WHERE LOWER(name) LIKE LOWER(${"%" + query + "%"})
        )
        LIMIT ${limit}
      `;
      const result = await this.db.execute(searchQuery);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions2 = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];
      if (worldId) {
        conditions2.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions2.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select().from(componentTable).where(and(...conditions2));
      if (result.length === 0)
        return null;
      const component = result[0];
      return {
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      };
    });
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions2 = [eq(componentTable.entityId, entityId)];
      if (worldId) {
        conditions2.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions2.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select({
        id: componentTable.id,
        entityId: componentTable.entityId,
        type: componentTable.type,
        data: componentTable.data,
        worldId: componentTable.worldId,
        agentId: componentTable.agentId,
        roomId: componentTable.roomId,
        sourceEntityId: componentTable.sourceEntityId,
        createdAt: componentTable.createdAt
      }).from(componentTable).where(and(...conditions2));
      if (result.length === 0)
        return [];
      const components = result.map((component) => ({
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      }));
      return components;
    });
  }
  async createComponent(component) {
    return this.withDatabase(async () => {
      await this.db.insert(componentTable).values({
        ...component,
        createdAt: new Date
      });
      return true;
    });
  }
  async updateComponent(component) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(componentTable).set({
          ...component,
          updatedAt: new Date
        }).where(eq(componentTable.id, component.id));
      } catch (e) {
        console.error("updateComponent error", e);
      }
    });
  }
  async deleteComponent(componentId) {
    return this.withDatabase(async () => {
      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));
    });
  }
  async getMemories(params) {
    const { entityId, agentId, roomId, worldId, tableName, unique: unique2, start, end } = params;
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions2 = [eq(memoryTable.type, tableName)];
      if (start) {
        conditions2.push(gte(memoryTable.createdAt, new Date(start)));
      }
      if (entityId) {
        conditions2.push(eq(memoryTable.entityId, entityId));
      }
      if (roomId) {
        conditions2.push(eq(memoryTable.roomId, roomId));
      }
      if (worldId) {
        conditions2.push(eq(memoryTable.worldId, worldId));
      }
      if (end) {
        conditions2.push(lte(memoryTable.createdAt, new Date(end)));
      }
      if (unique2) {
        conditions2.push(eq(memoryTable.unique, true));
      }
      if (agentId) {
        conditions2.push(eq(memoryTable.agentId, agentId));
      }
      const query = this.db.select({
        memory: {
          id: memoryTable.id,
          type: memoryTable.type,
          createdAt: memoryTable.createdAt,
          content: memoryTable.content,
          entityId: memoryTable.entityId,
          agentId: memoryTable.agentId,
          roomId: memoryTable.roomId,
          unique: memoryTable.unique,
          metadata: memoryTable.metadata
        },
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions2)).orderBy(desc(memoryTable.createdAt));
      const rows = params.count ? await query.limit(params.count) : await query;
      return rows.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ? Array.from(row.embedding) : undefined
      }));
    });
  }
  async getMemoriesByRoomIds(params) {
    return this.withDatabase(async () => {
      if (params.roomIds.length === 0)
        return [];
      const conditions2 = [
        eq(memoryTable.type, params.tableName),
        inArray(memoryTable.roomId, params.roomIds)
      ];
      conditions2.push(eq(memoryTable.agentId, this.agentId));
      const query = this.db.select({
        id: memoryTable.id,
        type: memoryTable.type,
        createdAt: memoryTable.createdAt,
        content: memoryTable.content,
        entityId: memoryTable.entityId,
        agentId: memoryTable.agentId,
        roomId: memoryTable.roomId,
        unique: memoryTable.unique,
        metadata: memoryTable.metadata
      }).from(memoryTable).where(and(...conditions2)).orderBy(desc(memoryTable.createdAt));
      const rows = params.limit ? await query.limit(params.limit) : await query;
      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt.getTime(),
        content: typeof row.content === "string" ? JSON.parse(row.content) : row.content,
        entityId: row.entityId,
        agentId: row.agentId,
        roomId: row.roomId,
        unique: row.unique,
        metadata: row.metadata
      }));
    });
  }
  async getMemoryById(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId)).where(eq(memoryTable.id, id)).limit(1);
      if (result.length === 0)
        return null;
      const row = result[0];
      return {
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      };
    });
  }
  async getMemoriesByIds(memoryIds, tableName) {
    return this.withDatabase(async () => {
      if (memoryIds.length === 0)
        return [];
      const conditions2 = [inArray(memoryTable.id, memoryIds)];
      if (tableName) {
        conditions2.push(eq(memoryTable.type, tableName));
      }
      const rows = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions2)).orderBy(desc(memoryTable.createdAt));
      return rows.map((row) => ({
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined
      }));
    });
  }
  async getCachedEmbeddings(opts) {
    return this.withDatabase(async () => {
      try {
        const results = await this.db.execute(sql`
                    WITH content_text AS (
                        SELECT
                            m.id,
                            COALESCE(
                                m.content->>${opts.query_field_sub_name},
                                ''
                            ) as content_text
                        FROM memories m
                        WHERE m.type = ${opts.query_table_name}
                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL
                    ),
                    embedded_text AS (
                        SELECT
                            ct.content_text,
                            COALESCE(
                                e.dim_384,
                                e.dim_512,
                                e.dim_768,
                                e.dim_1024,
                                e.dim_1536,
                                e.dim_3072
                            ) as embedding
                        FROM content_text ct
                        LEFT JOIN embeddings e ON e.memory_id = ct.id
                        WHERE e.memory_id IS NOT NULL
                    )
                    SELECT
                        embedding,
                        levenshtein(${opts.query_input}, content_text) as levenshtein_score
                    FROM embedded_text
                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}
                    ORDER BY levenshtein_score
                    LIMIT ${opts.query_match_count}
                `);
        return results.rows.map((row) => ({
          embedding: Array.isArray(row.embedding) ? row.embedding : typeof row.embedding === "string" ? JSON.parse(row.embedding) : [],
          levenshtein_score: Number(row.levenshtein_score)
        })).filter((row) => Array.isArray(row.embedding));
      } catch (error) {
        logger8.error(`Error in getCachedEmbeddings: ${error instanceof Error ? error.message : String(error)}, tableName: ${opts.query_table_name}, fieldName: ${opts.query_field_name}`);
        if (error instanceof Error && error.message === "levenshtein argument exceeds maximum length of 255 characters") {
          return [];
        }
        throw error;
      }
    });
  }
  async log(params) {
    return this.withDatabase(async () => {
      try {
        const sanitizedBody = this.sanitizeJsonObject(params.body);
        const jsonString = JSON.stringify(sanitizedBody);
        await this.db.transaction(async (tx) => {
          await tx.insert(logTable).values({
            body: sql`${jsonString}::jsonb`,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type
          });
        });
      } catch (error) {
        logger8.error(`Failed to create log entry: ${error instanceof Error ? error.message : String(error)}, type: ${params.type}, roomId: ${params.roomId}, entityId: ${params.entityId}`);
        throw error;
      }
    });
  }
  sanitizeJsonObject(value, seen = new WeakSet) {
    if (value === null || value === undefined) {
      return value;
    }
    if (typeof value === "string") {
      return value.replace(/\u0000/g, "").replace(/\\(?!["\\/bfnrtu])/g, "\\\\").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u");
    }
    if (typeof value === "object") {
      if (seen.has(value)) {
        return null;
      } else {
        seen.add(value);
      }
      if (Array.isArray(value)) {
        return value.map((item) => this.sanitizeJsonObject(item, seen));
      } else {
        const result = {};
        for (const [key, val] of Object.entries(value)) {
          const sanitizedKey = typeof key === "string" ? key.replace(/\u0000/g, "").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u") : key;
          result[sanitizedKey] = this.sanitizeJsonObject(val, seen);
        }
        return result;
      }
    }
    return value;
  }
  async getLogs(params) {
    const { entityId, roomId, type, count: count2, offset } = params;
    return this.withDatabase(async () => {
      const result = await this.db.select().from(logTable).where(and(eq(logTable.entityId, entityId), roomId ? eq(logTable.roomId, roomId) : undefined, type ? eq(logTable.type, type) : undefined)).orderBy(desc(logTable.createdAt)).limit(count2 ?? 10).offset(offset ?? 0);
      const logs = result.map((log) => ({
        ...log,
        id: log.id,
        entityId: log.entityId,
        roomId: log.roomId,
        body: log.body,
        createdAt: new Date(log.createdAt)
      }));
      if (logs.length === 0)
        return [];
      return logs;
    });
  }
  async getAgentRunSummaries(params = {}) {
    const limit = Math.min(Math.max(params.limit ?? 20, 1), 100);
    const fromDate = typeof params.from === "number" ? new Date(params.from) : undefined;
    const toDate = typeof params.to === "number" ? new Date(params.to) : undefined;
    return this.withDatabase(async () => {
      const runMap = new Map;
      const conditions2 = [
        eq(logTable.type, "run_event"),
        sql`${logTable.body} ? 'runId'`,
        eq(roomTable.agentId, this.agentId)
      ];
      if (params.roomId) {
        conditions2.push(eq(logTable.roomId, params.roomId));
      }
      if (fromDate) {
        conditions2.push(gte(logTable.createdAt, fromDate));
      }
      if (toDate) {
        conditions2.push(lte(logTable.createdAt, toDate));
      }
      const whereClause = and(...conditions2);
      const eventLimit = Math.max(limit * 20, 200);
      const runEventRows = await this.db.select({
        runId: sql`(${logTable.body} ->> 'runId')`,
        status: sql`(${logTable.body} ->> 'status')`,
        messageId: sql`(${logTable.body} ->> 'messageId')`,
        rawBody: logTable.body,
        createdAt: logTable.createdAt,
        roomId: logTable.roomId,
        entityId: logTable.entityId
      }).from(logTable).innerJoin(roomTable, eq(roomTable.id, logTable.roomId)).where(whereClause).orderBy(desc(logTable.createdAt)).limit(eventLimit);
      for (const row of runEventRows) {
        const runId = row.runId;
        if (!runId)
          continue;
        const summary = runMap.get(runId) ?? {
          runId,
          status: "started",
          startedAt: null,
          endedAt: null,
          durationMs: null,
          messageId: undefined,
          roomId: undefined,
          entityId: undefined,
          metadata: {}
        };
        if (!summary.messageId && row.messageId) {
          summary.messageId = row.messageId;
        }
        if (!summary.roomId && row.roomId) {
          summary.roomId = row.roomId;
        }
        if (!summary.entityId && row.entityId) {
          summary.entityId = row.entityId;
        }
        const body = row.rawBody;
        if (body && typeof body === "object") {
          if (!summary.roomId && typeof body.roomId === "string") {
            summary.roomId = body.roomId;
          }
          if (!summary.entityId && typeof body.entityId === "string") {
            summary.entityId = body.entityId;
          }
          if (!summary.messageId && typeof body.messageId === "string") {
            summary.messageId = body.messageId;
          }
          if (!summary.metadata || Object.keys(summary.metadata).length === 0) {
            const metadata = body.metadata ?? undefined;
            summary.metadata = metadata ? { ...metadata } : {};
          }
        }
        const createdAt = row.createdAt instanceof Date ? row.createdAt : new Date(row.createdAt);
        const timestamp3 = createdAt.getTime();
        const eventStatus = row.status ?? body?.status;
        if (eventStatus === "started") {
          summary.startedAt = summary.startedAt === null ? timestamp3 : Math.min(summary.startedAt, timestamp3);
        } else if (eventStatus === "completed" || eventStatus === "timeout" || eventStatus === "error") {
          summary.status = eventStatus;
          summary.endedAt = timestamp3;
          if (summary.startedAt !== null) {
            summary.durationMs = Math.max(timestamp3 - summary.startedAt, 0);
          }
        }
        runMap.set(runId, summary);
      }
      let runs = Array.from(runMap.values());
      if (params.status && params.status !== "all") {
        runs = runs.filter((run) => run.status === params.status);
      }
      runs.sort((a, b) => (b.startedAt ?? 0) - (a.startedAt ?? 0));
      const total = runs.length;
      const limitedRuns = runs.slice(0, limit);
      const hasMore = total > limit;
      const runCounts = new Map;
      for (const run of limitedRuns) {
        runCounts.set(run.runId, { actions: 0, modelCalls: 0, errors: 0, evaluators: 0 });
      }
      const runIds = limitedRuns.map((run) => run.runId).filter(Boolean);
      if (runIds.length > 0) {
        const runIdArray = sql`array[${sql.join(runIds.map((id) => sql`${id}`), sql`, `)}]::text[]`;
        const actionSummary = await this.db.execute(sql`
          SELECT
            body->>'runId' as "runId",
            COUNT(*)::int as "actions",
            SUM(CASE WHEN COALESCE(body->'result'->>'success', 'true') = 'false' THEN 1 ELSE 0 END)::int as "errors",
            SUM(COALESCE((body->>'promptCount')::int, 0))::int as "modelCalls"
          FROM ${logTable}
          WHERE type = 'action'
            AND body->>'runId' = ANY(${runIdArray})
          GROUP BY body->>'runId'
        `);
        const actionRows = actionSummary.rows ?? [];
        for (const row of actionRows) {
          const counts = runCounts.get(row.runId);
          if (!counts)
            continue;
          counts.actions += Number(row.actions ?? 0);
          counts.errors += Number(row.errors ?? 0);
          counts.modelCalls += Number(row.modelCalls ?? 0);
        }
        const evaluatorSummary = await this.db.execute(sql`
          SELECT
            body->>'runId' as "runId",
            COUNT(*)::int as "evaluators"
          FROM ${logTable}
          WHERE type = 'evaluator'
            AND body->>'runId' = ANY(${runIdArray})
          GROUP BY body->>'runId'
        `);
        const evaluatorRows = evaluatorSummary.rows ?? [];
        for (const row of evaluatorRows) {
          const counts = runCounts.get(row.runId);
          if (!counts)
            continue;
          counts.evaluators += Number(row.evaluators ?? 0);
        }
        const genericSummary = await this.db.execute(sql`
          SELECT
            body->>'runId' as "runId",
            COUNT(*) FILTER (WHERE type LIKE 'useModel:%')::int as "modelLogs",
            COUNT(*) FILTER (WHERE type = 'embedding_event' AND body->>'status' = 'failed')::int as "embeddingErrors"
          FROM ${logTable}
          WHERE (type LIKE 'useModel:%' OR type = 'embedding_event')
            AND body->>'runId' = ANY(${runIdArray})
          GROUP BY body->>'runId'
        `);
        const genericRows = genericSummary.rows ?? [];
        for (const row of genericRows) {
          const counts = runCounts.get(row.runId);
          if (!counts)
            continue;
          counts.modelCalls += Number(row.modelLogs ?? 0);
          counts.errors += Number(row.embeddingErrors ?? 0);
        }
      }
      for (const run of limitedRuns) {
        run.counts = runCounts.get(run.runId) ?? {
          actions: 0,
          modelCalls: 0,
          errors: 0,
          evaluators: 0
        };
      }
      return {
        runs: limitedRuns,
        total,
        hasMore
      };
    });
  }
  async deleteLog(logId) {
    return this.withDatabase(async () => {
      await this.db.delete(logTable).where(eq(logTable.id, logId));
    });
  }
  async searchMemories(params) {
    return await this.searchMemoriesByEmbedding(params.embedding, {
      match_threshold: params.match_threshold,
      count: params.count,
      roomId: params.roomId,
      worldId: params.worldId,
      entityId: params.entityId,
      unique: params.unique,
      tableName: params.tableName
    });
  }
  async searchMemoriesByEmbedding(embedding, params) {
    return this.withDatabase(async () => {
      const cleanVector = embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
      const similarity = sql`1 - (${cosineDistance(embeddingTable[this.embeddingDimension], cleanVector)})`;
      const conditions2 = [eq(memoryTable.type, params.tableName)];
      if (params.unique) {
        conditions2.push(eq(memoryTable.unique, true));
      }
      conditions2.push(eq(memoryTable.agentId, this.agentId));
      if (params.roomId) {
        conditions2.push(eq(memoryTable.roomId, params.roomId));
      }
      if (params.worldId) {
        conditions2.push(eq(memoryTable.worldId, params.worldId));
      }
      if (params.entityId) {
        conditions2.push(eq(memoryTable.entityId, params.entityId));
      }
      if (params.match_threshold) {
        conditions2.push(gte(similarity, params.match_threshold));
      }
      const results = await this.db.select({
        memory: memoryTable,
        similarity,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(embeddingTable).innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId)).where(and(...conditions2)).orderBy(desc(similarity)).limit(params.count ?? 10);
      return results.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        worldId: row.memory.worldId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? undefined,
        similarity: row.similarity
      }));
    });
  }
  async createMemory(memory, tableName) {
    logger8.debug(`DrizzleAdapter createMemory: memoryId: ${memory.id}, embeddingLength: ${memory.embedding?.length}, contentLength: ${memory.content?.text?.length}`);
    const memoryId = memory.id ?? v4();
    const existing = await this.getMemoryById(memoryId);
    if (existing) {
      logger8.debug(`Memory already exists, skipping creation: ${memoryId}`);
      return memoryId;
    }
    if (memory.unique === undefined) {
      memory.unique = true;
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {
          tableName,
          roomId: memory.roomId,
          worldId: memory.worldId,
          entityId: memory.entityId,
          match_threshold: 0.95,
          count: 1
        });
        memory.unique = similarMemories.length === 0;
      }
    }
    const contentToInsert = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
    const metadataToInsert = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
    await this.db.transaction(async (tx) => {
      await tx.insert(memoryTable).values([
        {
          id: memoryId,
          type: tableName,
          content: sql`${contentToInsert}::jsonb`,
          metadata: sql`${metadataToInsert}::jsonb`,
          entityId: memory.entityId,
          roomId: memory.roomId,
          worldId: memory.worldId,
          agentId: memory.agentId || this.agentId,
          unique: memory.unique,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        }
      ]);
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const embeddingValues = {
          id: v4(),
          memoryId,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : new Date
        };
        const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
        embeddingValues[this.embeddingDimension] = cleanVector;
        await tx.insert(embeddingTable).values([embeddingValues]);
      }
    });
    return memoryId;
  }
  async updateMemory(memory) {
    return this.withDatabase(async () => {
      try {
        logger8.debug(`Updating memory: memoryId: ${memory.id}, hasEmbedding: ${!!memory.embedding}`);
        await this.db.transaction(async (tx) => {
          if (memory.content) {
            const contentToUpdate = typeof memory.content === "string" ? memory.content : JSON.stringify(memory.content ?? {});
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              content: sql`${contentToUpdate}::jsonb`,
              ...memory.metadata && { metadata: sql`${metadataToUpdate}::jsonb` }
            }).where(eq(memoryTable.id, memory.id));
          } else if (memory.metadata) {
            const metadataToUpdate = typeof memory.metadata === "string" ? memory.metadata : JSON.stringify(memory.metadata ?? {});
            await tx.update(memoryTable).set({
              metadata: sql`${metadataToUpdate}::jsonb`
            }).where(eq(memoryTable.id, memory.id));
          }
          if (memory.embedding && Array.isArray(memory.embedding)) {
            const cleanVector = memory.embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
            const existingEmbedding = await tx.select({ id: embeddingTable.id }).from(embeddingTable).where(eq(embeddingTable.memoryId, memory.id)).limit(1);
            if (existingEmbedding.length > 0) {
              const updateValues = {};
              updateValues[this.embeddingDimension] = cleanVector;
              await tx.update(embeddingTable).set(updateValues).where(eq(embeddingTable.memoryId, memory.id));
            } else {
              const embeddingValues = {
                id: v4(),
                memoryId: memory.id
              };
              embeddingValues[this.embeddingDimension] = cleanVector;
              await tx.insert(embeddingTable).values([embeddingValues]);
            }
          }
        });
        logger8.debug(`Memory updated successfully: ${memory.id}`);
        return true;
      } catch (error) {
        logger8.error(`Error updating memory: ${error instanceof Error ? error.message : String(error)}, memoryId: ${memory.id}`);
        return false;
      }
    });
  }
  async deleteMemory(memoryId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await this.deleteMemoryFragments(tx, memoryId);
        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));
      });
      logger8.debug(`Memory and related fragments removed successfully: ${memoryId}`);
    });
  }
  async deleteManyMemories(memoryIds) {
    if (memoryIds.length === 0) {
      return;
    }
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const BATCH_SIZE = 100;
        for (let i = 0;i < memoryIds.length; i += BATCH_SIZE) {
          const batch = memoryIds.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(async (memoryId) => {
            await this.deleteMemoryFragments(tx, memoryId);
          }));
          await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));
          await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));
        }
      });
      logger8.debug(`Batch memory deletion completed successfully: ${memoryIds.length}`);
    });
  }
  async deleteMemoryFragments(tx, documentId) {
    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);
    if (fragmentsToDelete.length > 0) {
      const fragmentIds = fragmentsToDelete.map((f) => f.id);
      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));
      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));
      logger8.debug(`Deleted related fragments: documentId: ${documentId}, fragmentCount: ${fragmentsToDelete.length}`);
    }
  }
  async getMemoryFragments(tx, documentId) {
    const fragments = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.agentId, this.agentId), sql`${memoryTable.metadata}->>'documentId' = ${documentId}`));
    return fragments.map((f) => ({ id: f.id }));
  }
  async deleteAllMemories(roomId, tableName) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const rows = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
        const ids = rows.map((r) => r.id);
        logger8.debug(`[deleteAllMemories] memory IDs to delete: roomId: ${roomId}, tableName: ${tableName}, ids: ${JSON.stringify(ids)}`);
        if (ids.length === 0) {
          return;
        }
        await Promise.all(ids.map(async (memoryId) => {
          await this.deleteMemoryFragments(tx, memoryId);
          await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        }));
        await tx.delete(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
      });
      logger8.debug(`All memories removed successfully: roomId: ${roomId}, tableName: ${tableName}`);
    });
  }
  async countMemories(roomId, unique2 = true, tableName = "") {
    if (!tableName)
      throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions2 = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];
      if (unique2) {
        conditions2.push(eq(memoryTable.unique, true));
      }
      const result = await this.db.select({ count: sql`count(*)` }).from(memoryTable).where(and(...conditions2));
      return Number(result[0]?.count ?? 0);
    });
  }
  async getRoomsByIds(roomIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: roomTable.id,
        name: roomTable.name,
        channelId: roomTable.channelId,
        agentId: roomTable.agentId,
        serverId: roomTable.serverId,
        worldId: roomTable.worldId,
        type: roomTable.type,
        source: roomTable.source,
        metadata: roomTable.metadata
      }).from(roomTable).where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async getRoomsByWorld(worldId) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? undefined,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  async updateRoom(room) {
    return this.withDatabase(async () => {
      await this.db.update(roomTable).set({ ...room, agentId: this.agentId }).where(eq(roomTable.id, room.id));
    });
  }
  async createRooms(rooms) {
    return this.withDatabase(async () => {
      const roomsWithIds = rooms.map((room) => ({
        ...room,
        agentId: this.agentId,
        id: room.id || v4()
      }));
      const insertedRooms = await this.db.insert(roomTable).values(roomsWithIds).onConflictDoNothing().returning();
      const insertedIds = insertedRooms.map((r) => r.id);
      return insertedIds;
    });
  }
  async deleteRoom(roomId) {
    if (!roomId)
      throw new Error("Room ID is required");
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(roomTable).where(eq(roomTable.id, roomId));
      });
    });
  }
  async getRoomsForParticipant(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async getRoomsForParticipants(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.selectDistinct({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  async addParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(participantTable).values({
          entityId,
          roomId,
          agentId: this.agentId
        }).onConflictDoNothing();
        return true;
      } catch (error) {
        logger8.error(`Error adding participant to room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this.withDatabase(async () => {
      try {
        const values = entityIds.map((id) => ({
          entityId: id,
          roomId,
          agentId: this.agentId
        }));
        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();
        logger8.debug(`${entityIds.length} Entities linked successfully`);
        return true;
      } catch (error) {
        logger8.error(`Error adding participants to room: ${error instanceof Error ? error.message : String(error)}, entityIdSample: ${entityIds[0]}, roomId: ${roomId}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async removeParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.transaction(async (tx) => {
          return await tx.delete(participantTable).where(and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))).returning();
        });
        const removed = result.length > 0;
        logger8.debug(`Participant ${removed ? "removed" : "not found"}: entityId: ${entityId}, roomId: ${roomId}, removed: ${removed}`);
        return removed;
      } catch (error) {
        logger8.error(`Error removing participant from room: ${error instanceof Error ? error.message : String(error)}, entityId: ${entityId}, roomId: ${roomId}`);
        return false;
      }
    });
  }
  async getParticipantsForEntity(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: participantTable.id,
        entityId: participantTable.entityId,
        roomId: participantTable.roomId
      }).from(participantTable).where(eq(participantTable.entityId, entityId));
      const entities = await this.getEntitiesByIds([entityId]);
      if (!entities || !entities.length) {
        return [];
      }
      return result.map((row) => ({
        id: row.id,
        entity: entities[0]
      }));
    });
  }
  async getParticipantsForRoom(roomId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ entityId: participantTable.entityId }).from(participantTable).where(eq(participantTable.roomId, roomId));
      return result.map((row) => row.entityId);
    });
  }
  async getParticipantUserState(roomId, entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomState: participantTable.roomState }).from(participantTable).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId))).limit(1);
      return result[0]?.roomState ?? null;
    });
  }
  async setParticipantUserState(roomId, entityId, state) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.update(participantTable).set({ roomState: state }).where(and(eq(participantTable.roomId, roomId), eq(participantTable.entityId, entityId), eq(participantTable.agentId, this.agentId)));
        });
      } catch (error) {
        logger8.error(`Error setting participant follow state: roomId: ${roomId}, entityId: ${entityId}, state: ${state}, error: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    });
  }
  async createRelationship(params) {
    return this.withDatabase(async () => {
      const id = v4();
      const saveParams = {
        id,
        sourceEntityId: params.sourceEntityId,
        targetEntityId: params.targetEntityId,
        agentId: this.agentId,
        tags: params.tags || [],
        metadata: params.metadata || {}
      };
      try {
        await this.db.insert(relationshipTable).values(saveParams);
        return true;
      } catch (error) {
        logger8.error(`Error creating relationship: ${error instanceof Error ? error.message : String(error)}, saveParams: ${JSON.stringify(saveParams)}`);
        return false;
      }
    });
  }
  async updateRelationship(relationship) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(relationshipTable).set({
          tags: relationship.tags || [],
          metadata: relationship.metadata || {}
        }).where(eq(relationshipTable.id, relationship.id));
      } catch (error) {
        logger8.error(`Error updating relationship: ${error instanceof Error ? error.message : String(error)}, relationship: ${JSON.stringify(relationship)}`);
        throw error;
      }
    });
  }
  async getRelationship(params) {
    return this.withDatabase(async () => {
      const { sourceEntityId, targetEntityId } = params;
      const result = await this.db.select().from(relationshipTable).where(and(eq(relationshipTable.sourceEntityId, sourceEntityId), eq(relationshipTable.targetEntityId, targetEntityId)));
      if (result.length === 0)
        return null;
      const relationship = result[0];
      return {
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt.toISOString()
      };
    });
  }
  async getRelationships(params) {
    return this.withDatabase(async () => {
      const { entityId, tags } = params;
      let query;
      if (tags && tags.length > 0) {
        query = sql`
          SELECT * FROM ${relationshipTable}
          WHERE (${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId})
          AND ${relationshipTable.tags} && CAST(ARRAY[${sql.join(tags, sql`, `)}] AS text[])
        `;
      } else {
        query = sql`
          SELECT * FROM ${relationshipTable}
          WHERE ${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId}
        `;
      }
      const result = await this.db.execute(query);
      return result.rows.map((relationship) => ({
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt ? relationship.createdAt instanceof Date ? relationship.createdAt.toISOString() : new Date(relationship.createdAt).toISOString() : new Date().toISOString()
      }));
    });
  }
  async getCache(key) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ value: cacheTable.value }).from(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key))).limit(1);
        if (result && result.length > 0 && result[0]) {
          return result[0].value;
        }
        return;
      } catch (error) {
        logger8.error(`Error fetching cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return;
      }
    });
  }
  async setCache(key, value) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(cacheTable).values({
          key,
          agentId: this.agentId,
          value
        }).onConflictDoUpdate({
          target: [cacheTable.key, cacheTable.agentId],
          set: {
            value
          }
        });
        return true;
      } catch (error) {
        logger8.error(`Error setting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async deleteCache(key) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.delete(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        });
        return true;
      } catch (error) {
        logger8.error(`Error deleting cache: ${error instanceof Error ? error.message : String(error)}, key: ${key}, agentId: ${this.agentId}`);
        return false;
      }
    });
  }
  async createWorld(world) {
    return this.withDatabase(async () => {
      const newWorldId = world.id || v4();
      await this.db.insert(worldTable).values({
        ...world,
        id: newWorldId,
        name: world.name || ""
      });
      return newWorldId;
    });
  }
  async getWorld(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));
      return result.length > 0 ? result[0] : null;
    });
  }
  async getAllWorlds() {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.agentId, this.agentId));
      return result;
    });
  }
  async updateWorld(world) {
    return this.withDatabase(async () => {
      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));
    });
  }
  async removeWorld(id) {
    return this.withDatabase(async () => {
      await this.db.delete(worldTable).where(eq(worldTable.id, id));
    });
  }
  async createTask(task) {
    if (!task.worldId) {
      throw new Error("worldId is required");
    }
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const now = new Date;
        const metadata = task.metadata || {};
        const values = {
          id: task.id,
          name: task.name,
          description: task.description,
          roomId: task.roomId,
          worldId: task.worldId,
          tags: task.tags,
          metadata,
          createdAt: now,
          updatedAt: now,
          agentId: this.agentId
        };
        const result = await this.db.insert(taskTable).values(values).returning();
        return result[0].id;
      });
    });
  }
  async getTasks(params) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.agentId, this.agentId), ...params.roomId ? [eq(taskTable.roomId, params.roomId)] : [], ...params.tags && params.tags.length > 0 ? [
          sql`${taskTable.tags} @> ARRAY[${sql.raw(params.tags.map((t) => `'${t.replace(/'/g, "''")}'`).join(", "))}]::text[]`
        ] : []));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata
        }));
      });
    });
  }
  async getTasksByName(name) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        }));
      });
    });
  }
  async getTask(id) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId))).limit(1);
        if (result.length === 0) {
          return null;
        }
        const row = result[0];
        return {
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        };
      });
    });
  }
  async updateTask(id, task) {
    await this.withRetry(async () => {
      await this.withDatabase(async () => {
        const updateValues = {};
        if (task.name !== undefined)
          updateValues.name = task.name;
        if (task.description !== undefined)
          updateValues.description = task.description;
        if (task.roomId !== undefined)
          updateValues.roomId = task.roomId;
        if (task.worldId !== undefined)
          updateValues.worldId = task.worldId;
        if (task.tags !== undefined)
          updateValues.tags = task.tags;
        updateValues.updatedAt = new Date;
        if (task.metadata !== undefined) {
          updateValues.metadata = task.metadata;
        }
        await this.db.update(taskTable).set(updateValues).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));
      });
    });
  }
  async deleteTask(id) {
    return this.withDatabase(async () => {
      await this.db.delete(taskTable).where(eq(taskTable.id, id));
    });
  }
  async getMemoriesByWorldId(params) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        return [];
      }
      const roomIds = rooms.map((room) => room.id);
      const memories = await this.getMemoriesByRoomIds({
        roomIds,
        tableName: params.tableName || "messages",
        limit: params.count
      });
      return memories;
    });
  }
  async deleteRoomsByWorldId(worldId) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        logger8.debug(`No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`);
        return;
      }
      const roomIds = rooms.map((room) => room.id);
      if (roomIds.length > 0) {
        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));
        logger8.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);
        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
        logger8.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);
        const memoriesInRooms = await this.db.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id);
        if (memoryIdsInRooms.length > 0) {
          await this.db.delete(embeddingTable).where(inArray(embeddingTable.memoryId, memoryIdsInRooms));
          logger8.debug(`Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`);
          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));
          logger8.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);
        }
        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));
        logger8.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);
      }
    });
  }
  async createMessageServer(data) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = new Date;
      const serverToInsert = {
        id: newId,
        name: data.name,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageServerTable).values(serverToInsert).onConflictDoNothing();
      if (data.id) {
        const existing = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, data.id)).limit(1);
        if (existing.length > 0) {
          return {
            id: existing[0].id,
            name: existing[0].name,
            sourceType: existing[0].sourceType,
            sourceId: existing[0].sourceId || undefined,
            metadata: existing[0].metadata || undefined,
            createdAt: existing[0].createdAt,
            updatedAt: existing[0].updatedAt
          };
        }
      }
      return serverToInsert;
    });
  }
  async getMessageServers() {
    const result = await this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable);
      return results.map((r) => ({
        id: r.id,
        name: r.name,
        sourceType: r.sourceType,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
    return result || [];
  }
  async getMessageServerById(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, serverId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        name: results[0].name,
        sourceType: results[0].sourceType,
        sourceId: results[0].sourceId || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createChannel(data, participantIds) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = new Date;
      const channelToInsert = {
        id: newId,
        messageServerId: data.messageServerId,
        name: data.name,
        type: data.type,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        topic: data.topic,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.transaction(async (tx) => {
        await tx.insert(channelTable).values(channelToInsert);
        if (participantIds && participantIds.length > 0) {
          const participantValues = participantIds.map((userId) => ({
            channelId: newId,
            userId
          }));
          await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
        }
      });
      return channelToInsert;
    });
  }
  async getChannelsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.messageServerId, serverId));
      return results.map((r) => ({
        id: r.id,
        messageServerId: r.messageServerId,
        name: r.name,
        type: r.type,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        topic: r.topic || undefined,
        metadata: r.metadata || undefined,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async getChannelDetails(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.id, channelId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        messageServerId: results[0].messageServerId,
        name: results[0].name,
        type: results[0].type,
        sourceType: results[0].sourceType || undefined,
        sourceId: results[0].sourceId || undefined,
        topic: results[0].topic || undefined,
        metadata: results[0].metadata || undefined,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  async createMessage(data) {
    return this.withDatabase(async () => {
      const newId = data.messageId || v4();
      const now = new Date;
      const messageToInsert = {
        id: newId,
        channelId: data.channelId,
        authorId: data.authorId,
        content: data.content,
        rawMessage: data.rawMessage,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        inReplyToRootMessageId: data.inReplyToRootMessageId,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageTable).values(messageToInsert);
      return messageToInsert;
    });
  }
  async getMessageById(id) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(messageTable).where(eq(messageTable.id, id)).limit(1);
      return rows?.[0] ?? null;
    });
  }
  async updateMessage(id, patch) {
    return this.withDatabase(async () => {
      const existing = await this.getMessageById(id);
      if (!existing)
        return null;
      const updatedAt = new Date;
      const next = {
        content: patch.content ?? existing.content,
        rawMessage: patch.rawMessage ?? existing.rawMessage,
        sourceType: patch.sourceType ?? existing.sourceType,
        sourceId: patch.sourceId ?? existing.sourceId,
        metadata: patch.metadata ?? existing.metadata,
        inReplyToRootMessageId: patch.inReplyToRootMessageId ?? existing.inReplyToRootMessageId,
        updatedAt
      };
      await this.db.update(messageTable).set(next).where(eq(messageTable.id, id));
      return {
        ...existing,
        ...next
      };
    });
  }
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.withDatabase(async () => {
      const conditions2 = [eq(messageTable.channelId, channelId)];
      if (beforeTimestamp) {
        conditions2.push(lt(messageTable.createdAt, beforeTimestamp));
      }
      const query = this.db.select().from(messageTable).where(and(...conditions2)).orderBy(desc(messageTable.createdAt)).limit(limit);
      const results = await query;
      return results.map((r) => ({
        id: r.id,
        channelId: r.channelId,
        authorId: r.authorId,
        content: r.content,
        rawMessage: r.rawMessage || undefined,
        sourceType: r.sourceType || undefined,
        sourceId: r.sourceId || undefined,
        metadata: r.metadata || undefined,
        inReplyToRootMessageId: r.inReplyToRootMessageId,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  async deleteMessage(messageId) {
    return this.withDatabase(async () => {
      await this.db.delete(messageTable).where(eq(messageTable.id, messageId));
    });
  }
  async updateChannel(channelId, updates) {
    return this.withDatabase(async () => {
      const now = new Date;
      await this.db.transaction(async (tx) => {
        const updateData = { updatedAt: now };
        if (updates.name !== undefined)
          updateData.name = updates.name;
        if (updates.metadata !== undefined)
          updateData.metadata = updates.metadata;
        await tx.update(channelTable).set(updateData).where(eq(channelTable.id, channelId));
        if (updates.participantCentralUserIds !== undefined) {
          await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
          if (updates.participantCentralUserIds.length > 0) {
            const participantValues = updates.participantCentralUserIds.map((userId) => ({
              channelId,
              userId
            }));
            await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
          }
        }
      });
      const updatedChannel = await this.getChannelDetails(channelId);
      if (!updatedChannel) {
        throw new Error(`Channel ${channelId} not found after update`);
      }
      return updatedChannel;
    });
  }
  async deleteChannel(channelId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(messageTable).where(eq(messageTable.channelId, channelId));
        await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
        await tx.delete(channelTable).where(eq(channelTable.id, channelId));
      });
    });
  }
  async addChannelParticipants(channelId, userIds) {
    return this.withDatabase(async () => {
      if (!userIds || userIds.length === 0)
        return;
      const participantValues = userIds.map((userId) => ({
        channelId,
        userId
      }));
      await this.db.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
    });
  }
  async getChannelParticipants(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ userId: channelParticipantsTable.userId }).from(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
      return results.map((r) => r.userId);
    });
  }
  async addAgentToServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.insert(serverAgentsTable).values({
        serverId,
        agentId
      }).onConflictDoNothing();
    });
  }
  async getAgentsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ agentId: serverAgentsTable.agentId }).from(serverAgentsTable).where(eq(serverAgentsTable.serverId, serverId));
      return results.map((r) => r.agentId);
    });
  }
  async removeAgentFromServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.delete(serverAgentsTable).where(and(eq(serverAgentsTable.serverId, serverId), eq(serverAgentsTable.agentId, agentId)));
    });
  }
  async findOrCreateDmChannel(user1Id, user2Id, messageServerId) {
    return this.withDatabase(async () => {
      const ids = [user1Id, user2Id].sort();
      const dmChannelName = `DM-${ids[0]}-${ids[1]}`;
      const existingChannels = await this.db.select().from(channelTable).where(and(eq(channelTable.type, ChannelType.DM), eq(channelTable.name, dmChannelName), eq(channelTable.messageServerId, messageServerId))).limit(1);
      if (existingChannels.length > 0) {
        return {
          id: existingChannels[0].id,
          messageServerId: existingChannels[0].messageServerId,
          name: existingChannels[0].name,
          type: existingChannels[0].type,
          sourceType: existingChannels[0].sourceType || undefined,
          sourceId: existingChannels[0].sourceId || undefined,
          topic: existingChannels[0].topic || undefined,
          metadata: existingChannels[0].metadata || undefined,
          createdAt: existingChannels[0].createdAt,
          updatedAt: existingChannels[0].updatedAt
        };
      }
      return this.createChannel({
        messageServerId,
        name: dmChannelName,
        type: ChannelType.DM,
        metadata: { user1: ids[0], user2: ids[1] }
      }, ids);
    });
  }
}

// src/pglite/adapter.ts
class PgliteDatabaseAdapter extends BaseDrizzleAdapter {
  manager;
  embeddingDimension = DIMENSION_MAP[384];
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.db = drizzle(this.manager.getConnection());
  }
  async getEntityByIds(entityIds) {
    return this.getEntitiesByIds(entityIds);
  }
  async getMemoriesByServerId(_params) {
    logger9.warn("getMemoriesByServerId called but not implemented - returning empty array");
    return [];
  }
  async ensureAgentExists(agent) {
    const existingAgent = await this.getAgent(this.agentId);
    if (existingAgent) {
      return existingAgent;
    }
    const newAgent = {
      id: this.agentId,
      name: agent.name || "Unknown Agent",
      username: agent.username,
      bio: agent.bio || "An AI agent",
      createdAt: agent.createdAt || Date.now(),
      updatedAt: agent.updatedAt || Date.now()
    };
    await this.createAgent(newAgent);
    const createdAgent = await this.getAgent(this.agentId);
    if (!createdAgent) {
      throw new Error("Failed to create agent");
    }
    return createdAgent;
  }
  async withDatabase(operation) {
    if (this.manager.isShuttingDown()) {
      logger9.warn("Database is shutting down");
      return null;
    }
    return operation();
  }
  async init() {
    logger9.debug("PGliteDatabaseAdapter initialized, skipping automatic migrations.");
  }
  async isReady() {
    return !this.manager.isShuttingDown();
  }
  async close() {
    await this.manager.close();
  }
  async getConnection() {
    return this.manager.getConnection();
  }
}

// src/pglite/manager.ts
import { PGlite as PGlite2 } from "@electric-sql/pglite";
import { fuzzystrmatch } from "@electric-sql/pglite/contrib/fuzzystrmatch";
import { vector as vector4 } from "@electric-sql/pglite/vector";

class PGliteClientManager {
  client;
  shuttingDown = false;
  constructor(options) {
    this.client = new PGlite2({
      ...options,
      extensions: {
        vector: vector4,
        fuzzystrmatch
      }
    });
    this.setupShutdownHandlers();
  }
  getConnection() {
    return this.client;
  }
  isShuttingDown() {
    return this.shuttingDown;
  }
  async initialize() {}
  async close() {
    this.shuttingDown = true;
  }
  setupShutdownHandlers() {}
}

// src/pg/adapter.ts
import { logger as logger10 } from "@elizaos/core";

// ../../node_modules/drizzle-orm/node-postgres/driver.js
init_entity();
init_logger();
init_db();
init_dialect();
init_relations();
init_utils();
import pg2 from "pg";

// ../../node_modules/drizzle-orm/node-postgres/session.js
import pg from "pg";
init_entity();
init_logger();
init_pg_core();
init_session();
init_sql();
init_tracing();
init_utils();
var { Pool, types: types3 } = pg;

class NodePgPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger10, cache, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger10;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      name,
      text: queryString,
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types3.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types3.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types3.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types3.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types3.getTypeParser(typeId, format);
        }
      }
    };
    this.queryConfig = {
      name,
      text: queryString,
      rowMode: "array",
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types3.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types3.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types3.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types3.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types3.getTypeParser(typeId, format);
        }
      }
    };
  }
  static [entityKind] = "NodePgPreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", async (span) => {
          span?.setAttributes({
            "drizzle.query.name": rawQuery.name,
            "drizzle.query.text": rawQuery.text,
            "drizzle.query.params": JSON.stringify(params)
          });
          return this.queryWithCache(rawQuery.text, params, async () => {
            return await client.query(rawQuery, params);
          });
        });
      }
      const result = await tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": query.name,
          "drizzle.query.text": query.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(query.text, params, async () => {
          return await client.query(query, params);
        });
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      return tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": this.rawQueryConfig.name,
          "drizzle.query.text": this.rawQueryConfig.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(this.rawQueryConfig.text, params, async () => {
          return this.client.query(this.rawQueryConfig, params);
        }).then((result) => result.rows);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class NodePgSession extends PgSession {
  constructor(client, dialect2, schema2, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema2;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "NodePgSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new NodePgPreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    const session2 = this.client instanceof Pool ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;
    const tx = new NodePgTransaction(this.dialect, session2, this.schema);
    await tx.execute(sql`begin${config ? sql` ${tx.getTransactionConfigSQL(config)}` : undefined}`);
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (error) {
      await tx.execute(sql`rollback`);
      throw error;
    } finally {
      if (this.client instanceof Pool) {
        session2.client.release();
      }
    }
  }
  async count(sql22) {
    const res = await this.execute(sql22);
    return Number(res["rows"][0]["count"]);
  }
}

class NodePgTransaction extends PgTransaction {
  static [entityKind] = "NodePgTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new NodePgTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// ../../node_modules/drizzle-orm/node-postgres/driver.js
class NodePgDriver {
  constructor(client, dialect2, options = {}) {
    this.client = client;
    this.dialect = dialect2;
    this.options = options;
  }
  static [entityKind] = "NodePgDriver";
  createSession(schema2) {
    return new NodePgSession(this.client, this.dialect, schema2, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class NodePgDatabase extends PgDatabase {
  static [entityKind] = "NodePgDatabase";
}
function construct2(client, config = {}) {
  const dialect2 = new PgDialect({ casing: config.casing });
  let logger10;
  if (config.logger === true) {
    logger10 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger10 = config.logger;
  }
  let schema2;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema2 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NodePgDriver(client, dialect2, { logger: logger10, cache: config.cache });
  const session2 = driver.createSession(schema2);
  const db2 = new NodePgDatabase(dialect2, session2, schema2);
  db2.$client = client;
  db2.$cache = config.cache;
  if (db2.$cache) {
    db2.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db2;
}
function drizzle2(...params) {
  if (typeof params[0] === "string") {
    const instance = new pg2.Pool({
      connectionString: params[0]
    });
    return construct2(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct2(client, drizzleConfig);
    const instance = typeof connection === "string" ? new pg2.Pool({
      connectionString: connection
    }) : new pg2.Pool(connection);
    return construct2(instance, drizzleConfig);
  }
  return construct2(params[0], params[1]);
}
((drizzle22) => {
  function mock(config) {
    return construct2({}, config);
  }
  drizzle22.mock = mock;
})(drizzle2 || (drizzle2 = {}));

// src/pg/adapter.ts
class PgDatabaseAdapter extends BaseDrizzleAdapter {
  embeddingDimension = DIMENSION_MAP[384];
  manager;
  constructor(agentId, manager, _schema) {
    super(agentId);
    this.manager = manager;
    this.db = manager.getDatabase();
  }
  async getEntityByIds(entityIds) {
    return this.getEntitiesByIds(entityIds);
  }
  async getMemoriesByServerId(_params) {
    logger10.warn("getMemoriesByServerId called but not implemented - returning empty array");
    return [];
  }
  async ensureAgentExists(agent) {
    const existingAgent = await this.getAgent(this.agentId);
    if (existingAgent) {
      return existingAgent;
    }
    const newAgent = {
      id: this.agentId,
      name: agent.name || "Unknown Agent",
      username: agent.username,
      bio: agent.bio || "An AI agent",
      createdAt: agent.createdAt || Date.now(),
      updatedAt: agent.updatedAt || Date.now()
    };
    await this.createAgent(newAgent);
    const createdAgent = await this.getAgent(this.agentId);
    if (!createdAgent) {
      throw new Error("Failed to create agent");
    }
    return createdAgent;
  }
  async withDatabase(operation) {
    return await this.withRetry(async () => {
      const client = await this.manager.getClient();
      try {
        const db2 = drizzle2(client);
        this.db = db2;
        return await operation();
      } finally {
        client.release();
      }
    });
  }
  async init() {
    logger10.debug("PgDatabaseAdapter initialized, skipping automatic migrations.");
  }
  async isReady() {
    return this.manager.testConnection();
  }
  async close() {
    await this.manager.close();
  }
  async getConnection() {
    return this.manager.getConnection();
  }
  async createAgent(agent) {
    return super.createAgent(agent);
  }
  getAgent(agentId) {
    return super.getAgent(agentId);
  }
  updateAgent(agentId, agent) {
    return super.updateAgent(agentId, agent);
  }
  deleteAgent(agentId) {
    return super.deleteAgent(agentId);
  }
  createEntities(entities) {
    return super.createEntities(entities);
  }
  getEntitiesByIds(entityIds) {
    return super.getEntitiesByIds(entityIds).then((result) => result || []);
  }
  updateEntity(entity2) {
    return super.updateEntity(entity2);
  }
  createMemory(memory, tableName) {
    return super.createMemory(memory, tableName);
  }
  getMemoryById(memoryId) {
    return super.getMemoryById(memoryId);
  }
  searchMemories(params) {
    return super.searchMemories(params);
  }
  updateMemory(memory) {
    return super.updateMemory(memory);
  }
  deleteMemory(memoryId) {
    return super.deleteMemory(memoryId);
  }
  createComponent(component) {
    return super.createComponent(component);
  }
  getComponent(entityId, type, worldId, sourceEntityId) {
    return super.getComponent(entityId, type, worldId, sourceEntityId);
  }
  updateComponent(component) {
    return super.updateComponent(component);
  }
  deleteComponent(componentId) {
    return super.deleteComponent(componentId);
  }
}

// src/pg/manager.ts
import { Pool as Pool2 } from "pg";
import { logger as logger11 } from "@elizaos/core";

class PostgresConnectionManager {
  pool;
  db;
  constructor(connectionString) {
    this.pool = new Pool2({ connectionString });
    this.db = drizzle2(this.pool);
  }
  getDatabase() {
    return this.db;
  }
  getConnection() {
    return this.pool;
  }
  async getClient() {
    return this.pool.connect();
  }
  async testConnection() {
    let client = null;
    try {
      client = await this.pool.connect();
      await client.query("SELECT 1");
      return true;
    } catch (error) {
      logger11.error(`Failed to connect to the database: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    } finally {
      if (client) {
        client.release();
      }
    }
  }
  async close() {
    await this.pool.end();
  }
}

// src/utils.node.ts
import dotenv from "dotenv";
import { existsSync } from "node:fs";
import path from "node:path";
function expandTildePath(filepath) {
  if (filepath && filepath.startsWith("~")) {
    return path.join(process.cwd(), filepath.slice(1));
  }
  return filepath;
}
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path.join(startDir, ".env");
}
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync(envPath)) {
    dotenv.config({ path: envPath });
  }
  let monoPath;
  if (existsSync(path.join(process.cwd(), "packages", "core"))) {
    monoPath = process.cwd();
  } else {
    const twoUp = path.resolve(process.cwd(), "../..");
    if (existsSync(path.join(twoUp, "packages", "core"))) {
      monoPath = twoUp;
    }
  }
  const base = dir ?? process.env.PGLITE_DATA_DIR ?? fallbackDir ?? (monoPath ? path.join(monoPath, ".eliza", ".elizadb") : undefined) ?? path.join(process.cwd(), ".eliza", ".elizadb");
  const resolved = expandTildePath(base);
  const legacyPath = path.join(process.cwd(), ".elizadb");
  if (resolved === legacyPath) {
    const newPath = path.join(process.cwd(), ".eliza", ".elizadb");
    process.env.PGLITE_DATA_DIR = newPath;
    return newPath;
  }
  return resolved;
}

// src/index.node.ts
init_migration_service();
var GLOBAL_SINGLETONS = Symbol.for("@elizaos/plugin-sql/global-singletons");
var globalSymbols = globalThis;
if (!globalSymbols[GLOBAL_SINGLETONS]) {
  globalSymbols[GLOBAL_SINGLETONS] = {};
}
var globalSingletons = globalSymbols[GLOBAL_SINGLETONS];
function createDatabaseAdapter(config, agentId) {
  if (config.postgresUrl) {
    if (!globalSingletons.postgresConnectionManager) {
      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(config.postgresUrl);
    }
    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);
  }
  const dataDir = resolvePgliteDir(config.dataDir);
  if (!globalSingletons.pgLiteClientManager) {
    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });
  }
  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);
}
var plugin = {
  name: "@elizaos/plugin-sql",
  description: "A plugin for SQL database access with dynamic schema migrations",
  priority: 0,
  schema: exports_schema,
  init: async (_config, runtime) => {
    logger12.info("plugin-sql (node) init starting...");
    const adapterRegistered = await runtime.isReady().then(() => true).catch((error) => {
      const message = error instanceof Error ? error.message : String(error);
      if (message.includes("Database adapter not registered")) {
        logger12.info("No pre-registered database adapter detected; registering adapter");
      } else {
        logger12.warn({ error }, "Database adapter readiness check error; proceeding to register adapter");
      }
      return false;
    });
    if (adapterRegistered) {
      logger12.info("Database adapter already registered, skipping creation");
      return;
    }
    const postgresUrl = runtime.getSetting("POSTGRES_URL");
    const dataDir = runtime.getSetting("PGLITE_DATA_DIR") || undefined;
    const dbAdapter = createDatabaseAdapter({
      dataDir,
      postgresUrl
    }, runtime.agentId);
    runtime.registerDatabaseAdapter(dbAdapter);
    logger12.info("Database adapter created and registered");
  }
};
var index_node_default = plugin;
export {
  plugin,
  index_node_default as default,
  createDatabaseAdapter,
  DatabaseMigrationService
};

//# debugId=F87541CC826D31E064756E2164756E21
//# sourceMappingURL=index.node.js.map
